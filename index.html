<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HexWright</title>
    <link rel="icon" href="favicon.png" type="image/png">
  </head>

  <link href='https://fonts.googleapis.com/css?family=Almendra' rel='stylesheet'>
  <!--
  Almendra SC
  MedievalSharp
  Uncial Antiqua
  UnifrakturCook
  UnifrakturMaguntia

  -->

  <link rel="stylesheet" href="niftyButton.css">
  <link rel="stylesheet" href="mapInfo.css">
  <link rel="stylesheet" href="helpWindow.css">

  <script src="drawBridge.js"></script>
  <script src="decorations.js"></script>

  <style>

    body {
      height: 100%
    }


    #toolOpener {

      position: fixed;
      top: 23%;
      right: 1%;
      z-index: 10;

      height: 5%;
      aspect-ratio: 1.1547; /* Approx height-to-width ratio for a regular hex */
      background: #2200ff;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      /* line-height: 60px; */
      clip-path: polygon(
        25% 0%,
        75% 0%,
        100% 50%,
        75% 100%,
        25% 100%,
        0% 50%
      );

      /* text-shadow: 1px 1px 0px black,
                  -1px -1px 0px black,
                   1px -1px 0px black,
                  -1px  1px 0px black; */
      text-shadow: 1px 1px;

      transition: all 0.5s ease;

    }

    #toolOpenerInner {
      clip-path: inherit;
      height: 90%;
      width:90%;
      background: #22aa11;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;

    }


    #operationOpener {

      z-index: 10;
      position: fixed;
      top: 3%;
      left: 3%;
      height: 5%;
      aspect-ratio: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      background-color: white;
      border-radius: 50%;
      box-shadow: 0 0 10px 5px rgba(0, 0, 0, 0.2);
      transition: all 0.5s ease;

    }

    #operationOpener img {

      width: 80%;
      height: 80%;
      object-fit: contain;

    }


    .menuDiv {
      font-family: 'Almendra';
      font-size: 24px;
      z-index: 10;
      position: fixed;

      background: white;
      border: 1px solid #ccc;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.15);
      padding: 10px;
      display: none;
      z-index: 999;
      border-radius: 8px;
    }

    #operationMenu {

      top: 3%;
      left: 3%;

      display: none;



    }

    #toolMenu {

      top: 3%;
      right: 1%;

      display: none;



    }

    .menuItemSpan {

      transition: all 0.2s ease;
      cursor: pointer;

    }

    .menuItemSpan:hover {

      background-color: 999999;
      text-decoration: underline;

    }

    #mapDisplayDiv {

      border: solid thin;
      position: fixed;
      left: 1%;
      width: 98%;
      top: 1%;
      height: 77%;
      transition: height 0.5s ease;
      overflow: hidden;

    }

    #miniMapDiv {
      z-index: 10;
      position: fixed;
      width: 25%;
      top: 1%;
      height: 25%;
      right: 1%;
      transition: opacity 0.3s ease;
      border: solid thin;

    }

    #textDisplayArea {
      border: solid thin;
      position: fixed;
      left: 1%;
      width: 98%;
      bottom: 1%;
      height: 20%;

      padding: 10px;
      box-sizing: border-box;

      overflow-x: hidden;  /* No horizontal scrollbar */
      overflow-y: auto;    /* Vertical scrollbar when needed */

      /* border: solid thin; */
      transition: height 0.5s ease;

      /* background-color: #f4e9d9;
      background-image:
          repeating-linear-gradient(45deg, transparent, transparent 2px, rgba(139, 69, 19, 0.05) 2px, rgba(139, 69, 19, 0.05) 4px),
          repeating-linear-gradient(-45deg, transparent, transparent 2px, rgba(160, 82, 45, 0.03) 2px, rgba(160, 82, 45, 0.03) 4px); */

          /* background:
              radial-gradient(ellipse 80px 60px at 20% 30%, rgba(139, 69, 19, 0.15) 0%, transparent 70%),
              radial-gradient(ellipse 120px 80px at 75% 20%, rgba(160, 82, 45, 0.12) 0%, transparent 65%),
              radial-gradient(ellipse 90px 70px at 60% 80%, rgba(210, 180, 140, 0.18) 0%, transparent 60%),
              radial-gradient(ellipse 110px 90px at 15% 75%, rgba(139, 69, 19, 0.10) 0%, transparent 75%),
              radial-gradient(ellipse 70px 100px at 85% 60%, rgba(160, 82, 45, 0.14) 0%, transparent 65%),
              #f4e9d9; */

              /* background:
                  radial-gradient(ellipse at 15% 20%, rgba(139, 69, 19, 0.08) 0%, transparent 40%),
                  radial-gradient(ellipse at 85% 10%, rgba(160, 82, 45, 0.06) 0%, transparent 35%),
                  radial-gradient(ellipse at 70% 60%, rgba(210, 180, 140, 0.12) 0%, transparent 45%),
                  radial-gradient(ellipse at 30% 80%, rgba(139, 69, 19, 0.05) 0%, transparent 30%),
                  radial-gradient(ellipse at 90% 85%, rgba(160, 82, 45, 0.07) 0%, transparent 38%),
                  radial-gradient(ellipse at 10% 70%, rgba(210, 180, 140, 0.09) 0%, transparent 42%),
                  radial-gradient(ellipse at 60% 25%, rgba(139, 69, 19, 0.04) 0%, transparent 35%),
                  radial-gradient(ellipse at 40% 45%, rgba(160, 82, 45, 0.08) 0%, transparent 40%),
                  linear-gradient(0deg, #f4e9d9, #f0e0c8); */

                  /* background:
                      radial-gradient(ellipse at 15% 20%, rgba(139, 69, 19, 0.25) 0%, transparent 40%),
                      radial-gradient(ellipse at 85% 10%, rgba(160, 82, 45, 0.20) 0%, transparent 35%),
                      radial-gradient(ellipse at 70% 60%, rgba(210, 180, 140, 0.35) 0%, transparent 45%),
                      radial-gradient(ellipse at 30% 80%, rgba(139, 69, 19, 0.18) 0%, transparent 30%),
                      radial-gradient(ellipse at 90% 85%, rgba(160, 82, 45, 0.22) 0%, transparent 38%),
                      radial-gradient(ellipse at 10% 70%, rgba(210, 180, 140, 0.28) 0%, transparent 42%),
                      radial-gradient(ellipse at 60% 25%, rgba(139, 69, 19, 0.15) 0%, transparent 35%),
                      radial-gradient(ellipse at 40% 45%, rgba(160, 82, 45, 0.24) 0%, transparent 40%),
                      linear-gradient(0deg, #f4e9d9, #f0e0c8); */


                      background:
                          radial-gradient(ellipse at 15% 20%, rgba(139, 69, 19, 0.35) 0%, transparent 40%),
                          radial-gradient(ellipse at 85% 10%, rgba(160, 82, 45, 0.30) 0%, transparent 35%),
                          radial-gradient(ellipse at 70% 60%, rgba(210, 180, 140, 0.45) 0%, transparent 45%),
                          radial-gradient(ellipse at 30% 80%, rgba(139, 69, 19, 0.28) 0%, transparent 30%),
                          radial-gradient(ellipse at 90% 85%, rgba(160, 82, 45, 0.32) 0%, transparent 38%),
                          radial-gradient(ellipse at 10% 70%, rgba(210, 180, 140, 0.38) 0%, transparent 42%),
                          radial-gradient(ellipse at 60% 25%, rgba(139, 69, 19, 0.25) 0%, transparent 35%),
                          radial-gradient(ellipse at 40% 45%, rgba(160, 82, 45, 0.34) 0%, transparent 40%),
                          /* Burned spots */
                          radial-gradient(ellipse at 25% 15%, rgba(101, 67, 33, 0.4) 0%, transparent 15%),
                          radial-gradient(ellipse at 80% 75%, rgba(92, 51, 23, 0.45) 0%, transparent 12%),
                          radial-gradient(ellipse at 50% 90%, rgba(139, 69, 19, 0.5) 0%, transparent 18%),
                          radial-gradient(ellipse at 12% 50%, rgba(85, 45, 18, 0.35) 0%, transparent 10%),
                          radial-gradient(ellipse at 90% 30%, rgba(101, 67, 33, 0.38) 0%, transparent 14%),
                          linear-gradient(0deg, #f4e9d9, #f0e0c8);

                      background-attachment: local;


      border: 1px solid #654321;
      color: #432100;

    }



    #bigMapImage {
      display: none;
      border: solid thin;


    }

    #bridgeWarningBox {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 400px;
        background: linear-gradient(135deg, #8b7355, #6b5b47);
        border: 2px solid #5a4a37;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        z-index: 1000;
        overflow: hidden;
    }


    .testMap {
      position: fixed;
      right: 2%;
      background-color: white;
      border: solid thin;
      z-index: 100;
      font-weight: bold;
      border-radius: 5%;
      /* width: 40px; */
      height: 20px;

    }

    #testMap1 {
      bottom: 40%;
    }

    #testMap2 {
      bottom: 36%;
    }

    #testMap3 {
      bottom: 32%;
    }

    #testMap4 {
      bottom: 28%;
    }

    #testMap5 {
      bottom: 24%;
    }

    #testMap6 {
      bottom: 20%;
    }

    #testMap7 {
      bottom: 16%;
    }

    #testMap8 {
      bottom: 12%;
    }




    #helpOpener {
      position: fixed;
      bottom: 2%;
      right: 2%;
      height: 5%;
      aspect-ratio: 1;
      background: rgba(255, 255, 255, 0.7);
      color: black;
      font-size: 24px;
      font-weight: bold;
      border-radius: 50%;
      box-shadow: 0 0 10px 5px rgba(0, 0, 0, 0.2);
      text-align: center;
      line-height: 40px;
      cursor: pointer;
      z-index: 10;
      backdrop-filter: blur(4px);
      transition: all 0.5s ease;
    }

    #helpIcon:hover {
      background: rgba(255, 255, 255, 0.9);
    }

    #helpMenu {
      position: fixed;
      bottom: 2%;
      right: 2%;
    }

    .dialogOverlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 9;
    }



    #paletteDiv {
        position: fixed;
        top: 20%;
        left: 20%;
        display: none;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        backdrop-filter: blur(10px);
        padding: 30px;
        width: 600px;
        gap: 30px;
    }

    .palleteDivLeft {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 15px;
    }

    .palleteDivright {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .color-picker-group {
        display: flex;
        flex-direction: column;
        gap: 12px;
    }

    .color-picker-item {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .color-picker-item label {
        font-weight: 500;
        color: #333;
        min-width: 80px;
        font-size: 14px;
    }

    .color-picker-item input[type="color"] {
        width: 40px;
        height: 30px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    }

    .palleteDivButtons {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        margin-bottom: 20px;
    }


    #paletteSampleCanvas {
        /* width: 100%;
        height: 200px; */
        border-radius: 12px;
        border: 2px solid #ddd;
        background: linear-gradient(45deg, #f9f9f9, #e9e9e9);
        box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .panel-title {
        font-size: 16px;
        font-weight: 700;
        color: #444;
        margin-bottom: 15px;
        text-align: center;
        letter-spacing: 1px;
    }

    /* Tertools Grid Layout CSS Classes */
    .tertools-grid-layout {
        display: grid;
        grid-template-columns: auto auto 1fr;
        gap: 15px 20px;
        align-items: center;
    }

    .tertools-tool-name {
        text-align: right;
        font-weight: bold;
        color: #333;
    }

    .tertools-key-combo {
        background: #d4c4a8;
        color: #5a4a3a;
        padding: 4px 6px;
        border-radius: 4px;
        border: 1px solid #8b7355;
        font-family: monospace;
        font-weight: bold;
        text-align: center;
        min-width: 20px;
        display: inline-block;
    }

    .tertools-description {
        color: #666;
    }



  </style>


  <script>

    // global = {
    //   currentTool: 'clear',
    //   changed: 'no'
    // }

    const hexHeight = 100;
    const hexSide = hexHeight / Math.sqrt( 3 );
    const hexSideSquared = hexSide ** 2;
    const hexWidth = 2 * hexSide;

    focusX = 0;
    focusY = 0;

    zoomX = 0;
    zoomY = 0;
    zoomLevel = 300;

    let startX, startY;
    isDragging = false;

    undoStack = [];

    let bridgeStart;



//     const vertexStraddlingAngles = [
//     -2.7576,  // 8° CCW from vertex 0 (top-left)
//     -2.4784,  // 8° CW from vertex 0 (top-left)
//     -2.1108,  // 8° CCW from vertex 1 (top-right)
//     -1.8316,  // 8° CW from vertex 1 (top-right)
//     -1.4640,  // 8° CCW from vertex 2 (right)
//     -1.1848,  // 8° CW from vertex 2 (right)
//     -0.8172,  // 8° CCW from vertex 3 (bottom-right)
//     -0.5380,  // 8° CW from vertex 3 (bottom-right)
//     -0.1704,  // 8° CCW from vertex 4 (bottom-left)
//      0.1088,  // 8° CW from vertex 4 (bottom-left)
//      0.4764,  // 8° CCW from vertex 5 (left)
//      0.7556   // 8° CW from vertex 5 (left)
// ];

// const vertexStraddlingAngles = [
//     -2.7576,  // direction 0, CCW corner (top-left vertex, CCW angle)
//     -2.1108,  // direction 0, CW corner (top-right vertex, CCW angle)
//     -1.8316,  // direction 1, CCW corner (top-right vertex, CW angle)
//     -1.4640,  // direction 1, CW corner (right vertex, CCW angle)
//     -1.1848,  // direction 2, CCW corner (right vertex, CW angle)
//     -0.8172,  // direction 2, CW corner (bottom-right vertex, CCW angle)
//     -0.5380,  // direction 3, CCW corner (bottom-right vertex, CW angle)
//     -0.1704,  // direction 3, CW corner (bottom-left vertex, CCW angle)
//      0.1088,  // direction 4, CCW corner (bottom-left vertex, CW angle)
//      0.4764,  // direction 4, CW corner (left vertex, CCW angle)
//      0.7556,  // direction 5, CCW corner (left vertex, CW angle)
//     -2.4784   // direction 5, CW corner (top-left vertex, CW angle)
// ];

// const vertexStraddlingAngles = [
//     -2.7576,  // direction 0, CCW corner (top-left vertex, CCW angle)
//     -1.7104,  // direction 0, CW corner (top-right vertex, CCW angle)
//     -1.4312,  // direction 1, CCW corner (top-right vertex, CW angle)
//     -0.6632,  // direction 1, CW corner (right vertex, CCW angle)
//     -0.3840,  // direction 2, CCW corner (right vertex, CW angle)
//      0.3840,  // direction 2, CW corner (bottom-right vertex, CCW angle)
//      0.6632,  // direction 3, CCW corner (bottom-right vertex, CW angle)
//      1.4312,  // direction 3, CW corner (bottom-left vertex, CCW angle)
//      1.7104,  // direction 4, CCW corner (bottom-left vertex, CW angle)
//      2.4784,  // direction 4, CW corner (left vertex, CCW angle)
//      2.7576,  // direction 5, CCW corner (left vertex, CW angle)
//     -2.4784   // direction 5, CW corner (top-left vertex, CW angle)
// ];

// const vertexStraddlingAngles = [
//     -2.2340, // direction 0, CCW corner (top-left vertex, CCW angle)
//     -1.1868, // direction 0, CW corner (top-right vertex, CCW angle)
//     -0.9076, // direction 1, CCW corner (top-right vertex, CW angle)
//     -0.1396, // direction 1, CW corner (right vertex, CCW angle)
//      0.1396, // direction 2, CCW corner (right vertex, CW angle)
//      0.9076, // direction 2, CW corner (bottom-right vertex, CCW angle)
//      1.1868, // direction 3, CCW corner (bottom-right vertex, CW angle)
//      1.9548, // direction 3, CW corner (bottom-left vertex, CCW angle)
//      2.2340, // direction 4, CCW corner (bottom-left vertex, CW angle)
//      3.0020, // direction 4, CW corner (left vertex, CCW angle)
//      3.2812, // direction 5, CCW corner (left vertex, CW angle)
//     -1.9548  // direction 5, CW corner (top-left vertex, CW angle)
// ];

// const vertexStraddlingAngles = [
//     -1.1868, // direction 0, CCW corner (top-left vertex, CCW angle)
//     -0.1396, // direction 0, CW corner (top-right vertex, CCW angle)
//      0.1396, // direction 1, CCW corner (top-right vertex, CW angle)
//      0.9076, // direction 1, CW corner (right vertex, CCW angle)
//      1.1868, // direction 2, CCW corner (right vertex, CW angle)
//      1.9548, // direction 2, CW corner (bottom-right vertex, CCW angle)
//      2.2340, // direction 3, CCW corner (bottom-right vertex, CW angle)
//      3.0020, // direction 3, CW corner (bottom-left vertex, CCW angle)
//     -3.0584, // direction 4, CCW corner (bottom-left vertex, CW angle)
//     -2.2904, // direction 4, CW corner (left vertex, CCW angle)
//     -2.0112, // direction 5, CCW corner (left vertex, CW angle)
//     -0.9076  // direction 5, CW corner (top-left vertex, CW angle)
// ];


// const vertexStraddlingAngles = [
//      0.9076, // direction 0, CCW corner (top-left vertex, CCW angle)
//      1.9548, // direction 0, CW corner (top-right vertex, CCW angle)
//      2.2340, // direction 1, CCW corner (top-right vertex, CW angle)
//      3.0020, // direction 1, CW corner (right vertex, CCW angle)
//     -3.0584, // direction 2, CCW corner (right vertex, CW angle)
//     -2.2904, // direction 2, CW corner (bottom-right vertex, CCW angle)
//     -2.0112, // direction 3, CCW corner (bottom-right vertex, CW angle)
//     -0.9076, // direction 3, CW corner (bottom-left vertex, CCW angle)
//     -0.1396, // direction 4, CCW corner (bottom-left vertex, CW angle)
//      0.9076, // direction 4, CW corner (left vertex, CCW angle)
//      1.1868, // direction 5, CCW corner (left vertex, CW angle)
//      2.2340  // direction 5, CW corner (top-left vertex, CW angle)
// ];

const vertexStraddlingAngles = [
    -2.2340, // upper-left vertex, 8° CCW
    -1.9548, // upper-left vertex, 8° CW
    -1.1868, // upper-right vertex, 8° CCW
    -0.9076, // upper-right vertex, 8° CW
    -0.1396, // right vertex, 8° CCW
     0.1396, // right vertex, 8° CW
     0.9076, // lower-right vertex, 8° CCW
     1.1868, // lower-right vertex, 8° CW
     1.9548, // lower-left vertex, 8° CCW
     2.2340, // lower-left vertex, 8° CW
     3.0020, // left vertex, 8° CCW
    -3.0584  // left vertex, 8° CW
];

function drawAngleLines( centerX, centerY ) {

    let ctx = offscreenContext;

    // Draw the hexagon outline for reference
    ctx.strokeStyle = '#cccccc';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        const angle = i * Math.PI/3 - Math.PI*5/6;
        const x = centerX + hexSide * Math.cos(angle);
        const y = centerY + hexSide * Math.sin(angle);
        if (i === 0) {
            ctx.moveTo(x, y);
        } else {
            ctx.lineTo(x, y);
        }
    }
    ctx.closePath();
    ctx.stroke();

    // Draw lines for each angle
    const lineLength = hexSide * 1.2; // Extend beyond hex

    for (let i = 0; i < vertexStraddlingAngles.length; i++) {
        const angle = vertexStraddlingAngles[i];
        const endX = centerX + lineLength * Math.cos(angle);
        const endY = centerY + lineLength * Math.sin(angle);

        // Color code the lines by direction
        const direction = Math.floor(i / 2);
        const colors = ['#ff0000', '#ff8800', '#ffff00', '#00ff00', '#0088ff', '#8800ff'];
        ctx.strokeStyle = colors[direction];
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(endX, endY);
        ctx.stroke();

        // Add a label at the end of each line
        ctx.fillStyle = colors[direction];
        ctx.font = '12px Arial';
        ctx.fillText(`${i}`, endX + 5, endY + 5);
    }

    // Draw center point
    ctx.fillStyle = '#000000';
    ctx.beginPath();
    ctx.arc(centerX, centerY, 3, 0, 2 * Math.PI);
    ctx.fill();
}

// Usage example:
// drawAngleLines(ctx, 400, 300, 50);


    function initApp() {

      sampleMapContext = document.getElementById('paletteSampleCanvas').getContext("2d");

      const savedMap = localStorage.getItem('HexWrightWorking');
      if (savedMap) {

        document.getElementById("textDisplayArea").value = savedMap;

        convertTextToObject();

        document.getElementById('mapInfoShowDots').checked = (map.showDots === "yes");
        document.getElementById('mapInfoShowHex').checked = (map.showHexNumbers === "yes");
        document.getElementById('mapInfoTexture').checked = (map.texture === "yes");
        document.getElementById('mapInfoHandDrawn').checked = (map.handDrawn === "yes");

      } else {

        console.log('no saved map found, using default...');

        document.getElementById('textDisplayArea').value = document.getElementById('testText1').innerText;
        convertTextToObject();

        // map = {
        //   name: 'mapname',
        //   description: 'a map',
        //   showDots: 'yes',
        //   showHexNumbers: 'yes',
        //   grid: Array.from({ length: 6 }, () =>
        //     Array.from({ length: 6 }, () => [])
        //   ),
        //   palette: {
        //     lines: '#4C3270',
        //     clear: '#EEECF2',
        //     walls: '#4C3270',
        //     offboard: '#ffffff',
        //     water: '#483D8B',
        //     paths: '#bbb9f2',
        //     columns: '#4C3270',
        //     lava: '#aa0011'
        //   }
        // };

      }

//      global.miniMapSize = 'small';

      const fetchedSettings = localStorage.getItem('HexWrightSettings');
//      console.log('fetchedSettings:', fetchedSettings);
//      console.log('typeof fetchedSettings:', typeof fetchedSettings);
//      console.log('fetchedSettings === null:', fetchedSettings === null);
//      console.log('Boolean(fetchedSettings):', Boolean(fetchedSettings));

//    console.log(fetchedSettings);

      if ( fetchedSettings ) {

        global = JSON.parse( fetchedSettings );
//        console.log(global.currentTool);
        if (!global.hasOwnProperty('groupBy')) global.groupBy = 'terrain';
        document.querySelector(`input[name="groupBy"][value="${global.groupBy}"]`).checked = true;

        if (!global.hasOwnProperty('miniMapSize')) global.miniMapSize = 'medium';
        document.querySelector(`input[name="miniMapSize"][value="${global.miniMapSize}"]`).checked = true;

        if (!global.hasOwnProperty('miniMapPosition')) global.miniMapPosition = 'top-right';

        let iconFunction = 'set' + global.icons.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join('');

//        console.log(iconFunction);

        window[iconFunction]();

        setPrivacy( global.privacy );

//        console.log(global.currentTool);
        setTool( global.currentTool );

        updateMiniMapPosition();

      } else {

        global = {
          currentTool: 'offboard',
          currentTool: 'clear',
          groupBy: 'terrain',
          miniMapSize: 'medium',
          icons: "vertical-top-left",
          miniMapPosition: 'top-right'
        };

        showPrivacyDialog();


      }


      global.changed = 'no';

      setInterval(saveObjectToLS, 20000);

      window.addEventListener('resize', updateMiniMapSize);


      helpMenu = document.getElementById('helpMenu');
      toolMenu = document.getElementById('toolMenu');
      operationMenu = document.getElementById('operationMenu');
      helpDiv = document.getElementById('helpDiv');
      settingsDiv = document.getElementById('settingsDiv');
      paletteDiv = document.getElementById('paletteDiv');


      document.getElementById('fileInput').addEventListener('change', handleFileChange);
      document.getElementById('fileInput').addEventListener('click', handleFileChange);

      displayContext = displayCanvas.getContext('2d');
      offscreenContext = offscreenCanvas.getContext('2d');
      miniMapContext = miniMapCanvas.getContext('2d');

      operationOpener = document.getElementById('operationOpener');
      toolOpener = document.getElementById('toolOpener');
      helpOpener = document.getElementById('helpOpener');

      convertTextToObject();

      objectToOffscreen();

      focusX = offscreenCanvas.width / 2;
      focusY = offscreenCanvas.height / 2;

      offscreenToDisplay();

      updateMiniMapSize( global.miniMapSize );
      offscreenToMiniMap();

      undoStack.push(textDisplayArea.value);

      // this next part should let the system handle undos if they are editing
      // a text area, but if they are editing the map and thus nothing has
      // focus we will do our undo function.

      document.addEventListener('keydown', function(e) {
          // Check if any input/textarea is currently focused
          let activeElement = document.activeElement;
          let isEditingText = activeElement.tagName === 'TEXTAREA' ||
                             activeElement.tagName === 'INPUT' ||
                             activeElement.isContentEditable;

          // Only intercept undo if NOT editing text
          if (!isEditingText && (e.ctrlKey || e.metaKey) && e.key === 'z') {
              e.preventDefault();
              undo();
          }
      });

      window.addEventListener('pagehide', beforeGoodbye);

    }

    function displayAllMap() {
      document.getElementById('mapDisplayDiv').style.height = '98%';
//      document.getElementById('textDisplayArea').style.height = '0%';
      document.getElementById('textDisplayArea').style.display='none';

      setTimeout( offscreenToDisplay, 602 );
    }

    function displayAllText() {

      document.getElementById('mapDisplayDiv').style.height = '0%';
      document.getElementById('textDisplayArea').style.height = '97%';
      document.getElementById('textDisplayArea').style.display='block';

      setTimeout( offscreenToDisplay, 502 );
    }

    function displaySplit() {

      document.getElementById('mapDisplayDiv').style.height = '77%';
      document.getElementById('textDisplayArea').style.display='block';
      document.getElementById('textDisplayArea').style.height = '20%';

      setTimeout( offscreenToDisplay, 502 );
    }

    function toggleHelpDiv() {
      document.getElementById('helpDiv').classList.toggle('hidden');
    }

    function showDiv( theDiv ) {

      operationMenu.style.display='none';
      toolMenu.style.display='none';
      helpMenu.style.display='none';

      theDiv.style.display='block';

    }

    function hideDiv( theDiv ) {

      theDiv.style.display='none';

    }

    function saveObjectToLS() {

      if ( global.changed == 'no' || global.privacy < 2 ) {

        return

      }

//      localStorage.setItem('HexWrightWorking', JSON.stringify(map));

      localStorage.setItem('HexWrightWorking', document.getElementById("textDisplayArea").value );

      global.changed = 'no';

//      console.log('saved');

    }

    function openPalette() {

      setColorPickers();

      document.getElementById('colorDialogOverlay').style.display='block';

      paletteDiv.style.display = 'flex';

    }


    function updateMiniMapPosition() {

//      console.log( global.miniMapPosition );

      const newMiniMapPositionIndex = miniMapPositions.indexOf( global.miniMapPosition );

      switch( newMiniMapPositionIndex ) {
        case 0:
          document.getElementById('miniMapDiv').style.top = '1%';
          document.getElementById('miniMapDiv').style.right = '1%';
          document.getElementById('miniMapDiv').style.bottom = 'auto';
          document.getElementById('miniMapDiv').style.left = 'auto';
          break;
        case 1:
          document.getElementById('miniMapDiv').style.top = 'auto';
          document.getElementById('miniMapDiv').style.right = '1%';
          document.getElementById('miniMapDiv').style.bottom = '1%';
          document.getElementById('miniMapDiv').style.left = 'auto';
          break;
        case 2:
          document.getElementById('miniMapDiv').style.top = 'auto';
          document.getElementById('miniMapDiv').style.right = 'auto';
          document.getElementById('miniMapDiv').style.bottom = '1%';
          document.getElementById('miniMapDiv').style.left = '1%';
          break;
        case 3:
          document.getElementById('miniMapDiv').style.top = '1%';
          document.getElementById('miniMapDiv').style.right = 'auto';
          document.getElementById('miniMapDiv').style.bottom = 'auto';
          document.getElementById('miniMapDiv').style.left = '1%';
          break;
      }


    }

    const miniMapPositions = ['upper-right', 'lower-right', 'lower-left', 'upper-left'];

    function cycleMiniMapPosition() {

        const currentMiniMapPositionIndex = miniMapPositions.indexOf( global.miniMapPosition );
        const newMiniMapPositionIndex = ( currentMiniMapPositionIndex + 1 ) % 4;

        global.miniMapPosition = miniMapPositions[ newMiniMapPositionIndex ];

        saveSettings();

        updateMiniMapPosition();

    }

    function getMegaHexCenters( x, y ) {

      map.megaHexCenters = [{x:x,y:y}];

      // second, push centers above (and right of) given hex until we're out of bounds...
      // we are collecing starting points for rows

      let nextX = x+1;
      let nextY = y - 2 - ( x % 2 );

      while ( nextX < map.width + 3 || nextY > -3 ) {
        map.megaHexCenters.push({x:nextX,y:nextY});
        nextY = nextY - 2 - ( (nextX) % 2 );
        nextX = nextX+1;
      }

      // third we collect the starting points for rows below the start...

      nextX = x-1;
      nextY = y + 2 + ( Math.abs(x+1) % 2 );

      while ( nextX > -3 || nextY < map.height + 3 ) {
        map.megaHexCenters.push({x:nextX,y:nextY});
        nextX = nextX-1;
        nextY = nextY + 2 + Math.abs( ( nextX  ) % 2 );
      }

       rowLimit = map.megaHexCenters.length;

      // now we have one center for each row, we just the centers left and right of each...

      for ( let i = 0; i < rowLimit; i++ ) {

        nextX = map.megaHexCenters[i].x - 3;
        nextY = map.megaHexCenters[i].y + Math.abs( nextX%2 );

        while ( nextX > -3 || nextY < map.height + 3 ) {

          map.megaHexCenters.push({x:nextX,y:nextY});

          nextX -= 3;
          nextY += Math.abs(nextX%2);

        }

      }


      for ( let i = 0; i < rowLimit; i++ ) {

        nextX = map.megaHexCenters[i].x + 3;
        nextY = map.megaHexCenters[i].y - Math.abs( (nextX+1)%2 );

        while ( nextX < map.width + 3 && nextY > -3 ) {

          map.megaHexCenters.push({x:nextX,y:nextY});

          nextX += 3;
          nextY -= Math.abs((nextX+1)%2);

        }

      }


    }

    function setColorPickers() {

      document.getElementById('linesColor').value = map.palette.lines;
      document.getElementById('clearColor').value = map.palette.clear;
      document.getElementById('offboardColor').value = map.palette.offboard;
      document.getElementById('wallsColor').value = map.palette.walls;
      document.getElementById('pathsColor').value = map.palette.paths;
      document.getElementById('waterColor').value = map.palette.water;
      document.getElementById('columnsColor').value = map.palette.columns;
      document.getElementById('lavaColor').value = map.palette.lava;

      updateSampleMap();

    }

    function setOpenerColor() {

      document.getElementById('toolOpener').style.backgroundColor = map.palette.lines;

      switch ( global.currentTool ) {

        case 'offboard':
          document.getElementById('toolOpenerInner').style.backgroundColor = map.palette.offboard;
          document.getElementById('toolOpenerInner').style.color = map.palette.lines;
          break;

        case 'water':
          document.getElementById('toolOpenerInner').style.backgroundColor = map.palette.water;
          document.getElementById('toolOpenerInner').style.color = map.palette.clear;
          break;

        case 'lava':
          document.getElementById('toolOpenerInner').style.backgroundColor = map.palette.lava;
          document.getElementById('toolOpenerInner').style.color = '#ffffaa';
          break;

        case 'wall hex':
          document.getElementById('toolOpenerInner').style.backgroundColor = map.palette.walls;
          document.getElementById('toolOpenerInner').style.color = map.palette.clear;
          break;

        case 'paths':
          document.getElementById('toolOpenerInner').style.backgroundColor = map.palette.paths;
          document.getElementById('toolOpenerInner').style.color = map.palette.lines;
          break;

        case 'columns':
          document.getElementById('toolOpenerInner').style.backgroundColor = map.palette.columns;
          document.getElementById('toolOpenerInner').style.color = map.palette.clear;
          break;

        default:
          document.getElementById('toolOpenerInner').style.backgroundColor = map.palette.clear;
          document.getElementById('toolOpenerInner').style.color = map.palette.lines;


      }


    }

    function saveColors() {

      map.palette.lines = document.getElementById('linesColor').value;
      map.palette.clear = document.getElementById('clearColor').value;
      map.palette.offboard = document.getElementById('offboardColor').value;
      map.palette.walls = document.getElementById('wallsColor').value;
      map.palette.paths = document.getElementById('pathsColor').value;
      map.palette.water = document.getElementById('waterColor').value;
      map.palette.columns = document.getElementById('columnsColor').value;
      map.palette.lava = document.getElementById('lavaColor').value;

      document.getElementById('colorDialogOverlay').style.display='none';
//      paletteDiv.style.display='none';

      setOpenerColor();

      convertObjectToText();

      objectToOffscreen();

      offscreenToMiniMap();

      offscreenToDisplay();


    }

    function loadStandardPalette( paletteNum ) {

//      console.log( paletteNum );

      switch (paletteNum) {
        case 0:
          map.palette.lines = '#4C3270';
          map.palette.clear = '#EEECF2';
          map.palette.walls = '#4C3270';
          map.palette.offboard = '#FFFFFF';
          map.palette.water = '#483D8B';
          map.palette.paths = '#BBB9F2';
          map.palette.columns = '#4C3270';
          map.palette.lava = '#aa0011';
          map.palette.name = 'Melee';
          break;

        case 1:
          map.palette.lines = '#42599D';
          map.palette.clear = '#F2F1F7';
          map.palette.walls = '#42599D';
          map.palette.offboard = '#FFFFFF'
          map.palette.water = '#483D8B';
          map.palette.paths = '#E3E2F0';
          map.palette.columns = '#42599D';
          map.palette.lava = '#aa0011';
          map.palette.name = 'Wizard';
          break;

        case 2:
          map.palette.lines = '#444444';
          map.palette.clear = '#999999';
          map.palette.walls = '#333333';
          map.palette.offboard = '#666666';
          map.palette.water = '#5E7A87';
          map.palette.paths = '#BBBBBB';
          map.palette.columns = '#006400';
          map.palette.lava = '#f27602';
          map.palette.name = 'Cavern';
          break;

        case 3: //burrow
          map.palette.lines = '#2D1C12';
          map.palette.clear = '#5B3E2B';
          map.palette.walls = '#4A3223';
          map.palette.offboard = '#3E2A1F';
          map.palette.water = '#3D5A58';
          map.palette.paths = '#8B6F4E';
          map.palette.columns = '#FFFFE0';
          map.palette.lava = '#ec3b13';
          map.palette.name = 'Burrow';
          break;

        case 4:  //wildlands
          map.palette.lines = '#4E7433';
          map.palette.clear = '#A9D18E';
          map.palette.walls = '#6B4F3B';
          map.palette.offboard = '#B7B7A4';
          map.palette.water = '#3A7CA5';
          map.palette.paths = '#C2A97F';
          map.palette.columns = '#B8860B';
          map.palette.lava = '#fab1a0';
          map.palette.name = 'Wild Lands';
          break;

        case 5: // desert
          map.palette.lines = '#8B6B3F';
          map.palette.clear = '#F4E2B6';
          map.palette.walls = '#A67B5B';
          map.palette.offboard = '#D9C8A9';
          map.palette.water = '#2E8C8C';
          map.palette.paths = '#C29B6F';
          map.palette.columns = '#4A3C3D';
          map.palette.lava = '#fab1a0';
          map.palette.name = 'Desert';
          break;

        case 6: // frozen
          map.palette.lines = '#2C3E50';        // Dark blue-gray for lines
          map.palette.clear = '#E8F4F8';        // Very pale blue-white for clear areas
          map.palette.walls = '#34495E';        // Darker blue-gray for walls
          map.palette.offboard = '#5DADE2';     // Ice blue for offboard
          map.palette.water = '#1B4F72';        // Deep frozen water blue
          map.palette.paths = '#AEB6BF';        // Light gray-blue for paths
          map.palette.columns = '#566573';      // Medium gray-blue for columns
          map.palette.lava = '#E74C3C';         // Bright red for contrast (maybe geothermal vents?)
          map.palette.name = 'Frozen';
          break;

        case 7: // volcano
          map.palette.lines = '#8B4513';        // Dark burnt sienna for lines
          map.palette.clear = '#2F1B14';        // Dark volcanic ash for clear areas
          map.palette.walls = '#654321';        // Dark brown volcanic rock for walls
          map.palette.offboard = '#1C1C1C';     // Deep charcoal black for offboard
          map.palette.water = '#ff6b6b';        // Crimson red for lava flows/molten rock
          map.palette.paths = '#CD853F';        // Sandy brown for ash-covered paths
          map.palette.columns = '#A0522D';      // Sienna brown for rock columns
          map.palette.lava = '#FF4500';         // Bright orange-red for active lava
          map.palette.name = 'Volcanic';
          break;

        case 8: // woods
          map.palette.lines = '#2D5016';        // Dark forest green for lines
          map.palette.clear = '#8FBC8F';        // Light forest green for clear areas
          map.palette.walls = '#8B4513';        // Saddle brown for tree trunks/wooden walls
          map.palette.offboard = '#228B22';     // Forest green for offboard
          map.palette.water = '#4682B4';        // Steel blue for streams/ponds
          map.palette.paths = '#D2B48C';        // Tan for dirt paths
          map.palette.columns = '#654321';      // Dark brown for tree trunks/wooden posts
          map.palette.lava = '#FFD700';         // Gold for sunlight patches/clearings
          map.palette.name = 'Woods';
          break;

        case 9: // swamp
          map.palette.lines = '#2F4F2F';        // Dark olive green for lines
          map.palette.clear = '#556B2F';        // Olive drab for murky open areas
          map.palette.walls = '#8B7355';        // Dark khaki for rotting wood/twisted roots
          map.palette.offboard = '#1C3A1C';     // Very dark forest green for offboard
          map.palette.water = '#2F4F4F';        // Dark slate gray for murky swamp water
          map.palette.paths = '#6B8E23';        // Olive green for moss-covered paths
          map.palette.columns = '#5D4E37';      // Dark brown for gnarled tree trunks
          map.palette.lava = '#ADFF2F';         // Scary acid green for toxic pools/gases
          map.palette.name = 'Swamp';
          break;

        case 10: // B&W with jaggy lava pattern
          map.palette.lines = '#000000';
          map.palette.clear = '#ffffff';
          map.palette.walls = '#000000';
          map.palette.offboard = '#000000';
          map.palette.water = '#999999';
          map.palette.paths = '#bbbbbb';
          map.palette.columns = '#000000';
          map.palette.lava = '#444444';
          map.palette.name = 'Black and White';
          break;

      case 11: // ethereal plane
          map.palette.lines = '#E6E6FA';        // Lavender for subtle lines
          map.palette.clear = '#F0F8FF';        // Alice blue for open ethereal space
          map.palette.walls = '#DDA0DD';        // Plum for semi-solid barriers
          map.palette.offboard = '#9370DB';     // Medium slate blue for void areas
          map.palette.water = '#B0C4DE';        // Light steel blue for ethereal mists
          map.palette.paths = '#E0E0E0';        // Light gray for spectral pathways
          map.palette.columns = '#D8BFD8';      // Thistle for ethereal pillars
          map.palette.lava = '#FFE4E1';         // Misty rose for energy vortexes
          map.palette.name = 'Ethereal Plane';
          break;

      }

      setColorPickers();

    }

    function updateColorFromHex(colorType) {
        const hexInput = document.getElementById(colorType + 'Hex');
        const colorPicker = document.getElementById(colorType + 'Color');

        let hexValue = hexInput.value;

        // Add # if missing
        if (!hexValue.startsWith('#')) {
            hexValue = '#' + hexValue;
            hexInput.value = hexValue;
        }



        // Validate hex color
        if (/^#[0-9A-F]{6}$/i.test(hexValue)) {
            colorPicker.value = hexValue;
        } else {
          console.log( 'bad value for color');
        }

        map.palette.name = '';

        updateSampleMap();

    }

    function updateColorFromPicker(colorType) {
      const hexInput = document.getElementById(colorType + 'Hex');
      const colorPicker = document.getElementById(colorType + 'Color');

      hexInput.value = colorPicker.value;

      map.palette.name = '';

      updateSampleMap();

    }

    function updateSampleMap() {

      sampleMapContext.fillStyle = document.getElementById('offboardColor').value;
      sampleMapContext.fillRect(0, 0, sampleMapContext.canvas.width, sampleMapContext.canvas.height);

      sampleMapContext.strokeStyle = document.getElementById('linesColor').value;
      sampleMapContext.fillStyle = document.getElementById('clearColor').value;

      sampleMapContext.lineWidth = 2;

      // ai code follows

      // Hex grid parameters
      const hexSize = 30;
      const hexWidth = hexSize * 2;
      const hexHeight = Math.sqrt(3) * hexSize;
      const canvasWidth = sampleMapContext.canvas.width;
      const canvasHeight = sampleMapContext.canvas.height;

      // Calculate hex grid dimensions
      const colWidth = hexWidth * 0.75; // Distance between column centers
      const rowHeight = hexHeight; // Distance between row centers

      // Calculate how many hexes fit
      const numCols = Math.floor((canvasWidth - hexSize * 0.5) / colWidth);
      const numRows = Math.floor(canvasHeight / rowHeight);

      // Function to draw a single hexagon
      function drawHex(centerX, centerY) {
           points = [];
          for (let i = 0; i < 6; i++) {
              const angle = (Math.PI / 3) * i;
              const x = centerX + hexSize * Math.cos(angle);
              const y = centerY + hexSize * Math.sin(angle);
              points.push({ x, y });
          }

          // Draw filled hex
          sampleMapContext.beginPath();
          sampleMapContext.moveTo(points[0].x, points[0].y);
          for (let i = 1; i < points.length; i++) {
              sampleMapContext.lineTo(points[i].x, points[i].y);
          }
          sampleMapContext.closePath();

          sampleMapContext.fill();

          if ( col==2 && row==3 || col==3 && row==0 ) {

            // Calculate midpoints
            const midpoint1 = {
              x: (points[1].x + points[2].x) / 2,
              y: (points[1].y + points[2].y) / 2
            };

            const midpoint2 = {
              x: (points[4].x + points[5].x) / 2,
              y: (points[4].y + points[5].y) / 2
            };

            // Draw the line
            sampleMapContext.lineWidth = 20;
            sampleMapContext.strokeStyle = document.getElementById('pathsColor').value;

            sampleMapContext.beginPath();
            sampleMapContext.moveTo(midpoint1.x, midpoint1.y);
            sampleMapContext.lineTo(midpoint2.x, midpoint2.y);
            sampleMapContext.stroke();
            sampleMapContext.closePath();

            sampleMapContext.strokeStyle = document.getElementById('linesColor').value;
            sampleMapContext.lineWidth = 2;

          }

          if ( col==2 && row==2  ) {

            // Calculate midpoints
            const midpoint1 = {
              x: (points[5].x + points[0].x) / 2,
              y: (points[5].y + points[0].y) / 2
            };

            const midpoint2 = {
              x: (points[1].x + points[4].x) / 2,
              y: (points[1].y + points[4].y) / 2
            };

            const midpoint3 = {
              x: (points[1].x + points[2].x) / 2,
              y: (points[1].y + points[2].y) / 2
            };

            // Draw the line
            sampleMapContext.lineWidth = 20;
            sampleMapContext.strokeStyle = document.getElementById('pathsColor').value;

            sampleMapContext.beginPath();
            sampleMapContext.moveTo(midpoint1.x, midpoint1.y);
            sampleMapContext.lineTo(midpoint2.x, midpoint2.y);
            sampleMapContext.lineTo(midpoint3.x, midpoint3.y);
            sampleMapContext.stroke();
            sampleMapContext.closePath();

            sampleMapContext.strokeStyle = document.getElementById('linesColor').value;
            sampleMapContext.lineWidth = 2;

          }

          if ( col==3 && row==1  ) {

            // Calculate midpoints
            const midpoint1 = {
              x: (points[2].x + points[3].x) / 2,
              y: (points[2].y + points[3].y) / 2
            };

            const midpoint2 = {
              x: (points[1].x + points[4].x) / 2,
              y: (points[1].y + points[4].y) / 2
            };

            const midpoint3 = {
              x: (points[4].x + points[5].x) / 2,
              y: (points[4].y + points[5].y) / 2
            };

            // Draw the line
            sampleMapContext.lineWidth = 20;
            sampleMapContext.strokeStyle = document.getElementById('pathsColor').value;

            sampleMapContext.beginPath();
            sampleMapContext.moveTo(midpoint1.x, midpoint1.y);
            sampleMapContext.lineTo(midpoint2.x, midpoint2.y);
            sampleMapContext.lineTo(midpoint3.x, midpoint3.y);
            sampleMapContext.stroke();
            sampleMapContext.closePath();

            sampleMapContext.strokeStyle = document.getElementById('linesColor').value;
            sampleMapContext.lineWidth = 2;

          }


          sampleMapContext.beginPath();
          sampleMapContext.moveTo(points[0].x, points[0].y);
          for (let i = 1; i < points.length; i++) {
              sampleMapContext.lineTo(points[i].x, points[i].y);
          }
          sampleMapContext.closePath();

          sampleMapContext.stroke();

          // Draw center dot
          sampleMapContext.strokeRect(centerX - 1, centerY - 1, 2, 2);
      }

      // Draw the hex grid
      for ( row = 0; row < numRows; row++) {
          for ( col = 0; col < numCols; col++) {
              // Calculate hex center position
              const x = hexSize + col * colWidth + 15;
              const y = hexSize + row * rowHeight + (col % 2) * (hexHeight / 2);

              if ( row == 0 && col == 1 ||  row == 0 && col == 2 ||  row == 1 && col == 1 ) {
                sampleMapContext.fillStyle = document.getElementById('wallsColor').value;

              } else if ( row == 1 && col == 2) {
                sampleMapContext.fillStyle = document.getElementById('waterColor').value;

              } else if ( row == 3 && col == 4) {
                sampleMapContext.fillStyle = document.getElementById('lavaColor').value;

              } else {
                sampleMapContext.fillStyle = document.getElementById('clearColor').value;

              }


              // Only draw if hex is fully within canvas bounds
              if (x - hexSize >= 0 && x + hexSize <= canvasWidth &&
                  y - hexSize >= 0 && y + hexSize <= canvasHeight) {
                  drawHex(x, y);

                  if ( row == 2 && col == 1 || row == 1 && col == 5 ) {
                    sampleMapContext.fillStyle = document.getElementById('columnsColor').value;
                    sampleMapContext.beginPath();
                    sampleMapContext.arc(x, y, 12, 0, 2 * Math.PI); // draw a circle
                    sampleMapContext.fill();                           // fill the arc

                  }

              }
          }
      }


    }

    function openInfo() {

      document.getElementById('mapInfoName').value = map.name;
      document.getElementById('mapInfoDescription').value = map.description;

      document.getElementById('mapInfoWidth').value = map.width;
      document.getElementById('mapInfoHeight').value = map.height;


      document.getElementById('mapInfoDialogOverlay').style.display = 'flex';

    }


    function saveMapInfo() {

      map.name = document.getElementById('mapInfoName').value;

      map.description = document.getElementById('mapInfoDescription').value;

      map.showDots = ( document.getElementById('mapInfoShowDots').checked ? 'yes' : 'no' );

      map.showHexNumbers = ( document.getElementById('mapInfoShowHex').checked ? 'yes' : 'no' );

      map.texture = ( document.getElementById('mapInfoTexture').checked ? 'yes' : 'no' );

//      map.handDrawn = ( document.getElementById('mapInfoHandDrawn').checked ? 'yes' : 'no' );

      map.lineStyle = document.querySelector('input[name="lineStyle"]:checked').value;

      // if the dimensions have chnaged we'll have to modify the array...

      const newWidth = parseInt( document.getElementById('mapInfoWidth' ).value );
      const newHeight = parseInt( document.getElementById('mapInfoHeight' ).value );

      if ( newWidth != map.width  || newHeight != map.height ) {

        const oldWidth = map.width;
        const oldHeight = map.height;

        // Create new grid with new dimensions
        const newGrid = [];

        for (let x = 0; x < newWidth; x++) {
            newGrid[x] = [];
            for (let y = 0; y < newHeight; y++) {
                // Copy existing data if within old bounds
                if (x < oldWidth && y < oldHeight) {
                    newGrid[x][y] = [...map.grid[x][y]]; // Copy the array of strings
                } else {
                    newGrid[x][y] = []; // Initialize new cells as empty arrays
                }
            }
        }

        // Update the map object
        map.grid = newGrid;
        map.width = newWidth;
        map.height = newHeight;


      }

      document.getElementById('mapInfoDialogOverlay').style.display = 'none';

      global.changed = 'yes';

      convertObjectToText();

      objectToOffscreen();

      offscreenToMiniMap();

      offscreenToDisplay();

    }


    // Help system functionality
           class HelpSystem {
               constructor() {
                   this.helpSystem = document.getElementById('helpSystem');
                   this.helpBackdrop = document.getElementById('helpBackdrop');
                   this.tabs = document.querySelectorAll('.help-tab');
                   this.sections = document.querySelectorAll('.help-section');

                   this.init();
               }

               init() {
                   // Add click handlers to tabs
                   this.tabs.forEach(tab => {
                       tab.addEventListener('click', (e) => {
                           const sectionName = e.target.dataset.section;
                           this.showSection(sectionName);
                       });
                   });

                   // Close on backdrop click
                   this.helpBackdrop.addEventListener('click', () => {
                       this.hide();
                   });

                   // Close on Escape key
                   document.addEventListener('keydown', (e) => {
                       if (e.key === 'Escape' && this.isVisible()) {
                           this.hide();
                       }
                   });
               }

               show(section = 'general') {
                   this.helpSystem.style.display = 'block';
                   this.helpBackdrop.style.display = 'block';
                   this.showSection(section);

                   // Focus the help system for keyboard navigation
                   this.helpSystem.focus();
               }

               hide() {
                   this.helpSystem.style.display = 'none';
                   this.helpBackdrop.style.display = 'none';
               }

               isVisible() {
                   return this.helpSystem.style.display === 'block';
               }

               showSection(sectionName) {
                   // Hide all sections
                   this.sections.forEach(section => {
                       section.classList.remove('active');
                   });

                   // Remove active class from all tabs
                   this.tabs.forEach(tab => {
                       tab.classList.remove('active');
                   });

                   // Show the requested section
                   const targetSection = document.getElementById(`section-${sectionName}`);
                   const targetTab = document.querySelector(`[data-section="${sectionName}"]`);

                   if (targetSection && targetTab) {
                       targetSection.classList.add('active');
                       targetTab.classList.add('active');
                   }
               }
           }

           // Initialize the help system after DOM is loaded
           let helpSystem;

           // Wait for DOM to be ready
           if (document.readyState === 'loading') {
               document.addEventListener('DOMContentLoaded', () => {
                   helpSystem = new HelpSystem();
               });
           } else {
               // DOM is already ready
               helpSystem = new HelpSystem();
           }

           // Global functions for external access
           function showHelp(section = 'general') {
               if (helpSystem) {
                   helpSystem.show(section);
               }
           }

           function hideHelp() {
               if (helpSystem) {
                   helpSystem.hide();
               }
           }

           function showHelpSection(section) {
               if (helpSystem) {
                   helpSystem.show(section);
               }
           }

           // Example usage - you can call these from anywhere in your app:
           // showHelp(); // Shows help with General tab active
           // showHelp('keys'); // Shows help with Keys tab active
           // showHelpSection('terrain'); // Shows help with Terrain Tools tab active
           // hideHelp(); // Hides the help system

           class SettingsWindow {
               constructor() {
                   this.settingsWindow = document.getElementById('settingsWindow');
                   this.settingsBackdrop = document.getElementById('settingsBackdrop');

                   // Default settings values
                   this.settings = {
                       showDots: true,
                       showHex: false,
                       showMiniMap: true
                   };

                   this.init();
               }

               init() {
                   // Close on backdrop click
                   this.settingsBackdrop.addEventListener('click', () => {
                       this.hide();
                   });

                   // Close on Escape key
                   document.addEventListener('keydown', (e) => {
                       if (e.key === 'Escape' && this.isVisible()) {
                           this.hide();
                       }
                   });

                   // Initialize toggle states
                   this.updateToggleStates();
               }

               show() {
                   this.settingsWindow.style.display = 'block';
                   this.settingsBackdrop.style.display = 'block';

                   // Focus the settings window for keyboard navigation
                   this.settingsWindow.focus();
               }

               hide() {
                   this.settingsWindow.style.display = 'none';
                   this.settingsBackdrop.style.display = 'none';
               }

               isVisible() {
                   return this.settingsWindow.style.display === 'block';
               }

               toggleSetting(settingName) {
                   // Toggle the setting value
                   this.settings[settingName] = !this.settings[settingName];

                   // Update the visual state
                   this.updateToggleStates();

                   // Call callback if provided
                   if (this.onSettingChange) {
                       this.onSettingChange(settingName, this.settings[settingName]);
                   }

//                   console.log(`${settingName} is now ${this.settings[settingName] ? 'ON' : 'OFF'}`);
               }

               updateToggleStates() {

                   // Update Show MiniMap toggle
                   const miniMapToggle = document.getElementById('showMiniMapToggle');
                   if (this.settings.showMiniMap) {
                       miniMapToggle.classList.add('active');
                   } else {
                       miniMapToggle.classList.remove('active');
                   }
               }

               // Get current setting value
               getSetting(settingName) {
                   return this.settings[settingName];
               }

               // Set a setting value programmatically
               setSetting(settingName, value) {
                   this.settings[settingName] = value;
                   this.updateToggleStates();

                   if (this.onSettingChange) {
                       this.onSettingChange(settingName, value);
                   }
               }

               // Get all settings
               getAllSettings() {
                   return { ...this.settings };
               }

               // Set callback for when settings change
               setOnSettingChange(callback) {
                   this.onSettingChange = callback;
               }
           }

           // Initialize the settings window after DOM is loaded
           let settingsWindow;

           // Wait for DOM to be ready
           if (document.readyState === 'loading') {
               document.addEventListener('DOMContentLoaded', () => {
                   settingsWindow = new SettingsWindow();
               });
           } else {
               // DOM is already ready
               settingsWindow = new SettingsWindow();
           }

           // Global functions for external access
           function showSettings() {
               if (settingsWindow) {
                   settingsWindow.show();
               }
           }

           function hideSettings() {
               if (settingsWindow) {
                   settingsWindow.hide();
               }
           }

           function toggleSetting(settingName) {
               if (settingsWindow) {
                   settingsWindow.toggleSetting(settingName);
               }
           }

           function getSetting(settingName) {
               return settingsWindow ? settingsWindow.getSetting(settingName) : false;
           }

           function setSetting(settingName, value) {
               if (settingsWindow) {
                   settingsWindow.setSetting(settingName, value);
               }
           }

           function getAllSettings() {
               return settingsWindow ? settingsWindow.getAllSettings() : {};
           }

           // Example of how to listen for setting changes
           function onSettingChanged(settingName, newValue) {
//               console.log(`Setting ${settingName} changed to: ${newValue}`);

               // Handle individual settings
               switch(settingName) {
                   case 'showDots':
                       // Your code to show/hide dots
                       break;
                   case 'showHex':
                       // Your code to show/hide hex numbers
                       break;
                   case 'showMiniMap':
                       // Your code to show/hide minimap
                       break;
               }
           }

           // Set up the callback (do this after the settings window is initialized)
           setTimeout(() => {
               if (settingsWindow) {
                   settingsWindow.setOnSettingChange(onSettingChanged);
               }
           }, 100);

    function saveToDownloads() {

        const a = document.createElement('a');
        const file = new Blob([ document.getElementById('textDisplayArea').value ], {type: 'text/plain'});

        var d = new Date();

                  dateString = d.getMonth() + "-" + d.getDate() + "-" + d.getYear() + " " + d.getHours() + " " + d.getMinutes();

        a.href= URL.createObjectURL(file);
        a.download = map.name + " " + dateString;
        a.click();

        URL.revokeObjectURL(a.href);



    }


    function loadMap() {

      document.getElementById('fileInput').click();

    }

    function setTool( newTool ) {

//      console.log('***********'+newTool);
      global.currentTool = newTool;

      saveSettings();

      document.getElementById('toolOpenerInner').innerHTML = newTool;

      setOpenerColor();

      hideDiv( toolMenu );

    }

    function handleFileChange(event) {
//        console.log('handleFileChange()');
        const file = event.target.files[0]; // Get the selected file
        if (!file) {
//            console.log("no file was selected");
            return; // If no file is selected, do nothing
        }

//        console.log( file );

        const reader = new FileReader(); // Create a FileReader object
        reader.onload = handleFileLoad;

        // Read the file as text
        reader.readAsText(file);
    }

    function handleFileLoad(e) {

//      console.log( 'handleFileLoad()' );

        const content = e.target.result; // Get the file content

        document.getElementById('textDisplayArea').value = content; // Load content into the textarea

//        console.log( content.split('\n')[0] );

        convertTextToObject();

        objectToOffscreen();

        offscreenToMiniMap();

        offscreenToDisplay();

    }




    function convertObjectToText() {

      let newText = 'Name: ' + map.name + '\n';

      newText += 'Description: ' + map.description + '\n';

      newText += 'Height: ' + map.height + '\n';

      newText += 'Width: ' + map.width + '\n';

      if ( map.graphic ) {
        newText += "Graphic: " + map.graphic + '\n';
      }

      if ( map.showDots == 'no' ) {

        newText += 'Show Dots: no\n';

      }

      if ( map.showHexNumbers == 'no' ) {

        newText += 'Show hex Numbers: no\n';

      }

      if ( map.texture == 'yes' ) {

        newText += 'Add Texture: ' + 'yes' + '\n';

      }

      if ( map.lineStyle != 'normal' ) {

        newText += 'Line Style: ' + map.lineStyle + '\n';

      }

      if ( map.palette.name ) {

        newText += 'Palette: ' + map.palette.name + '\n';

      } else  {

          newText += 'Offboard: ' + map.palette.offboard + '\n';
          newText += 'Clear: ' + map.palette.clear + '\n';
          newText += 'Lines: ' + map.palette.lines + '\n';
          newText += 'Walls: ' + map.palette.walls + '\n';
          newText += 'Water: ' + map.palette.water + '\n';
          newText += 'Path: ' + map.palette.paths + '\n';
          newText += 'Columns: ' + map.palette.columns + '\n';
          newText += 'Lava: ' + map.palette.lava + '\n';

      }

      if ( map.megaHexCenters.length != 0 ) {

        newText += "Megahex centers on: " + map.megaHexCenters[0].x + ',' + map.megaHexCenters[0].y + '\n';

      }

      if ( global.groupBy == 'terrain' ) {

        let offboardList = '';
        let wallList = '';
        let pitList = '';
        let fireList = '';
        let shadowList = '';
        let waterList = '';
        let pathList = '';
        let columnList = '';
        let bodyList = '';
        let debrisList = '';
        let trapdoorList = '';
        let tableList = '';
        let altarList = '';
        let pentacleList = '';
        let barricadeList = '';
        let lavaList = '';
        let stoneList = '';
        let stickyList = '';
        let tarList = '';
        let slipperyList = '';
        let darkerList = '';
        let lighterList = '';
        let starList = '';

        for ( let x = 0; x < map.width; x++ ) {
          for ( let y = 0; y < map.height; y++ ) {

            if ( map.grid[x][y].some(item => item.includes('offboard')) ) {
              offboardList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => item.includes('wall')) ) {
              wallList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['water', 'pond', 'river', 'stream', 'pool'].includes(item)) ) {
              waterList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['path', 'paths'].includes(item)) ) {
              pathList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['column', 'columns'].includes(item)) ) {
              columnList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['body', 'bodies'].includes(item)) ) {
              bodyList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['debris'].includes(item)) ) {
              debrisList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['trapdoor', 'trapdoors'].includes(item)) ) {
              trapdoorList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['table', 'tables'].includes(item)) ) {
              tableList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['altar', 'altars'].includes(item)) ) {
              altarList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['pentacle', 'pentacles'].includes(item)) ) {
              pentacleList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['barricade', 'barricades'].includes(item)) ) {
              barricadeList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['fire'].includes(item)) ) {
              fireList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['shadow'].includes(item)) ) {
              shadowList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['lava'].includes(item)) ) {
              lavaList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['stone'].includes(item)) ) {
              stoneList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['tar'].includes(item)) ) {
              tarList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['sticky'].includes(item)) ) {
              stickyList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['slippery'].includes(item)) ) {
              slipperyList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['pit'].includes(item)) ) {
              pitList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['star'].includes(item)) ) {
              starList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['darker'].includes(item)) ) {
              darkerList += x+','+y+' ';
            }

            if ( map.grid[x][y].some(item => ['lighter'].includes(item)) ) {
              lighterList += x+','+y+' ';
            }



          }
        }


        const lists = [
          { label: 'Offboard', list: offboardList },
          { label: 'Walls', list: wallList },
          { label: 'Water', list: waterList },
          { label: 'Path', list: pathList },
          { label: 'Column', list: columnList },
          { label: 'Fire', list: fireList },
          { label: 'Body', list: bodyList },
          { label: 'Shadow', list: shadowList },
          { label: 'Debris', list: debrisList },
          { label: 'Trapdoor', list: trapdoorList },
          { label: 'Barricade', list: barricadeList },
          { label: 'Table', list: tableList },
          { label: 'Altar', list: altarList },
          { label: 'Pentacle', list: pentacleList },
          { label: 'Lava', list: lavaList },
          { label: 'Stone', list: stoneList },
          { label: 'Tar', list: tarList },
          { label: 'Sticky', list: stickyList },
          { label: 'Slippery', list: slipperyList },
          { label: 'Pits', list: pitList },
          { label: 'Darker', list: darkerList },
          { label: 'Lighter', list: lighterList },
          { label: 'Stars', list: starList }
        ];

        lists.forEach(({ label, list }) => {
          newText = addListToText(newText, label, list);
        });





      } else {

        for ( let x = 0; x < map.width; x++ ) {
          for ( let y = 0; y < map.height; y++ ) {

            if ( map.grid[x][y].length == 0 || ( map.grid[x][y].lrngth == 1 && map.grid[x][y][0] === ['clear']  ) ) {
              continue;
            }

            newText += x + ',' + y + ' ' + map.grid[x][y].join(' ') + '\n';


          }
        }


      }


      for ( let i = 0; i < map.stoneBridges.length; i++ ) {
        newText += 'stone bridge from ' + map.stoneBridges[i].startingX + "," + map.stoneBridges[i].startingY + " to " + map.stoneBridges[i].endingX + "," + map.stoneBridges[i].endingY;

        if ( !bridgeGoodDirection( {x:map.stoneBridges[i].startingX, y:map.stoneBridges[i].startingY, },{x:map.stoneBridges[i].endingX,y:map.stoneBridges[i].endingY}) ) {
          newText += ' (note: this bridge will be excluded from TFT Trainer)';
        }

        newText += '\n';

      }

      for ( let i = 0; i < map.woodBridges.length; i++ ) {
        newText += 'wood bridge from ' + map.woodBridges[i].startingX + "," + map.woodBridges[i].startingY + " to " + map.woodBridges[i].endingX + "," + map.woodBridges[i].endingY;

        if ( !bridgeGoodDirection( {x:map.woodBridges[i].startingX, y:map.woodBridges[i].startingY, },{x:map.woodBridges[i].endingX,y:map.woodBridges[i].endingY}) ) {
          newText += '(note: this bridge will be excluded from TFT Trainer)';
        }

        newText += '\n';

      }


      document.getElementById("textDisplayArea").value = newText;

    }


    function addListToText(newText, label, list, maxLength = 80) {
      if (!list) return newText;

      const prefix = label + ': ';
      const fullLine = prefix + list;

      // If line fits within limit, add it normally
      if (fullLine.length <= maxLength) {
        return newText + fullLine + '\n';
      }

      // Need to split into multiple lines
      const availableSpace = maxLength - prefix.length;
      const items = list.split(' ');

      let currentLine = '';
      let currentLength = 0;

      for (let i = 0; i < items.length; i++) {
        const itemWithSpace = (currentLength === 0 ? items[i] : ' ' + items[i]);

        // Check if adding this item would exceed the limit
        if (currentLength + itemWithSpace.length > availableSpace && currentLength > 0) {
          // Output current line and start a new one
          newText += prefix + currentLine + '\n';
          currentLine = items[i]; // Start new line with current item
          currentLength = items[i].length;
        } else {
          // Add item to current line
          currentLine += itemWithSpace;
          currentLength += itemWithSpace.length;
        }
      }

      // Add the final line if it has content
      if (currentLine) {
        newText += prefix + currentLine + '\n';
      }

      return newText;
    }


    function convertTextToObject() {

      const lines = document.getElementById("textDisplayArea").value.split('\n').map(line => line.trim());

      while (lines.length > 0 && lines[0].trim() === '') {
        lines.shift();
      }

      if ( lines[0].startsWith('{"shamat') ) {

        convertShamatToObject();
        return;

      }

      map = {
        name: 'missing data map',
        palette: {}
      }

      map.name = lines.find(line => /^name\s*[:= -]?/i.test(line))?.replace(/^name\s*[:= -]?\s*/i, '');
        if ( map.name === undefined ) {
          map.name = 'Nameless Map';
        }

//        map.description = lines.find(line => /^description\s*[:= -]?/i.test(line))?.replace(/^name\s*[:= -]?\s*/i, '');

      map.description = lines.find(line => /^description\s*[:= -]?/i.test(line))?.replace(/^description\s*[:= -]?\s*/i, '');

      if ( map.description === undefined ) {
        map.description = '...A place shrouded in mystery and silence, untouched by map or legend.';
      }

      map.graphic = lines.find(line => /^(graphic|graphics|background|bg)\b/i.test(line))?.split(' ').pop();

      map.texture = (lines.find(line => /^(use\s+|add\s+|draw\s+)?texture\b/i.test(line))?.match(/\b(yes|no)\b/i)?.[1] || 'no').toLowerCase();

      // map.handDrawn = (lines.find(line => /^(use\s+|add\s+|draw\s+)?hand[\s-]*drawn[\s-]*lines\b/i.test(line))?.match(/\b(yes|no)\b/i)?.[1] || 'no').toLowerCase();

      map.lineStyle = findLineStyle( lines );

      map.showDots = (lines.find(line => /^(?:show\s+)?dots\s*[:= -]?/i.test(line))?.match(/\b(yes|no)\b/i)?.[1] || 'yes').toLowerCase();

      map.showHexNumbers = (lines.find(line => /^(?:show\s+)?hex\s+numbers\s*[:= -]?/i.test(line))?.match(/\b(yes|no)\b/i)?.[1] || 'yes').toLowerCase();

      // const paletteFound = lines.some(line =>
      //     /^palettes?\s*[:=-]?\s*(?:melee|wild\s+land|wizard|cavern|swamp|volcano|woods|frozen|burrow|desert)s?\s*$/i.test(line)
      //   );

      const paletteFound = lines.some(line =>
          /^palettes?\s*[:=-]?\s*(?:melee|wild\s*land|wizard|cavern|swamp|volcano|woods|frozen|burrow|desert|black\s*and\s*white|ethereal\s*plane)s?\s*$/i.test(line)
      );


      if (paletteFound) {
        const paletteLine = lines.find(line =>
          /^palettes?\s*[:=-]?\s*(?:melee|wild\s*land|wizard|cavern|swamp|volcano|woods?|frozen|burrow|desert|black\s*and\s*white|ethereal\s*plane)s?\s*$/i.test(line)
        );
        const match = paletteLine.match(/^palettes?\s*[:=-]?\s*((?:melee|wild\s*land|wizard|cavern|swamp|volcano|woods?|frozen|burrow|desert|black\s*and\s*white|ethereal\s*plane)s?)\s*$/i);
        let paletteWord = match[1].toLowerCase();
        //          console.log(paletteWord);
        // Remove plural 's' if present (but not from 'melee')
        if (paletteWord.endsWith('s') && paletteWord !== 'melee') {
          paletteWord = paletteWord.slice(0, -1);
        }

        // Normalize spacing for lookup
        paletteWord = paletteWord.replace(/\s+/g, ' '); // normalize multiple spaces to single space

        map.palette.name = paletteWord;
        let paletteList = ['melee','wizard','cavern','burrow','wild land','desert','frozen','volcano','woods','swamp','black and white','ethereal plane'];

//        console.log(paletteWord);

        // Check for both spaced and non-spaced versions
        let paletteIndex = paletteList.indexOf(paletteWord);
        if (paletteIndex === -1) {
          // Try without spaces
          const noSpaceWord = paletteWord.replace(/\s+/g, '');
          const noSpaceList = paletteList.map(p => p.replace(/\s+/g, ''));
          paletteIndex = noSpaceList.indexOf(noSpaceWord);
        }

        loadStandardPalette( paletteIndex );

      } else {

        map.palette.paths = (() => {
          const match = lines.find(line => /^paths?\b/i.test(line))?.match(/#?[0-9a-fA-F]{6}\b/);
          return match ? (match[0].startsWith('#') ? match[0] : '#' + match[0]) : "#C2A97F";
        })();

        map.palette.clear = (() => {
          const match = lines.find(line => /^clear?\b/i.test(line))?.match(/#?[0-9a-fA-F]{6}\b/);
          return match ? (match[0].startsWith('#') ? match[0] : '#' + match[0]) : '#A9D18E';
        })();

        map.palette.columns = (() => {
          const match = lines.find(line => /^columns?\b/i.test(line))?.match(/#?[0-9a-fA-F]{6}\b/);
          return match ? (match[0].startsWith('#') ? match[0] : '#' + match[0]) : "#B8860B";
        })();

        map.palette.lines = (() => {
          const match = lines.find(line => /^lines?\b/i.test(line))?.match(/#?[0-9a-fA-F]{6}\b/);
          return match ? (match[0].startsWith('#') ? match[0] : '#' + match[0]) : "#4E7433";
        })();

        map.palette.offboard = (() => {
          const match = lines.find(line => /^offboard?\b/i.test(line))?.match(/#?[0-9a-fA-F]{6}\b/);
          return match ? (match[0].startsWith('#') ? match[0] : '#' + match[0]) : "#B7B7A4";
        })();

        map.palette.walls = (() => {
          const match = lines.find(line => /^walls?\b/i.test(line))?.match(/#?[0-9a-fA-F]{6}\b/);
          return match ? (match[0].startsWith('#') ? match[0] : '#' + match[0]) : "#6B4F3B";
        })();

        map.palette.water = (() => {
          const match = lines.find(line => /^water?\b/i.test(line))?.match(/#?[0-9a-fA-F]{6}\b/);
          return match ? (match[0].startsWith('#') ? match[0] : '#' + match[0]) : "#3A7CA5";
        })();

        map.palette.lava = (() => {
          const match = lines.find(line => /^lava\b/i.test(line))?.match(/#?[0-9a-fA-F]{6}\b/);
          return match ? (match[0].startsWith('#') ? match[0] : '#' + match[0]) : "#000000";
        })();

      }



      map.width = (() => {
        const match = lines.find(line => /^w(?:idth|ide)\b/i.test(line))?.match(/\b([1-9][0-9]{0,2}|1000)\b/);
        return match ? parseInt(match[1], 10) : 12;
      })();

      map.height = (() => {
        const match = lines.find(line => /^height\b/i.test(line))?.match(/\b([1-9][0-9]{0,2}|1000)\b/);
        return match ? parseInt(match[1], 10) : 9;
      })();

      map.grid = Array.from({ length: map.width }, () =>
        Array.from({ length: map.height }, () => [])
      );

//      updateMiniMapSize();

      // const hexContents = [
      //   { pattern: /^(?:offboard|off\s*board)\s*[:= -]?/i, gridValue: 'offboard' },
      //   { pattern: /^walls?\s*[:= -]?/i, gridValue: 'wall hex' },
      //   { pattern: /^(?:pits?|holes?)\s*[:= -]?/i, gridValue: 'pit' },
      //   { pattern: /^(?:water|pool|pond|stream|river)\s*[:= -]?/i, gridValue: 'water' },
      //   { pattern: /^(?:column|tree)\s*[:= -]?/i, gridValue: 'column' },
      //   { pattern: /^(?:trapdoor|trap\s*door)\s*[:= -]?/i, gridValue: 'trapdoor' },
      //   { pattern: /^debris\s*[:= -]?/i, gridValue: 'debris' },
      //   { pattern: /^darker\s*[:= -]?/i, gridValue: 'darker' },
      //   { pattern: /^lighter\s*[:= -]?/i, gridValue: 'lighter' },
      //   { pattern: /^star\s*[:= -]?/i, gridValue: 'star' },
      //   { pattern: /^body\s*[:= -]?/i, gridValue: 'body' },
      //   { pattern: /^table\s*[:= -]?/i, gridValue: 'table' },
      //   { pattern: /^barricade\s*[:= -]?/i, gridValue: 'barricade' },
      //   { pattern: /^altar\s*[:= -]?/i, gridValue: 'altar' },
      //   { pattern: /^(?:shadows?|darkness)\s*[:= -]?/i, gridValue: 'shadow' },
      //   { pattern: /^(?:fires?|flames?)\s*[:= -]?/i, gridValue: 'fire' },
      //   { pattern: /^(?:paths?|roads?|trails?|walkways?)\s*[:= -]?/i, gridValue: 'path' },
      //   { pattern: /^(?:lavas?|acids?)\s*[:= -]?/i, gridValue: 'lava' },
      //   { pattern: /^(?:rock?|stone?)(?!\s*bridge)\b\s*[:= -]?/i, gridValue: 'stone' }
      // ];

      const hexContents = [
        { pattern: /^(?:offboard|off\s*board)\s*[:= -]?/i, gridValue: 'offboard' },
        { pattern: /^walls?\s*[:= -]?/i, gridValue: 'wall hex' },
        { pattern: /^(?:pits?|holes?)\s*[:= -]?/i, gridValue: 'pit' },
        { pattern: /^(?:water|pool|pond|stream|river)\s*[:= -]?/i, gridValue: 'water' },
        { pattern: /^(?:column|tree)\s*[:= -]?/i, gridValue: 'column' },
        { pattern: /^(?:trapdoor|trap\s*door)\s*[:= -]?/i, gridValue: 'trapdoor' },
        { pattern: /^debris\s*[:= -]?/i, gridValue: 'debris' },
        { pattern: /^dark\s*[:= -]?/i, gridValue: 'darker' },
        { pattern: /^light\s*[:= -]?/i, gridValue: 'lighter' },
        { pattern: /^star\s*[:= -]?/i, gridValue: 'star' },
        { pattern: /^slippery\s*[:= -]?/i, gridValue: 'slippery' },
        { pattern: /^sticky\s*[:= -]?/i, gridValue: 'sticky' },
        { pattern: /^tar\s*[:= -]?/i, gridValue: 'tar' },
        { pattern: /^(?:body|bodies)\s*[:= -]?/i, gridValue: 'body' },
        { pattern: /^table\s*[:= -]?/i, gridValue: 'table' },
        { pattern: /^barricade\s*[:= -]?/i, gridValue: 'barricade' },
        { pattern: /^altar\s*[:= -]?/i, gridValue: 'altar' },
        { pattern: /^pentacle\s*[:= -]?/i, gridValue: 'pentacle' },
        { pattern: /^(?:shadows?|darkness)\s*[:= -]?/i, gridValue: 'shadow' },
        { pattern: /^(?:fires?|flames?)\s*[:= -]?/i, gridValue: 'fire' },
        { pattern: /^(?:paths?|roads?|trails?|walkways?)\s*[:= -]?/i, gridValue: 'path' },
        { pattern: /^(?:lavas?|acids?)\s*[:= -]?/i, gridValue: 'lava' },
        { pattern: /^(?:rock?|stone?)(?!\s*bridge)\b\s*[:= -]?/i, gridValue: 'stone' }
      ];

      lines.forEach(line => {
        for (const obj of hexContents) {
          if (obj.pattern.test(line)) {
            const pairs = [...line.matchAll(/\b(\d{1,3})\s*,\s*(\d{1,3})\b/g)];
            for (const [, xStr, yStr] of pairs) {
              const x = parseInt(xStr, 10);
              const y = parseInt(yStr, 10);
              if (x >= 0 && x < map.width && y >= 0 && y < map.height) {
                map.grid[x][y].push(obj.gridValue);
              }
            }
            break; // Move the break here - after processing ALL coordinate pairs
          }
        }
      });

      lines.forEach(line => {
        // Check if line starts with coordinates (with optional whitespace)
        const coordMatch = line.match(/^\s*(\d{1,3})\s*,\s*(\d{1,3})\s+(.+)/);
        if (coordMatch) {
          const x = parseInt(coordMatch[1], 10);
          const y = parseInt(coordMatch[2], 10);
          const contentString = coordMatch[3].trim();

          if (x >= 0 && x < map.width && y >= 0 && y < map.height) {
            // Split the remaining content by whitespace and push each word
            const words = contentString.split(/\s+/).filter(word => word.length > 0);
            for (const word of words) {
              map.grid[x][y].push(word);
            }
          }
        }
      });

      // look for bridges
      // map.bridges=[];
      //
      // lines.forEach(line => {
      //     // Skip if line doesn't contain "bridge"
      //     if (!line.toLowerCase().includes('bridge')) return;
      //
      //     // Remove "bridge" and common separators, clean up the string
      //     let cleanLine = line.toLowerCase()
      //         .replace('bridge', '')
      //         .replace('from', '')
      //         .replace('to', '')
      //         .replace(':', '')
      //         .replace('-', ' ')
      //         .trim();
      //
      //     // Extract all numbers using regex
      //     const numbers = cleanLine.match(/\d+/g);
      //
      //     // We need exactly 4 numbers for startingX, startingY, endingX, endingY
      //     if (numbers && numbers.length === 4) {
      //         const bridgeObj = {
      //             startingX: parseInt(numbers[0]),
      //             startingY: parseInt(numbers[1]),
      //             endingX: parseInt(numbers[2]),
      //             endingY: parseInt(numbers[3])
      //         };
      //
      //         map.bridges.push(bridgeObj);
      //     }
      // });

      // look for bridges
      map.woodBridges = [];
      map.stoneBridges = [];

      lines.forEach(line => {
          const lowerLine = line.toLowerCase();

          // Skip if line doesn't contain "bridge"
          if (!lowerLine.includes('bridge')) return;

          // Check if it's a wood bridge
          let isWoodBridge = lowerLine.includes('wood bridge') ||
                              lowerLine.includes('woodbridge') ||
                              lowerLine.includes('wooden bridge') ||
                              lowerLine.includes('timber bridge');

          // Check if it's a stone bridge
          let isStoneBridge = lowerLine.includes('stone bridge') ||
                               lowerLine.includes('stonebridge') ||
                               lowerLine.includes('rock bridge') ||
                               lowerLine.includes('granite bridge') ||
                               lowerLine.includes('marble bridge');

           // If it's neither wood nor stone, check palette for default assignment
           if (!isWoodBridge && !isStoneBridge) {
               const woodPalettes = ['burrow', 'wild lands', 'woods', 'frozen', 'swamp'];
               if (woodPalettes.includes(map.palette.name.toLowerCase())) {
                   isWoodBridge = true;
               } else {
                 isStoneBridge = true;
               }
           }

          // Remove bridge-related words and common separators, clean up the string
          let cleanLine = lowerLine
              .replace(/wood(en)?\s*bridge/g, '')
              .replace(/woodbridge/g, '')
              .replace(/timber\s*bridge/g, '')
              .replace(/stone\s*bridge/g, '')
              .replace(/stonebridge/g, '')
              .replace(/rock\s*bridge/g, '')
              .replace(/granite\s*bridge/g, '')
              .replace(/marble\s*bridge/g, '')
              .replace(/bridge/g, '')
              .replace(/from/g, '')
              .replace(/to/g, '')
              .replace(/:/g, '')
              .replace(/-/g, ' ')
              .trim();

          // Extract all numbers using regex
          const numbers = cleanLine.match(/\d+/g);

          // We need exactly 4 numbers for startingX, startingY, endingX, endingY
          if (numbers && numbers.length === 4) {
              const bridgeObj = {
                  startingX: parseInt(numbers[0]),
                  startingY: parseInt(numbers[1]),
                  endingX: parseInt(numbers[2]),
                  endingY: parseInt(numbers[3])
              };

              // Add to appropriate array
              if (isWoodBridge) {
                  map.woodBridges.push(bridgeObj);
              } else if (isStoneBridge) {
                  map.stoneBridges.push(bridgeObj);
              }
          }
      });

      if (map.stoneBridges && map.stoneBridges.length > 0) {
          map.stoneBridges.forEach(stoneBridge => {

              fillBridge( stoneBridge );
          });
      }

      if (map.woodBridges && map.woodBridges.length > 0) {
          map.woodBridges.forEach(woodBridge => {

              fillBridge( woodBridge );

          });
      }


      megaHexOrigin = findMegahexCoordinates(lines)

//      console.table(map.palette);

    }


    function convertShamatToObject() {

//      document.getElementById('shamatWarningDiv').style.display='block';

      showShamatWarning();

      shamatObject = JSON.parse( document.getElementById("textDisplayArea").value );

      map = {
        name: shamatObject.name,
        description: 'Imported from Shamat II\ncreated by ' + shamatObject.author,
        width: shamatObject.cols,
        height: shamatObject.rows,
        grid: Array.from({ length: shamatObject.cols }, () =>
          Array.from({ length: shamatObject.rows }, () => [])
        ),
        palette: {
          name: 'cavern'
        },
        graphic: undefined,
        lineStyle: 'normal',
        showDots: 'no',
        showHexNumbers: 'no',
        stoneBridges: [],
        woodBridges: [],
        texture: 'no',
        megaHexCenters: []
      };

      for ( let i = 0; i < shamatObject.hexes.length; i++ ) {

        const x = Math.floor( i / map.height );
        const y = i % map.width;

        const shamatColor = shamatObject.hexes[i].base[0].color;
        const hexColor = simpleColorCategory( shamatColor );

        switch ( hexColor ) {

          case 'black':
            map.grid[x][y].push('wall hex');
            break;

          case 'blue':
            map.grid[x][y].push('water');
            break;

          case 'red':
            map.grid[x][y].push('lava');
            break;

        }

        if ( shamatObject.hexes[i].decor.length > 0 ) {

          if ( shamatObject.hexes[i].decor[0].component=='pentagram' ) {
            map.grid[x][y].push('pentacle');

          }

          if ( shamatObject.hexes[i].decor[0].component=='trapdoor' ) {
            map.grid[x][y].push('trapdoor');

          }

          if ( shamatObject.hexes[i].decor[0].component=='floor_pit' ) {
            map.grid[x][y].push('pit');

          }
                }


      }

      loadStandardPalette( 2 );

      megaHexOrigin = null;

      convertObjectToText();

    }


    let shamatKeyHandler = null;

    function showShamatWarning() {
        const div = document.getElementById('shamatWarningDiv');
        div.style.display = 'block';

        // Add key listener only when dialog is shown
        shamatKeyHandler = function(event) {
            if (event.key === 'Escape' || event.key === ' ' || event.key === 'Enter') {
                hideShamatWarning();
            }
        };

        document.addEventListener('keydown', shamatKeyHandler);
    }

    function hideShamatWarning() {
        const div = document.getElementById('shamatWarningDiv');
        div.style.display = 'none';

        // Remove the key listener when dialog is hidden
        if (shamatKeyHandler) {
            document.removeEventListener('keydown', shamatKeyHandler);
            shamatKeyHandler = null;
        }
    }

    function simpleColorCategory(hexColor) {
        const hex = hexColor.replace('#', '');
        const r = parseInt(hex.substr(0, 2), 16);
        const g = parseInt(hex.substr(2, 2), 16);
        const b = parseInt(hex.substr(4, 2), 16);

        // Calculate brightness
        const brightness = (r + g + b) / 3;

        if (brightness < 50) return 'black';
        if (brightness > 200) return 'white';

        // Find dominant color
        const max = Math.max(r, g, b);
        if (r === max && r > g + b) return 'red';
        if (g === max && g > r + b) return 'green';
        if (b === max && b > r + g) return 'blue';

        return 'mixed'; // When no single color dominates
    }



    function drawWall( centerX, centerY ) {
        const ctx = offscreenContext;
        const originalLineWidth = ctx.lineWidth;

        // Calculate hexagon vertices
        const vertices = [];
        for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI) / 3;
            const x = centerX + hexSide * Math.cos(angle);
            const y = centerY + hexSide * Math.sin(angle);
            vertices.push({ x, y });
        }

        // Create hexagon path for clipping
        function createHexPath() {
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < vertices.length; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
        }

        // Save context state
        ctx.save();

        // Clip to hexagon shape
        createHexPath();
        ctx.clip();


        const blobRadius = hexSide * 0.8; // Base size of the blob (increased from 0.15)

        ctx.fillStyle = map.palette.wall;
        ctx.beginPath();

        for ( let direction = 0; direction < 6; direction++ ) {

          // first, figure out what hexes are adjacent
          const ccwHex = hexAdjacent( xI, yI, (direction+5)%6 );
          const acrossHex = hexAdjacent( xI, yI, direction );
          const cwHex = hexAdjacent( xI, yI, (direction+1)%6 );

          const ccwWall = ( inBounds( ccwHex.x, ccwHex.y ) ? map.grid[ccwHex.x][ccwHex.y].includes('wall hex') ||  map.grid[ccwHex.x][ccwHex.y].includes('offboard') : true );

          const acrossWall = ( inBounds( acrossHex.x, acrossHex.y ) ? map.grid[acrossHex.x][acrossHex.y].includes('wall hex')  || map.grid[acrossHex.x][acrossHex.y].includes('offboard') : true );

          const cwWall = ( inBounds(cwHex.x, cwHex.y ) ? map.grid[cwHex.x][cwHex.y].includes('wall hex') ||  map.grid[cwHex.x][cwHex.y].includes('offboard') : true );

          //then we find the corners
          const x1 = centerX + hexSide * Math.cos(direction * Math.PI/3 - Math.PI*2/3);
          const y1 = centerY + hexSide * Math.sin(direction * Math.PI/3 - Math.PI*2/3);

          const x2 = centerX + hexSide * Math.cos((direction+1) * Math.PI/3 - Math.PI*2/3);
          const y2 = centerY + hexSide * Math.sin((direction+1) * Math.PI/3 - Math.PI*2/3);

          // now we move around based on all these established variables.
          if ( ccwWall && acrossWall ) {

              x=x1;
              y=y1;

          } else if ( acrossWall ) {

            x = x1 + 0.15 * (x2 - x1);
            y = y1 + 0.15 * (y2 - y1);

          } else {

            x = centerX + blobRadius * Math.cos( vertexStraddlingAngles[ direction * 2 + 1 ] );
            y = centerY + blobRadius * Math.sin( vertexStraddlingAngles[ direction * 2 + 1 ] );

          }

          // now we move to that points
          if ( direction === 0 ) {
              ctx.moveTo(x, y);
          } else {
              ctx.lineTo(x, y);
          }

          // now we do the next corner
          if ( cwWall && acrossWall ) {

              ctx.lineTo(x2, y2);

          } else if ( acrossWall ) {

            x = x1 + 0.85 * (x2 - x1);
            y = y1 + 0.85 * (y2 - y1);

            ctx.lineTo(x, y);

          } else {

            let x3 = centerX + blobRadius * Math.cos( vertexStraddlingAngles[ (direction * 2 + 2)%12 ] );
            let y3 = centerY + blobRadius * Math.sin( vertexStraddlingAngles[ (direction * 2 + 2)%12 ] );

            ctx.lineTo( x3, y3 );

          }

        }


        ctx.closePath();
        offscreenContext.fillStyle = map.palette.walls;
        ctx.fill();
//        ctx.stroke();


        // Restore context state
        ctx.restore();

        // // Draw hexagon border
        // ctx.strokeStyle = '#2a1f15';
        // ctx.lineWidth = 2;
        // createHexPath();
        // ctx.stroke();

        ctx.lineWidth = originalLineWidth;

    }

    function drawTar( centerX, centerY ) {
        const ctx = offscreenContext;
        const originalLineWidth = ctx.lineWidth;

        // Calculate hexagon vertices
        const vertices = [];
        for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI) / 3;
            const x = centerX + hexSide * Math.cos(angle);
            const y = centerY + hexSide * Math.sin(angle);
            vertices.push({ x, y });
        }

        // Create hexagon path for clipping
        function createHexPath() {
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < vertices.length; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
        }

        // Save context state
        ctx.save();

        // Clip to hexagon shape
        createHexPath();
//        ctx.clip();


        const blobRadius = hexSide * 0.7; // Base size of the blob (increased from 0.15)

        ctx.fillStyle = '#000000';
        ctx.beginPath();

        for ( let direction = 0; direction < 6; direction++ ) {

          // first, figure out what hexes are adjacent
          const ccwHex = hexAdjacent( xI, yI, (direction+5)%6 );
          const acrossHex = hexAdjacent( xI, yI, direction );
          const cwHex = hexAdjacent( xI, yI, (direction+1)%6 );

          //then figure out if they have pits
          const ccwTar = ( inBounds( ccwHex.x, ccwHex.y ) ? map.grid[ccwHex.x][ccwHex.y].includes('tar') ||  map.grid[ccwHex.x][ccwHex.y].includes('offboard') : true );

          const acrossTar = ( inBounds( acrossHex.x, acrossHex.y ) ? map.grid[acrossHex.x][acrossHex.y].includes('tar') ||  map.grid[acrossHex.x][acrossHex.y].includes('offboard') : true );

          const cwTar = ( inBounds(cwHex.x, cwHex.y ) ? map.grid[cwHex.x][cwHex.y].includes('tar') ||  map.grid[cwHex.x][cwHex.y].includes('offboard') : true );

          //then we find the corners
          const x1 = centerX + hexSide * Math.cos(direction * Math.PI/3 - Math.PI*2/3);
          const y1 = centerY + hexSide * Math.sin(direction * Math.PI/3 - Math.PI*2/3);

          const x2 = centerX + hexSide * Math.cos((direction+1) * Math.PI/3 - Math.PI*2/3);
          const y2 = centerY + hexSide * Math.sin((direction+1) * Math.PI/3 - Math.PI*2/3);

          // now we move around based on all these established variables.
//          if ( ccwWater && acrossWater ) {
          if ( ccwTar ) {

              x=x1;
              y=y1;

          } else if ( acrossTar ) {

            x = x1 + 0.15 * (x2 - x1);
            y = y1 + 0.15 * (y2 - y1);

          } else {

            x = centerX + blobRadius * Math.cos( vertexStraddlingAngles[ direction * 2 + 1 ] );
            y = centerY + blobRadius * Math.sin( vertexStraddlingAngles[ direction * 2 + 1 ] );

          }

          // now we move to that points
          if ( direction === 0 ) {
              ctx.moveTo(x, y);
          } else {
              ctx.lineTo(x, y);
          }

          // now we do the next corner
//          if ( cwWater && acrossWater ) {
          if ( cwTar && !ccwTar ) {

              ctx.lineTo(x2, y2);

          } else if ( acrossTar ) {

            x = x1 + 0.85 * (x2 - x1);
            y = y1 + 0.85 * (y2 - y1);

            ctx.lineTo(x, y);

          } else if (cwTar && ccwTar ) {

            // Calculate the new endpoint
              let newX = x1 + 0.85 * (x2 - x1);
              let newY = y1 + 0.85 * (y2 - y1);

              // Get current position (the point you just did lineTo)
              let currentX = x; // your current x position
              let currentY = y; // your current y position

              // Calculate midpoint between current position and new endpoint
              let midX = (currentX + newX) / 2;
              let midY = (currentY + newY) / 2;

              // Calculate direction from midpoint toward center
              let directionToCenter = Math.atan2(centerY - midY, centerX - midX);

              // Calculate control point (10-15% toward center)
              let curveStrength = 0.1 + Math.random() * 0.05; // 10-15%
              let distanceToCenter = Math.sqrt((centerX - midX) ** 2 + (centerY - midY) ** 2);
              let controlX = midX + Math.cos(directionToCenter) * distanceToCenter * curveStrength;
              let controlY = midY + Math.sin(directionToCenter) * distanceToCenter * curveStrength;

              // Draw the curved line
              ctx.quadraticCurveTo(controlX, controlY, newX, newY);
              ctx.lineTo(x2,y2);

          } else {


            let x3 = centerX + blobRadius * Math.cos( vertexStraddlingAngles[ (direction * 2 + 2)%12 ] );
            let y3 = centerY + blobRadius * Math.sin( vertexStraddlingAngles[ (direction * 2 + 2)%12 ] );

            let midX = (x + x3) / 2;
            let midY = (y + y3) / 2;
            let directionToWater = Math.atan2(midY - centerY, midX - centerX);

            // Create two control points with slight variation for more natural curves
            let bulgeDistance = hexSide * (0.1 + Math.random() * 0.1); // Random bulge 0.1-0.2
            let control1X = midX + Math.cos(directionToWater + 0.2) * bulgeDistance;
            let control1Y = midY + Math.sin(directionToWater + 0.2) * bulgeDistance;
            let control2X = midX + Math.cos(directionToWater - 0.2) * bulgeDistance;
            let control2Y = midY + Math.sin(directionToWater - 0.2) * bulgeDistance;

            ctx.bezierCurveTo(control1X, control1Y, control2X, control2Y, x3, y3);

          }

        }

        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = '#222222';

        // Draw dark patches/bubbles in the tar
            const patchCount = 4 + Math.floor(Math.random() * 4); // 2-4 patches

            for (let patch = 0; patch < patchCount; patch++) {
                const patchAngle = Math.random() * Math.PI * 2;
                const patchRadius = Math.random() * hexSide * 0.6;
                const patchX = centerX + Math.cos(patchAngle) * patchRadius;
                const patchY = centerY + Math.sin(patchAngle) * patchRadius;

                const patchSize = hexSide * (0.08 + Math.random() * 0.12); // Variable patch size

                offscreenContext.beginPath();
                offscreenContext.arc(patchX, patchY, patchSize, 0, Math.PI * 2);
                offscreenContext.fill();
            }



        ctx.restore();

    }




    function drawWater( centerX, centerY ) {
        const ctx = offscreenContext;
        const originalLineWidth = ctx.lineWidth;

        // Calculate hexagon vertices
        const vertices = [];
        for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI) / 3;
            const x = centerX + hexSide * Math.cos(angle);
            const y = centerY + hexSide * Math.sin(angle);
            vertices.push({ x, y });
        }

//         // Create hexagon path for clipping
//         function createHexPath() {
//             ctx.beginPath();
//             ctx.moveTo(vertices[0].x, vertices[0].y);
//             for (let i = 1; i < vertices.length; i++) {
//                 ctx.lineTo(vertices[i].x, vertices[i].y);
//             }
//             ctx.closePath();
//         }
//
//         // Save context state
//         ctx.save();
//
//         // Clip to hexagon shape
//         createHexPath();
// //        ctx.clip();


        const blobRadius = hexSide * 0.8; // Base size of the blob (increased from 0.15)

        ctx.fillStyle = map.palette.water;
        ctx.beginPath();

        for ( let direction = 0; direction < 6; direction++ ) {

          // first, figure out what hexes are adjacent
          const ccwHex = hexAdjacent( xI, yI, (direction+5)%6 );
          const acrossHex = hexAdjacent( xI, yI, direction );
          const cwHex = hexAdjacent( xI, yI, (direction+1)%6 );

          //then figure out if they have pits
          const ccwWater = ( inBounds( ccwHex.x, ccwHex.y ) ? map.grid[ccwHex.x][ccwHex.y].includes('water') || map.grid[ccwHex.x][ccwHex.y].includes('pit') || map.grid[ccwHex.x][ccwHex.y].includes('offboard') : true );

          const acrossWater = ( inBounds( acrossHex.x, acrossHex.y ) ? map.grid[acrossHex.x][acrossHex.y].includes('water') || map.grid[acrossHex.x][acrossHex.y].includes('pit') || map.grid[acrossHex.x][acrossHex.y].includes('offboard') : true );

          const cwWater = ( inBounds(cwHex.x, cwHex.y ) ? map.grid[cwHex.x][cwHex.y].includes('water') || map.grid[cwHex.x][cwHex.y].includes('pit') || map.grid[cwHex.x][cwHex.y].includes('offboard') : true );

          //then we find the corners
          const x1 = centerX + hexSide * Math.cos(direction * Math.PI/3 - Math.PI*2/3);
          const y1 = centerY + hexSide * Math.sin(direction * Math.PI/3 - Math.PI*2/3);

          const x2 = centerX + hexSide * Math.cos((direction+1) * Math.PI/3 - Math.PI*2/3);
          const y2 = centerY + hexSide * Math.sin((direction+1) * Math.PI/3 - Math.PI*2/3);

          // now we move around based on all these established variables.
//          if ( ccwWater && acrossWater ) {
          if ( ccwWater ) {

              x=x1;
              y=y1;

          } else if ( acrossWater ) {

            x = x1 + 0.15 * (x2 - x1);
            y = y1 + 0.15 * (y2 - y1);

          } else {

            x = centerX + blobRadius * Math.cos( vertexStraddlingAngles[ direction * 2 + 1 ] );
            y = centerY + blobRadius * Math.sin( vertexStraddlingAngles[ direction * 2 + 1 ] );

          }

          // now we move to that points
          if ( direction === 0 ) {
              ctx.moveTo(x, y);
          } else {
              ctx.lineTo(x, y);
          }

          // now we do the next corner
//          if ( cwWater && acrossWater ) {
          if ( cwWater && !ccwWater ) {

              ctx.lineTo(x2, y2);

          } else if ( acrossWater ) {

            x = x1 + 0.85 * (x2 - x1);
            y = y1 + 0.85 * (y2 - y1);

            ctx.lineTo(x, y);

          } else if (cwWater && ccwWater ) {

            // Calculate the new endpoint
              let newX = x1 + 0.85 * (x2 - x1);
              let newY = y1 + 0.85 * (y2 - y1);

              // Get current position (the point you just did lineTo)
              let currentX = x; // your current x position
              let currentY = y; // your current y position

              // Calculate midpoint between current position and new endpoint
              let midX = (currentX + newX) / 2;
              let midY = (currentY + newY) / 2;

              // Calculate direction from midpoint toward center
              let directionToCenter = Math.atan2(centerY - midY, centerX - midX);

              // Calculate control point (10-15% toward center)
              let curveStrength = 0.1 + Math.random() * 0.05; // 10-15%
              let distanceToCenter = Math.sqrt((centerX - midX) ** 2 + (centerY - midY) ** 2);
              let controlX = midX + Math.cos(directionToCenter) * distanceToCenter * curveStrength;
              let controlY = midY + Math.sin(directionToCenter) * distanceToCenter * curveStrength;

              // Draw the curved line
              ctx.quadraticCurveTo(controlX, controlY, newX, newY);
              ctx.lineTo(x2,y2);

          } else {

            // x = centerX + blobRadius * Math.cos( vertexStraddlingAngles[ (direction * 2 + 2)%12 ] );
            // y = centerY + blobRadius * Math.sin( vertexStraddlingAngles[ (direction * 2 + 2)%12 ] );
            // ctx.lineTo(x, y);

            let x3 = centerX + blobRadius * Math.cos( vertexStraddlingAngles[ (direction * 2 + 2)%12 ] );
            let y3 = centerY + blobRadius * Math.sin( vertexStraddlingAngles[ (direction * 2 + 2)%12 ] );

//            drawWavyLine( x, y, x3, y3);

            // these worked but there were ugly concave sections
            // let cPoints = getControlPoints( x, y, x3, y3 );
            //
            // ctx.bezierCurveTo( cPoints.control1.x, cPoints.control1.y, cPoints.control2.x, cPoints.control2.y, x3, y3)

            let midX = (x + x3) / 2;
            let midY = (y + y3) / 2;
            let directionToWater = Math.atan2(midY - centerY, midX - centerX);

            // Create two control points with slight variation for more natural curves
            let bulgeDistance = hexSide * (0.1 + Math.random() * 0.1); // Random bulge 0.1-0.2
            let control1X = midX + Math.cos(directionToWater + 0.2) * bulgeDistance;
            let control1Y = midY + Math.sin(directionToWater + 0.2) * bulgeDistance;
            let control2X = midX + Math.cos(directionToWater - 0.2) * bulgeDistance;
            let control2Y = midY + Math.sin(directionToWater - 0.2) * bulgeDistance;

            ctx.bezierCurveTo(control1X, control1Y, control2X, control2Y, x3, y3);

          }

        }

        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        //////////////////////////////waterRipple

        offscreenContext.strokeStyle = getContrastingShade( map.palette.water );

        for ( let i = 0; i < 6; i++ ) {

          baseAngle = Math.PI - i * Math.PI / 3;

          startPoint = { x: centerX + Math.sin( baseAngle + Math.PI/6 ) * hexSide * 0.65,
                          y: centerY + Math.cos( baseAngle + Math.PI/6 ) * hexSide * 0.65 };

          let adjHex = hexAdjacent( xI, yI, i );

          // if this is a waterfall edge we put current lines
          if ( inBounds( adjHex.x, adjHex.y ) && map.grid[ adjHex.x ][ adjHex.y ].includes('pit') ) {



            // Calculate the angle for the waterfall direction
            const fallAngle = (i * 60 - 90) * Math.PI / 180; // Convert to radians, -90 to start at top

            // Calculate the direction toward the waterfall (perpendicular to the hex edge)
            const towardFallX = Math.cos(fallAngle + Math.PI); // Point toward the fall
            const towardFallY = Math.sin(fallAngle + Math.PI);

            // Calculate parallel direction along the hex edge
            const parallelAngle = fallAngle + Math.PI / 2;
            const parallelX = Math.cos(parallelAngle);
            const parallelY = Math.sin(parallelAngle);

            // Calculate position of the waterfall edge
            const edgeDistance = hexSide * Math.cos(Math.PI / 6); // Distance from center to edge
            const edgeX = centerX + Math.cos(fallAngle) * edgeDistance;
            const edgeY = centerY + Math.sin(fallAngle) * edgeDistance;

            // Draw 4-6 current lines
            const lineCount = 5 + Math.floor(Math.random() * 2);
            const lineLength = hexSide / 5; // Back to original length

            offscreenContext.lineWidth = 1;
            offscreenContext.lineCap = 'round';

            for (let line = 0; line < lineCount; line++) {
                // Spread lines along the waterfall edge (center 80% only)
                const spreadRange = hexSide * 0.8;
                const spreadOffset = (line / (lineCount - 1) - 0.5) * spreadRange;

                // Vary the length of each line
                const baseLength = hexSide / 7;
                const lengthVariation = baseLength; // 50% variation
                const thisLineLength = baseLength + (Math.random()) * lengthVariation;

                // Starting position at the waterfall edge
                const lineEndX = edgeX + parallelX * spreadOffset;
                const lineEndY = edgeY + parallelY * spreadOffset;

                // Calculate start position (variable distance inward from edge)
                const lineStartX = lineEndX + towardFallX * thisLineLength;
                const lineStartY = lineEndY + towardFallY * thisLineLength;

                // Draw wiggly line toward the waterfall
                offscreenContext.beginPath();
                offscreenContext.moveTo(lineStartX, lineStartY);

                // Create wiggly line with multiple segments
                const segments = 4 + Math.floor(Math.random() * 3);

                for (let seg = 1; seg <= segments; seg++) {
                    const progress = seg / segments;

                    // Base position along the line toward waterfall
                    const baseX = lineStartX - towardFallX * thisLineLength * progress;
                    const baseY = lineStartY - towardFallY * thisLineLength * progress;

                    // Add wiggle perpendicular to the main direction
                    const wiggleAmount = (hexSide / 20) * (Math.random() - 0.5);
                    const wiggleX = baseX + parallelX * wiggleAmount;
                    const wiggleY = baseY + parallelY * wiggleAmount;

                    offscreenContext.lineTo(wiggleX, wiggleY);
                }

                offscreenContext.stroke();
            }





          } else { // if it's water or offboard we don't put ripples, otherwise we do

            let adjWater = ( inBounds( adjHex.x, adjHex.y ) ? map.grid[ adjHex.x ][ adjHex.y ].includes('water') || map.grid[ adjHex.x ][ adjHex.y ].includes('offboard') : true );

            if ( !adjWater ) {

              offscreenContext.beginPath();
              offscreenContext.moveTo( startPoint.x, startPoint.y );

              waterRipple();

            }

          }



        }


        // Restore context state
        ctx.restore();

        // // Draw hexagon border
        // ctx.strokeStyle = '#2a1f15';
        // ctx.lineWidth = 2;
        // createHexPath();
        // ctx.stroke();

        ctx.lineWidth = originalLineWidth;

    }

    function waterRipple () {

//      console.log('strokeStyle after setting:', offscreenContext.strokeStyle);
//      console.log('hi');

      const radius = hexSide * 0.65;

//      const bumpSize = Math.random() * 4 + 2;
      const bumpSize = Math.ceil(Math.random() * 2);
      const waves = Math.floor( Math.random() * 3 ) + 1;

      const thetaStart = baseAngle + Math.PI/6;
      const thetaStep = ( (baseAngle - Math.PI/6) - thetaStart ) / 100;
      const radiusStart = 0;
      const radiusStep = ( Math.PI * waves + Math.PI ) / 100;

      let drawing=1;

      for ( i = 0 ; i < 101 ; i ++ ) {

        let thisRadius = radius - Math.sin( radiusStart + radiusStep * i ) * bumpSize;

        if ( drawing > 0 ) {
          offscreenContext.lineTo( centerX + Math.sin( thetaStart + thetaStep * i ) * thisRadius,
                                  centerY + Math.cos( thetaStart + thetaStep * i ) * thisRadius );
        } else {
          offscreenContext.moveTo( centerX + Math.sin( thetaStart + thetaStep * i ) * thisRadius,
                                  centerY + Math.cos( thetaStart + thetaStep * i ) * thisRadius );
          drawing++;
        }

        if ( Math.random() < 0.03 ) {
          drawing = -10 -1 * Math.random() * 10;
        }

      }
      offscreenContext.stroke();
      offscreenContext.beginPath();

    }




    function hexToHsl(hex) {
      // Remove the hash if present
      hex = hex.replace('#', '');

      // Convert hex to RGB
      const r = parseInt(hex.substr(0, 2), 16) / 255;
      const g = parseInt(hex.substr(2, 2), 16) / 255;
      const b = parseInt(hex.substr(4, 2), 16) / 255;

      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const diff = max - min;

      let h, s, l = (max + min) / 2;

      if (diff === 0) {
        h = s = 0; // achromatic
      } else {
        s = l > 0.5 ? diff / (2 - max - min) : diff / (max + min);

        switch (max) {
          case r: h = (g - b) / diff + (g < b ? 6 : 0); break;
          case g: h = (b - r) / diff + 2; break;
          case b: h = (r - g) / diff + 4; break;
        }
        h /= 6;
      }

      return { hue: h, saturation: s, lightness: l };
    }

    function hslToHex(hsl) {
      const { hue: h, saturation: s, lightness: l } = hsl;

      const hue2rgb = (p, q, t) => {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
      };

      let r, g, b;

      if (s === 0) {
        r = g = b = l; // achromatic
      } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }

      const toHex = (c) => {
        const hex = Math.round(c * 255).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      };

      return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
    }

    function getContrastingShade(hexColor) {
      // Convert hex to HSL
      if ( hexColor == undefined ) {
        hexColor='#ffffff';
      }

      const hsl = hexToHsl(hexColor);

      // Determine if color is light or dark
      const isLight = hsl.lightness > 0.2;

      // Adjust lightness for contrast
      if (isLight) {
        // Make darker - reduce lightness by 20-30%
        hsl.lightness = Math.max(0, hsl.lightness - 0.25);
      } else {
        // Make lighter - increase lightness by 20-30%
        hsl.lightness = Math.min(1, hsl.lightness + 0.25);
      }

      return hslToHex(hsl);
    }




    function drawDeepPit( centerX, centerY ) {
        const ctx = offscreenContext;
        const originalLineWidth = ctx.lineWidth;

        // Calculate hexagon vertices
        const vertices = [];
        for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI) / 3;
            const x = centerX + hexSide * Math.cos(angle);
            const y = centerY + hexSide * Math.sin(angle);
            vertices.push({ x, y });
        }

        // Create hexagon path for clipping
        function createHexPath() {
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < vertices.length; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
        }

        // Save context state
        ctx.save();

        // Clip to hexagon shape
        createHexPath();
        ctx.clip();

        // start of original shaded lines code

        // // Draw radiating dark lines from edges toward center
        // const lineCount = 24; // Number of lines to draw
        //
        // for (let i = 0; i < lineCount; i++) {
        //     const angle = (i * Math.PI * 2) / lineCount;
        //
        //     // Start point at edge of hexagon
        //     let startX = centerX + hexSide * Math.cos(angle);
        //     let startY = centerY + hexSide * Math.sin(angle);
        //
        //     // Find intersection with hexagon edge more precisely
        //     let minDist = Infinity;
        //     let edgeX = startX;
        //     let edgeY = startY;
        //
        //     // Check intersection with each hexagon side
        //     for (let j = 0; j < 6; j++) {
        //         const v1 = vertices[j];
        //         const v2 = vertices[(j + 1) % 6];
        //
        //         // Line intersection calculation
        //         const dx = v2.x - v1.x;
        //         const dy = v2.y - v1.y;
        //         const det = dx * Math.sin(angle) - dy * Math.cos(angle);
        //
        //         if (Math.abs(det) > 0.001) {
        //             const u = ((centerX - v1.x) * Math.sin(angle) - (centerY - v1.y) * Math.cos(angle)) / det;
        //             const v = ((centerX - v1.x) * dy - (centerY - v1.y) * dx) / det;
        //
        //             if (u >= 0 && u <= 1 && v > 0) {
        //                 const intX = v1.x + u * dx;
        //                 const intY = v1.y + u * dy;
        //                 const dist = Math.sqrt((intX - centerX) ** 2 + (intY - centerY) ** 2);
        //
        //                 if (dist < minDist) {
        //                     minDist = dist;
        //                     edgeX = intX;
        //                     edgeY = intY;
        //                 }
        //             }
        //         }
        //     }
        //
        //     // End point closer to center (tapered)
        //     const taper = 0.3 + Math.random() * 0.4; // Random taper between 30-70%
        //     const endX = centerX + (edgeX - centerX) * taper;
        //     const endY = centerY + (edgeY - centerY) * taper;
        //
        //     // Create gradient for the line (darker at edge, lighter toward center)
        //     const gradient = ctx.createLinearGradient(edgeX, edgeY, endX, endY);
        //     gradient.addColorStop(0, 'rgba(0, 0, 0, 0.8)');
        //     gradient.addColorStop(0.7, 'rgba(0, 0, 0, 0.4)');
        //     gradient.addColorStop(1, 'rgba(0, 0, 0, 0.1)');
        //
        //     // Draw the line with varying width
        //     ctx.strokeStyle = gradient;
        //     ctx.lineWidth = 2 + Math.random() * 3; // Random width between 2-5
        //     ctx.lineCap = 'round';
        //
        //     ctx.beginPath();
        //     ctx.moveTo(edgeX, edgeY);
        //     ctx.lineTo(endX, endY);
        //     ctx.stroke();
        // }
        // end of original shaded lines code


        ///////// jagged lines code

        for (let i = 0; i < 6; i++) {
            const angle = (i * 60 - 90) * Math.PI / 180; // Start from top, go clockwise
            const x = centerX + hexSide * Math.cos(angle);
            const y = centerY + hexSide * Math.sin(angle);
            vertices.push({x, y});
        }

        // Draw 4 jagged lines from each edge toward center
        for (let i = 0; i < 6; i++) {
            const startVertex = vertices[i];
            const endVertex = vertices[(i + 1) % 6];

            // Draw 4 lines along this edge
            for (let j = 0; j < 4; j++) {
                // Position along the edge (0.2, 0.4, 0.6, 0.8)
                const t = (j + 1) / 5;
                const edgeX = startVertex.x + (endVertex.x - startVertex.x) * t;
                const edgeY = startVertex.y + (endVertex.y - startVertex.y) * t;

                // Create jagged path from edge toward center
                const segments = 6; // Number of jagged segments
//                const baseLength = hexSide * 0.6; // Only go 25% toward center

                ctx.beginPath();
                ctx.moveTo(edgeX, edgeY);

                for (let k = 1; k <= segments; k++) {
                    const progress = k / segments;

                    // Base position moving toward center
                    const baseX = edgeX + (centerX - edgeX) * progress * 0.4;
                    const baseY = edgeY + (centerY - edgeY) * progress * 0.4;

                    // Add jagged offset perpendicular to the line
                    const perpX = -(centerY - edgeY);
                    const perpY = (centerX - edgeX);
                    const perpLength = Math.sqrt(perpX * perpX + perpY * perpY);
                    const normalizedPerpX = perpX / perpLength;
                    const normalizedPerpY = perpY / perpLength;

                    // Much smaller jagged offset with rapid tapering
                    const jaggedOffset = (Math.random() - 0.5) * 4 * (1 - progress * progress * 3);
                    const finalX = baseX + normalizedPerpX * jaggedOffset;
                    const finalY = baseY + normalizedPerpY * jaggedOffset;

                    ctx.lineTo(finalX, finalY);
                }

                // ctx.strokeStyle = '#333';
                // ctx.lineWidth = 2;
                // ctx.stroke();

                const gradient = ctx.createLinearGradient(edgeX, edgeY,
                    edgeX + (centerX - edgeX) * 0.4, edgeY + (centerY - edgeY) * 0.4);
                gradient.addColorStop(0, '#333'); // Opaque at start
                gradient.addColorStop(1, 'rgba(51, 51, 51, 0)'); // Transparent at end

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2;
                ctx.stroke();


            }
        }

        ///////// end jagged lines code


        const blobRadius = hexSide * 0.66; // Base size of the blob (increased from 0.15)

        ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
        ctx.beginPath();

        // this works, but I want to connect to other hexes...
        // // Create irregular black blob at the bottom
        // const blobPoints = 8; // Number of points for irregular shape
        //
        //
        // for (let i = 0; i < blobPoints; i++) {
        //     const angle = (i * Math.PI * 2) / blobPoints;
        //     const randomRadius = blobRadius * (0.6 + Math.random() * 0.6); // Random variation
        //     const x = centerX + randomRadius * Math.cos(angle);
        //     const y = centerY + randomRadius * Math.sin(angle);
        //
        //     if (i === 0) {
        //         ctx.moveTo(x, y);
        //     } else {
        //         ctx.lineTo(x, y);
        //     }
        // }

        for ( let direction = 0; direction < 6; direction++ ) {

          // first, figure out what hexes are adjacent
          const ccwHex = hexAdjacent( xI, yI, (direction+5)%6 );
          const acrossHex = hexAdjacent( xI, yI, direction );
          const cwHex = hexAdjacent( xI, yI, (direction+1)%6 );

          //then figure out if they have pits
          const ccwPit = ( inBounds( ccwHex.x, ccwHex.y ) ? map.grid[ccwHex.x][ccwHex.y].includes('pit') || map.grid[ccwHex.x][ccwHex.y].includes('lava') || map.grid[ccwHex.x][ccwHex.y].includes('water') : true );

          const acrossPit = ( inBounds ( acrossHex.x, acrossHex.y ) ? map.grid[acrossHex.x][acrossHex.y].includes('pit') || map.grid[acrossHex.x][acrossHex.y].includes('lava') || map.grid[acrossHex.x][acrossHex.y].includes('water') : true );

          const cwPit = ( inBounds( cwHex.x, cwHex.y ) ? map.grid[cwHex.x][cwHex.y].includes('pit') || map.grid[cwHex.x][cwHex.y].includes('lava') || map.grid[cwHex.x][cwHex.y].includes('water') : true );

          //then we find the corners
          const x1 = centerX + hexSide * Math.cos(direction * Math.PI/3 - Math.PI*2/3);
          const y1 = centerY + hexSide * Math.sin(direction * Math.PI/3 - Math.PI*2/3);

          const x2 = centerX + hexSide * Math.cos((direction+1) * Math.PI/3 - Math.PI*2/3);
          const y2 = centerY + hexSide * Math.sin((direction+1) * Math.PI/3 - Math.PI*2/3);

          // now we move around based on all these established variables.
          if ( ccwPit && acrossPit ) {

              x=x1;
              y=y1;

          } else if ( acrossPit ) {

            x = x1 + 0.15 * (x2 - x1);
            y = y1 + 0.15 * (y2 - y1);

          } else {

            x = centerX + blobRadius * Math.cos( vertexStraddlingAngles[ direction * 2 + 1 ] );
            y = centerY + blobRadius * Math.sin( vertexStraddlingAngles[ direction * 2 + 1 ] );

          }

          // now we move to that points
          if ( direction === 0 ) {
              ctx.moveTo(x, y);
          } else {
              ctx.lineTo(x, y);
          }

          // now we do the next corner
          if ( cwPit && acrossPit ) {

              ctx.lineTo(x2, y2);

          } else if ( acrossPit ) {

            x = x1 + 0.85 * (x2 - x1);
            y = y1 + 0.85 * (y2 - y1);

            ctx.lineTo(x, y);

          } else {

            // x = centerX + blobRadius * Math.cos( vertexStraddlingAngles[ (direction * 2 + 2)%12 ] );
            // y = centerY + blobRadius * Math.sin( vertexStraddlingAngles[ (direction * 2 + 2)%12 ] );
            // ctx.lineTo(x, y);

            let x3 = centerX + blobRadius * Math.cos( vertexStraddlingAngles[ (direction * 2 + 2)%12 ] );
            let y3 = centerY + blobRadius * Math.sin( vertexStraddlingAngles[ (direction * 2 + 2)%12 ] );

//            drawWavyLine( x, y, x3, y3);

            // let cPoints = getControlPoints( x, y, x3, y3 );
            //
            // ctx.bezierCurveTo( cPoints.control1.x, cPoints.control1.y, cPoints.control2.x, cPoints.control2.y, x3, y3)

            let midX = (x + x3) / 2;
            let midY = (y + y3) / 2;
            let directionToWater = Math.atan2(midY - centerY, midX - centerX);

            // Create two control points with slight variation for more natural curves
            let bulgeDistance = hexSide * (0.1 + Math.random() * 0.1); // Random bulge 0.1-0.2
            let control1X = midX + Math.cos(directionToWater + 0.2) * bulgeDistance;
            let control1Y = midY + Math.sin(directionToWater + 0.2) * bulgeDistance;
            let control2X = midX + Math.cos(directionToWater - 0.2) * bulgeDistance;
            let control2Y = midY + Math.sin(directionToWater - 0.2) * bulgeDistance;

            ctx.bezierCurveTo(control1X, control1Y, control2X, control2Y, x3, y3);


          }


        }


        ctx.closePath();
        ctx.fill();
        ctx.stroke();



        // Add some additional small dark spots around the blob
        for (let i = 0; i < 4; i++) { // Increased from 3 to 4 spots
            const spotAngle = Math.random() * Math.PI * 2;
            const spotDist = blobRadius * (0.1 + Math.random() * 0.7); // Spots closer to main blob
            const spotX = centerX + spotDist * Math.cos(spotAngle);
            const spotY = centerY + spotDist * Math.sin(spotAngle);
            const spotSize = blobRadius * 0.2 * Math.random();

            ctx.fillStyle = 'rgba( 64,64, 64, 1)';
            ctx.beginPath();
            ctx.arc(spotX, spotY, spotSize, 0, Math.PI * 2);
            ctx.fill();
        }

        //waterfall/lavafall code

        for ( let direction = 0; direction < 6; direction++ ) {

          const acrossHex = hexAdjacent( xI, yI, direction );

          if ( !( inBounds( acrossHex.x, acrossHex.y ) ) ) continue;

          if ( map.grid[acrossHex.x][acrossHex.y].includes('water') ) {

            offscreenContext.fillStyle = map.palette.water;
            drawFall( direction );

          } else if ( map.grid[acrossHex.x][acrossHex.y].includes('lava') ) {

            offscreenContext.fillStyle = map.palette.lava;
            drawFall( direction );
          }

        }

          // end of waterfall/lavafall code



        // Restore context state
        ctx.restore();

        // Draw hexagon border
        // ctx.strokeStyle = '#2a1f15';
        // ctx.lineWidth = 2;
        // createHexPath();
        // ctx.stroke();

        ctx.lineWidth = originalLineWidth;

    }


    function drawFall(direction) {

      // Calculate the angle for the waterfall side (0 = straight up, clockwise)
       const sideAngle = (direction * 60 - 90) * Math.PI / 180; // Convert to radians, -90 to start at top

       // Calculate the position of the waterfall side's center
       const sideDistance = hexSide * Math.cos(Math.PI / 6); // Distance from center to side
       const sideX = centerX + Math.cos(sideAngle) * sideDistance;
       const sideY = centerY + Math.sin(sideAngle) * sideDistance;

       // Calculate perpendicular direction (inward from the side)
       const perpAngle = sideAngle + Math.PI; // Point inward
       const perpX = Math.cos(perpAngle);
       const perpY = Math.sin(perpAngle);

       // Calculate parallel direction along the side
       const parallelAngle = sideAngle + Math.PI / 2;
       const parallelX = Math.cos(parallelAngle);
       const parallelY = Math.sin(parallelAngle);

       // Get the current fill style to use as base color
       const baseColor = offscreenContext.fillStyle;

       // Helper function to lighten a color
       function lightenColor(color, factor) {
           if (color.startsWith('#')) {
               // Handle hex colors
               const hex = color.slice(1);
               const r = parseInt(hex.substr(0, 2), 16);
               const g = parseInt(hex.substr(2, 2), 16);
               const b = parseInt(hex.substr(4, 2), 16);

               const newR = Math.min(255, Math.floor(r + (255 - r) * factor));
               const newG = Math.min(255, Math.floor(g + (255 - g) * factor));
               const newB = Math.min(255, Math.floor(b + (255 - b) * factor));

               return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
           } else if (color.startsWith('rgb')) {
               // Handle rgb colors
               const matches = color.match(/\d+/g);
               if (matches && matches.length >= 3) {
                   const r = parseInt(matches[0]);
                   const g = parseInt(matches[1]);
                   const b = parseInt(matches[2]);

                   const newR = Math.min(255, Math.floor(r + (255 - r) * factor));
                   const newG = Math.min(255, Math.floor(g + (255 - g) * factor));
                   const newB = Math.min(255, Math.floor(b + (255 - b) * factor));

                   return `rgb(${newR}, ${newG}, ${newB})`;
               }
           }
           return color; // Return original if can't parse
       }

       // Helper function to check if a point is inside the hexagon
       function isInsideHexagon(x, y) {
           const dx = x - centerX;
           const dy = y - centerY;
           const distance = Math.sqrt(dx * dx + dy * dy);

           // Quick circle check first
           if (distance > hexSide) return false;

           // More precise hexagon check
           const angle = Math.atan2(dy, dx);
           const hexAngle = ((angle + Math.PI) % (Math.PI / 3)) - Math.PI / 6;
           const maxDistance = hexSide * Math.cos(Math.PI / 6) / Math.cos(hexAngle);

           return distance <= maxDistance;
       }

       // Layer 0: Edge bubbles - cover the hex edge first
       offscreenContext.fillStyle = baseColor;
       const edgeBubbleCount = 8 + Math.floor(Math.random() * 6);

       for (let i = 0; i < edgeBubbleCount; i++) {
           const bubbleSize = 4 + Math.random() * 6;

           // Position bubbles directly along the hex edge, but only center 80%
           const progress = (i / (edgeBubbleCount - 1)) * 0.8 + 0.1; // Map to 0.1 to 0.9 (center 80%)
           const alongSide = (progress - 0.5) * hexSide; // Center around the side
           const edgeOffset = Math.random() * 2 - 1; // Small random offset from exact edge

           const bubbleX = sideX + parallelX * alongSide + perpX * edgeOffset;
           const bubbleY = sideY + parallelY * alongSide + perpY * edgeOffset;

           // Only draw if inside hexagon
           if (isInsideHexagon(bubbleX, bubbleY)) {
               offscreenContext.beginPath();
               offscreenContext.arc(bubbleX, bubbleY, bubbleSize, 0, 2 * Math.PI);
               offscreenContext.fill();
           }
       }

       // Layer 1: Large bubbles in base color
       const layer1Count = 15 + Math.floor(Math.random() * 10);

       for (let i = 0; i < layer1Count; i++) {
           const bubbleSize = 3 + Math.random() * 8;

           // Position bubbles closer to the waterfall side, but only center 80%
           const alongSide = (Math.random() - 0.5) * hexSide * 0.56; // 0.7 * 0.8 = center 80% of the side
           const inwardDistance = Math.random() * hexSide * 0.25;

           const bubbleX = sideX + parallelX * alongSide + perpX * inwardDistance;
           const bubbleY = sideY + parallelY * alongSide + perpY * inwardDistance;

           // Only draw if inside hexagon
           if (isInsideHexagon(bubbleX, bubbleY)) {
               offscreenContext.beginPath();
               offscreenContext.arc(bubbleX, bubbleY, bubbleSize, 0, 2 * Math.PI);
               offscreenContext.fill();
           }
       }

       // Layer 2: Medium bubbles, lighter color
       offscreenContext.fillStyle = lightenColor(baseColor, 0.3);
       const layer2Count = 10 + Math.floor(Math.random() * 8);

       for (let i = 0; i < layer2Count; i++) {
           const bubbleSize = 2 + Math.random() * 5;

           const alongSide = (Math.random() - 0.5) * hexSide * 0.4; // 0.5 * 0.8 = center 80% of the side
           const inwardDistance = (Math.random() * hexSide * 0.2) + (hexSide * 0.05); // Start 5% inward from edge

           const bubbleX = sideX + parallelX * alongSide + perpX * inwardDistance;
           const bubbleY = sideY + parallelY * alongSide + perpY * inwardDistance;

           if (isInsideHexagon(bubbleX, bubbleY)) {
               offscreenContext.beginPath();
               offscreenContext.arc(bubbleX, bubbleY, bubbleSize, 0, 2 * Math.PI);
               offscreenContext.fill();
           }
       }

       // Layer 3: Small bubbles, even lighter color
       offscreenContext.fillStyle = lightenColor(baseColor, 0.6);
       const layer3Count = 8 + Math.floor(Math.random() * 6);

       for (let i = 0; i < layer3Count; i++) {
           const bubbleSize = 1 + Math.random() * 3;

           const alongSide = (Math.random() - 0.5) * hexSide * 0.24; // 0.3 * 0.8 = center 80% of the side
           const inwardDistance = (Math.random() * hexSide * 0.15) + (hexSide * 0.08); // Start 8% inward from edge

           const bubbleX = sideX + parallelX * alongSide + perpX * inwardDistance;
           const bubbleY = sideY + parallelY * alongSide + perpY * inwardDistance;

           if (isInsideHexagon(bubbleX, bubbleY)) {
               offscreenContext.beginPath();
               offscreenContext.arc(bubbleX, bubbleY, bubbleSize, 0, 2 * Math.PI);
               offscreenContext.fill();
           }
       }

       // Restore the original fill style
       offscreenContext.fillStyle = baseColor;

    }  // end drawFall()


    function drawLava( centerX, centerY ) {
        const ctx = offscreenContext;
        const originalLineWidth = ctx.lineWidth;

        // Calculate hexagon vertices
        const vertices = [];
        for (let i = 0; i < 6; i++) {
            const angle = (i * Math.PI) / 3;
            const x = centerX + hexSide * Math.cos(angle);
            const y = centerY + hexSide * Math.sin(angle);
            vertices.push({ x, y });
        }

        // Create hexagon path for clipping
        function createHexPath() {
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            for (let i = 1; i < vertices.length; i++) {
                ctx.lineTo(vertices[i].x, vertices[i].y);
            }
            ctx.closePath();
        }

        // Save context state
        ctx.save();

        // Clip to hexagon shape
        createHexPath();
        ctx.clip();


        const blobRadius = hexSide * 0.8; // Base size of the blob (increased from 0.15)

        ctx.fillStyle = map.palette.lava;
        ctx.beginPath();

        for ( let direction = 0; direction < 6; direction++ ) {

          // first, figure out what hexes are adjacent
          const ccwHex = hexAdjacent( xI, yI, (direction+5)%6 );
          const acrossHex = hexAdjacent( xI, yI, direction );
          const cwHex = hexAdjacent( xI, yI, (direction+1)%6 );

          //then figure out if they have pits
          const ccwLava = ( inBounds( ccwHex.x, ccwHex.y ) ? map.grid[ccwHex.x][ccwHex.y].includes('lava') || map.grid[ccwHex.x][ccwHex.y].includes('pit') || map.grid[ccwHex.x][ccwHex.y].includes('offboard') : true );

          const acrossLava = ( inBounds( acrossHex.x, acrossHex.y ) ? map.grid[acrossHex.x][acrossHex.y].includes('lava') || map.grid[acrossHex.x][acrossHex.y].includes('pit') || map.grid[acrossHex.x][acrossHex.y].includes('offboard') : true );

          const cwLava = ( inBounds(cwHex.x, cwHex.y ) ? map.grid[cwHex.x][cwHex.y].includes('lava') || map.grid[cwHex.x][cwHex.y].includes('pit')|| map.grid[cwHex.x][cwHex.y].includes('offboard') : true );

          //then we find the corners
          const x1 = centerX + hexSide * Math.cos(direction * Math.PI/3 - Math.PI*2/3);
          const y1 = centerY + hexSide * Math.sin(direction * Math.PI/3 - Math.PI*2/3);

          const x2 = centerX + hexSide * Math.cos((direction+1) * Math.PI/3 - Math.PI*2/3);
          const y2 = centerY + hexSide * Math.sin((direction+1) * Math.PI/3 - Math.PI*2/3);

          // now we move around based on all these established variables.
          if ( ccwLava && acrossLava ) {

              x=x1;
              y=y1;

          } else if ( acrossLava ) {

            x = x1 + 0.15 * (x2 - x1);
            y = y1 + 0.15 * (y2 - y1);

          } else {

            x = centerX + blobRadius * Math.cos( vertexStraddlingAngles[ direction * 2 + 1 ] );
            y = centerY + blobRadius * Math.sin( vertexStraddlingAngles[ direction * 2 + 1 ] );

          }

          // now we move to that points
          if ( direction === 0 ) {
              ctx.moveTo(x, y);
          } else {
              ctx.lineTo(x, y);
          }

          // now we do the next corner
          if ( cwLava && acrossLava ) {

              ctx.lineTo(x2, y2);

          } else if ( acrossLava ) {

            x = x1 + 0.85 * (x2 - x1);
            y = y1 + 0.85 * (y2 - y1);

            ctx.lineTo(x, y);

          } else {

            // x = centerX + blobRadius * Math.cos( vertexStraddlingAngles[ (direction * 2 + 2)%12 ] );
            // y = centerY + blobRadius * Math.sin( vertexStraddlingAngles[ (direction * 2 + 2)%12 ] );
            // ctx.lineTo(x, y);

            let x3 = centerX + blobRadius * Math.cos( vertexStraddlingAngles[ (direction * 2 + 2)%12 ] );
            let y3 = centerY + blobRadius * Math.sin( vertexStraddlingAngles[ (direction * 2 + 2)%12 ] );

//            drawWavyLine( x, y, x3, y3);


            let midX = (x + x3) / 2;
            let midY = (y + y3) / 2;
            let directionToWater = Math.atan2(midY - centerY, midX - centerX);

            // Create two control points with slight variation for more natural curves
            let bulgeDistance = hexSide * (0.1 + Math.random() * 0.1); // Random bulge 0.1-0.2
            let control1X = midX + Math.cos(directionToWater + 0.2) * bulgeDistance;
            let control1Y = midY + Math.sin(directionToWater + 0.2) * bulgeDistance;
            let control2X = midX + Math.cos(directionToWater - 0.2) * bulgeDistance;
            let control2Y = midY + Math.sin(directionToWater - 0.2) * bulgeDistance;

            ctx.bezierCurveTo(control1X, control1Y, control2X, control2Y, x3, y3);


          }


        }


        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        addLavaTexture();
        offscreenContext.beginPath();

        // Restore context state
        ctx.restore();

        // // Draw hexagon border
        // ctx.strokeStyle = '#2a1f15';
        // ctx.lineWidth = 2;
        // createHexPath();
        // ctx.stroke();

        ctx.lineWidth = originalLineWidth;

    }



    ///////////////////////////////////////////


    // Function to check if a point is inside the hexagon
    function isPointInHex(x, y, centerX, centerY, hexSide) {
        const dx = Math.abs(x - centerX);
        const dy = Math.abs(y - centerY);
        const hexWidth = hexSide * Math.sqrt(3) / 2;

        if (dx > hexWidth || dy > hexSide) return false;
        if (dx <= hexWidth / 2) return true;

        const slope = hexSide / (hexWidth / 2);
        return dy <= hexSide - slope * (dx - hexWidth / 2);
    }

    // Function to create a lighter/glowing version of the lava color
    function createGlowColor(baseColor, lightenAmount = 80) {
        if (baseColor.startsWith('#')) {
            // Convert hex to RGB, lighten significantly
            const r = parseInt(baseColor.substr(1, 2), 16);
            const g = parseInt(baseColor.substr(3, 2), 16);
            const b = parseInt(baseColor.substr(5, 2), 16);

            const newR = Math.min(255, r + lightenAmount);
            const newG = Math.min(255, g + lightenAmount);
            const newB = Math.min(255, b + lightenAmount);

            return `rgb(${newR}, ${newG}, ${newB})`;
        } else {
            // Fallback for other color formats
            return lightenAmount > 100 ? 'rgba(255, 255, 200, 0.9)' : 'rgba(255, 200, 100, 0.8)';
        }
    }

    // Function to draw a cluster of glowing dots
    function drawGlowCluster(clusterCenterX, clusterCenterY, glowColor, dotSizeRange = [1, 3]) {
        // Each cluster has 3-7 dots
        const numDots = 6 + Math.floor(Math.random() * 10);
        const clusterRadius = hexSide / 8; // Tight cluster

        for (let i = 0; i < numDots; i++) {
            // Random position within cluster radius
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * clusterRadius;

            const dotX = clusterCenterX + Math.cos(angle) * distance;
            const dotY = clusterCenterY + Math.sin(angle) * distance;

            // Only draw if dot is within hex
            if (isPointInHex(dotX, dotY, centerX, centerY, hexSide)) {
                // Vary dot size within specified range
                const dotSize = dotSizeRange[0] + Math.random() * (dotSizeRange[1] - dotSizeRange[0]);

                offscreenContext.fillStyle = glowColor;
                offscreenContext.beginPath();
                offscreenContext.arc(dotX, dotY, dotSize, 0, Math.PI * 2);
                offscreenContext.fill();
            }
        }
    }

    // Main function to add lava texture
    function addLavaTexture() {
        const glowColor = createGlowColor(map.palette.lava, 80);
        const brightGlowColor = createGlowColor(map.palette.lava, 180);

        // Create 2-3 clusters
        const numClusters = 2 + Math.floor(Math.random() * 4);
        const hexWidth = hexSide * Math.sqrt(3) / 2;

        for (let i = 0; i < numClusters; i++) {
            // Random cluster center position within hex
            let clusterCenterX, clusterCenterY;

            // Use polar coordinates for better distribution
            const angle = Math.random() * Math.PI * 2;
            const maxDistance = Math.min(hexSide * 0.6, hexWidth * 0.6);
            const distance = Math.random() * maxDistance;

            clusterCenterX = centerX + Math.cos(angle) * distance;
            clusterCenterY = centerY + Math.sin(angle) * distance;

            // Fallback to random positioning if needed
            if (!isPointInHex(clusterCenterX, clusterCenterY, centerX, centerY, hexSide)) {
                do {
                    clusterCenterX = centerX + (Math.random() - 0.5) * hexWidth * 1.2;
                    clusterCenterY = centerY + (Math.random() - 0.5) * hexSide * 1.2;
                } while (!isPointInHex(clusterCenterX, clusterCenterY, centerX, centerY, hexSide));
            }

            // Draw first set of medium glow dots
            drawGlowCluster(clusterCenterX, clusterCenterY, glowColor, [1, 3]);

            // Draw second set of smaller, much brighter dots
            drawGlowCluster(clusterCenterX, clusterCenterY, brightGlowColor, [0.5, 1.5]);
        }
    }


///////////////////////////////////////////



    function getControlPoints(x1, y1, x2, y2) {
        // Calculate the direct line vector
        const dx = x2 - x1;
        const dy = y2 - y1;

        // Calculate perpendicular vector (for offsetting to sides)
        const length = Math.sqrt(dx * dx + dy * dy);
        const perpX = -dy / length; // Perpendicular X (rotated 90 degrees)
        const perpY = dx / length;  // Perpendicular Y

        // Points at 1/3 and 2/3 along the line
        const point1X = x1 + dx * (1/3);
        const point1Y = y1 + dy * (1/3);

        const point2X = x1 + dx * (2/3);
        const point2Y = y1 + dy * (2/3);

        // Random offsets 5-15px to either side
        const offset1 = (3 + Math.random() * 5) * (Math.random() < 0.5 ? -1 : 1);
        const offset2 = (3 + Math.random() * 5) * (Math.random() < 0.5 ? -1 : 1);

        // Apply offsets perpendicular to the line
        const control1 = {
            x: point1X + perpX * offset1,
            y: point1Y + perpY * offset1
        };

        const control2 = {
            x: point2X + perpX * offset2,
            y: point2Y + perpY * offset2
        };

        return { control1, control2 };
    }

    // function generateWavyLine(x1, y1, x2, y2) {
    //     // Calculate the direct distance and angle
    //     const dx = x2 - x1;
    //     const dy = y2 - y1;
    //     const distance = Math.sqrt(dx * dx + dy * dy);
    //     const angle = Math.atan2(dy, dx);
    //
    //     // Create perpendicular direction for waves
    //     const perpAngle = angle + Math.PI / 2;
    //     const perpX = Math.cos(perpAngle);
    //     const perpY = Math.sin(perpAngle);
    //
    //     // Control how much the line deviates (10-20px as requested)
    //     const waveAmplitude = 10 + Math.random() * 10; // 10-20px
    //     const waveFrequency = 0.8 + Math.random() * 0.4; // Vary the waviness
    //
    //     // Generate points along the path
    //     const numPoints = Math.max(4, Math.floor(distance / 15)); // Point every ~15px
    //     const points = [];
    //
    //     for (let i = 0; i <= numPoints; i++) {
    //         const t = i / numPoints;
    //
    //         // Base position along the straight line
    //         const baseX = x1 + dx * t;
    //         const baseY = y1 + dy * t;
    //
    //         // Add wave displacement with gentle tapering only at the very ends
    //         let waveIntensity = 1.0;
    //         if (t < 0.1) {
    //             waveIntensity = t / 0.1; // Fade in over first 10%
    //         } else if (t > 0.9) {
    //             waveIntensity = (1.0 - t) / 0.1; // Fade out over last 10%
    //         }
    //
    //         const waveOffset = Math.sin(t * Math.PI * 2 * waveFrequency) * waveAmplitude * waveIntensity;
    //
    //         // Add some randomness to make it more organic
    //         const randomOffset = (Math.random() - 0.5) * 8 * waveIntensity;
    //         const totalOffset = waveOffset + randomOffset;
    //
    //         points.push({
    //             x: baseX + perpX * totalOffset,
    //             y: baseY + perpY * totalOffset
    //         });
    //     }
    //
    //     return points;
    // }
    // // Function to draw the wavy line using canvas
    // function drawWavyLine(ctx, x1, y1, x2, y2) {
    //     const points = generateWavyLine(x1, y1, x2, y2);
    //
    //     if (points.length < 2) return;
    //
    //     ctx.beginPath();
    //     ctx.moveTo(points[0].x, points[0].y);
    //
    //     // Use quadratic curves for smooth connection between points
    //     for (let i = 1; i < points.length - 1; i++) {
    //         const currentPoint = points[i];
    //         const nextPoint = points[i + 1];
    //
    //         // Control point is the current point
    //         const controlX = currentPoint.x;
    //         const controlY = currentPoint.y;
    //
    //         // End point is halfway to next point
    //         const endX = (currentPoint.x + nextPoint.x) / 2;
    //         const endY = (currentPoint.y + nextPoint.y) / 2;
    //
    //         ctx.quadraticCurveTo(controlX, controlY, endX, endY);
    //     }
    //
    //     // Draw final segment to last point
    //     const lastPoint = points[points.length - 1];
    //     ctx.lineTo(lastPoint.x, lastPoint.y);
    //
    //     ctx.stroke();
    // }


    function findMegahexCoordinates(lines) {
        // Regex for megahex variants (case insensitive, optional 's', optional space)
        const megahexPattern = /mega\s?hexe?s?/i;

        // Regex for first pair of numbers separated by comma
        const coordPattern = /(-?\d+)\s*,\s*(-?\d+)/;

        for (const line of lines) {
            if (megahexPattern.test(line)) {
                const match = line.match(coordPattern);
                if (match) {
                    return [parseInt(match[1]), parseInt(match[2])];
                }
            }
        }

        return null; // No megahex line found or no coordinates found
    }


      function findLineStyle(lines) {
      // Regex to match line style declarations (case insensitive, flexible punctuation)
//      const lineStylePattern = /line\s*style\s*[:=]\s*(.+)/i;

          const lineStylePattern = /line[\s-]*style\s*[:=\-]?\s*(\S+)/i

      // Style mapping - converts various inputs to standard outputs
      const styleMap = {
          'handdrawn': 'handDrawn',
          'hand-drawn': 'handDrawn',
          'hand drawn': 'handDrawn',
          'uneven': 'handDrawn',
          'cornersonly': 'cornersOnly',
          'corners-only': 'cornersOnly',
          'corners only': 'cornersOnly',
          'only corners': 'cornersOnly',
          'normal': 'normal',
          'regular': 'normal'
      };

      for (const line of lines) {
          const match = line.match(lineStylePattern);
          if (match) {
              let styleValue = match[1]
                  .replace(/['"]/g, '')
                  .trim()
                  .toLowerCase()
                  .replace(/[-\s]+/g, ''); // Remove all spaces and hyphens

              // Now match against normalized keys
              if (styleValue.includes('hand') || styleValue.includes('uneven')) {
                  return 'handDrawn';
              } else if (styleValue.includes('corner')) {
                  return 'cornersOnly';
              } else if (styleValue.includes('normal') || styleValue.includes('regular')) {
                  return 'normal';
              }
          }
      }

      return 'normal'; // Default if nothing found
    }


    function centerOf( x, y ) {

        if ( x%2 == 0 ) {

          centerX =  3 * ( x / 2 ) * hexSide  + hexSide * 3 / 2;
            centerY = (y+1) * hexHeight + hexHeight / 2;

        } else {

          centerX =  3 * ( x / 2 ) * hexSide  + hexSide * 3 / 2;
            centerY = y * hexHeight + hexHeight;

        }

        return { x: centerX, y: centerY };
    }


    function getHexFromCanvasPoint(canvasX, canvasY) {
        // Step 1: Reverse the coordinate transformation to get approximate grid position

        // Reverse the X calculation: x = 2 * ((centerX - hexSide * 3/2) / (3 * hexSide))
        let approxX = Math.round(2 * (canvasX - hexSide * 3/2) / (3 * hexSide));

        // Reverse the Y calculation (depends on whether column is even or odd)
        let approxY;
        if (approxX % 2 == 0) {
            // Even column: centerY = (y+1) * hexHeight + hexHeight / 2
            // So: y = (centerY - hexHeight / 2) / hexHeight - 1
            approxY = Math.round((canvasY - hexHeight / 2) / hexHeight - 1);
        } else {
            // Odd column: centerY = y * hexHeight + hexHeight
            // So: y = (centerY - hexHeight) / hexHeight
            approxY = Math.round((canvasY - hexHeight) / hexHeight);
        }

        // Step 2: Check the 9 surrounding hexes (3x3 grid centered on our approximation)
        let candidates = [];
        for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
                let testX = approxX + dx;
                let testY = approxY + dy;

                // Only add valid hexes (you might have bounds checking)
                if (inBounds(testX, testY)) {  // Replace with your bounds check
                    candidates.push({x: testX, y: testY});
                }
            }
        }

        // Step 3: Find the closest hex among candidates
        let closestHex = null;
        let minDistance = Infinity;

        for (let candidate of candidates) {
            let center = centerOf(candidate.x, candidate.y);
            let distance = Math.sqrt(
                (canvasX - center.x) ** 2 +
                (canvasY - center.y) ** 2
            );

            if (distance < minDistance) {
                minDistance = distance;
                closestHex = candidate;
            }
        }

        return closestHex;
    }


//     function hexGridOf(canvasX, canvasY) {
//         // Calculate the column (x) first
//         const x = Math.floor((canvasX - hexSide * 3 / 2) / (3 * hexSide / 2));
//
//         let y;
//         if (x % 2 == 0) {
//             // Even columns
//             y = Math.floor((canvasY - hexHeight / 2) / hexHeight) - 1;
//         } else {
//             // Odd columns
//             y = Math.floor((canvasY - hexHeight) / hexHeight);
//         }
//
//         return { x: x, y: y };
//     }
//
//     function hexGridOf2( canvasX, canvasY ) {
//
// //      x = Math.floor( ( 2 * canvasX / 3 * hexSide ) - 1 );
//       x = Math.floor( (canvasX / hexSide - 1.5) / 3 );
//
//       y=-1;
//
//       return { x: x, y: y };
//
//     }


    function textChange() {

//      console.log('textChange()')

      undoStack.push(textDisplayArea.value);

      if (undoStack.length > 100) {
        undoStack.shift(); // remove oldest entry
      }


      convertTextToObject();

      objectToOffscreen();

      offscreenToMiniMap();

      offscreenToDisplay();

      global.changed = 'yes';


    }

    function undo() {
        if (undoStack.length > 1) {
            // Remove current state
            undoStack.pop();
            // Get previous state and apply it
            textDisplayArea.value = undoStack[undoStack.length - 1];
        }
    }

    function inBounds( x, y ) {

      if ( x < 0 || y < 0 ) return false;
      if ( x >= map.width || y >= map.height ) return false;

      return true;

    }

    function hexVertex( x, y, v ) {

      let center = centerOf( x, y );

      v = Math.abs( v ) % 6;

      switch (v) {

        case 0:
          return { x: center.x - hexSide / 2,
            y: center.y - hexHeight / 2 };
          break;

        case 1:
          return { x: center.x + hexSide / 2,
            y: center.y - hexHeight / 2 };
          break;

        case 2:
          return { x: center.x + hexSide,
            y: center.y };
          break;

        case 3:
          return { x: center.x + hexSide / 2,
          y: center.y + hexHeight / 2 };
          break;

        case 4:
          return { x: center.x - hexSide / 2,
          y: center.y + hexHeight / 2 };
          break;

        case 5:
          return { x: center.x - hexSide,
          y: center.y };
          break;

      }

    }

    // function drawOffboard() {
    //
    //   for ( let dir = 0; dir < 6; dir++ ) {
    //
    //     adjHex = hexAdjacent( xI, yI, dir );
    //     if ( !inBounds( adjHex.x, adjHex.y ) ) continue;
    //     if ( map.grid[adjHex.x][adjHex.y].includes('offboard') ) continue;
    //
    //     console.log(xI, yI,dir)
    //
    //     drawHexSide( xI, yI, dir );
    //
    //   }
    //
    // }


    // function drawHexSide(x, y, sideIndex ) {
    //     // Get the two vertices of the side
    //     canvasCenter = centerOf( x, y );
    //     const vertex1 = hexVertex(x, y, sideIndex);  // Fixed: use x, y instead of canvasCenter
    //     const vertex2 = hexVertex(x, y, (sideIndex + 1) % 6);  // Fixed: use x, y instead of canvasCenter
    //
    //     // Calculate the inward offset distance
    //     const inwardOffset = 3;
    //
    //     // Calculate the vector from center to midpoint of the side
    //     const midX = (vertex1.x + vertex2.x) / 2;
    //     const midY = (vertex1.y + vertex2.y) / 2;
    //     const centerToMidX = midX - canvasCenter.x;
    //     const centerToMidY = midY - canvasCenter.y;
    //
    //     // Normalize this vector
    //     const length = Math.sqrt(centerToMidX * centerToMidX + centerToMidY * centerToMidY);
    //     const normalX = centerToMidX / length;
    //     const normalY = centerToMidY / length;
    //
    //     // Move both vertices inward by the offset amount
    //     const insetVertex1 = {
    //         x: vertex1.x - normalX * inwardOffset,
    //         y: vertex1.y - normalY * inwardOffset
    //     };
    //     const insetVertex2 = {
    //         x: vertex2.x - normalX * inwardOffset,
    //         y: vertex2.y - normalY * inwardOffset
    //     };
    //
    //     // Calculate extension to close gaps
    //     const extension = 0;
    //     const lineVectorX = insetVertex2.x - insetVertex1.x;
    //     const lineVectorY = insetVertex2.y - insetVertex1.y;
    //     const lineLength = Math.sqrt(lineVectorX * lineVectorX + lineVectorY * lineVectorY);
    //     const extendX = (lineVectorX / lineLength) * extension;
    //     const extendY = (lineVectorY / lineLength) * extension;
    //
    //     // Extend both ends of the line
    //     const extendedVertex1 = {
    //         x: insetVertex1.x - extendX,
    //         y: insetVertex1.y - extendY
    //     };
    //     const extendedVertex2 = {
    //         x: insetVertex2.x + extendX,
    //         y: insetVertex2.y + extendY
    //     };
    //
    //     // Draw the thick line
    //     let originalLineWidth = offscreenContext.lineWidth;
    //     let originalStrokeStyle = offscreenContext.strokeStyle;
    //     offscreenContext.lineCap = 'round';
    //
    //     offscreenContext.lineWidth = 6;
    //     offscreenContext.strokeStyle = map.palette.lines;
    //     offscreenContext.beginPath();
    //     offscreenContext.moveTo(extendedVertex1.x, extendedVertex1.y);
    //     offscreenContext.lineTo(extendedVertex2.x, extendedVertex2.y);
    //     offscreenContext.stroke();
    //     offscreenContext.lineWidth = originalLineWidth;
    //     offscreenContext.strokeStyle = originalStrokeStyle;
    // }
    //

    // this one works perfectly, but we're going to attempt to add hatching...
    // function drawOutsideBorder(x, y, sideIndex) {
    //     const canvasCenter = centerOf(x, y);
    //     const vertex1 = hexVertex(x, y, sideIndex);
    //     const vertex2 = hexVertex(x, y, (sideIndex + 1) % 6);
    //
    //     // Calculate the outward offset distance
    //     const outwardOffset = 3;  // 3 pixels outward from the hex edge
    //
    //     // Calculate the vector from center to midpoint of the side
    //     const midX = (vertex1.x + vertex2.x) / 2;
    //     const midY = (vertex1.y + vertex2.y) / 2;
    //     const centerToMidX = midX - canvasCenter.x;
    //     const centerToMidY = midY - canvasCenter.y;
    //
    //     // Normalize this vector
    //     const length = Math.sqrt(centerToMidX * centerToMidX + centerToMidY * centerToMidY);
    //     const normalX = centerToMidX / length;
    //     const normalY = centerToMidY / length;
    //
    //     // Move both vertices OUTWARD by the offset amount
    //     const outsetVertex1 = {
    //         x: vertex1.x + normalX * outwardOffset,
    //         y: vertex1.y + normalY * outwardOffset
    //     };
    //     const outsetVertex2 = {
    //         x: vertex2.x + normalX * outwardOffset,
    //         y: vertex2.y + normalY * outwardOffset
    //     };
    //
    //     // Store original line settings
    //     const originalLineWidth = offscreenContext.lineWidth;
    //     const originalLineCap = offscreenContext.lineCap;
    //
    //     // Set line properties
    //     offscreenContext.lineWidth = 6;
    //     offscreenContext.lineCap = 'round';
    //
    //     // Draw the line
    //     offscreenContext.beginPath();
    //     offscreenContext.moveTo(outsetVertex1.x, outsetVertex1.y);
    //     offscreenContext.lineTo(outsetVertex2.x, outsetVertex2.y);
    //     offscreenContext.stroke();
    //
    //     // Restore original line settings
    //     offscreenContext.lineWidth = originalLineWidth;
    //     offscreenContext.lineCap = originalLineCap;
    // }

      function drawOutsideBorder(x, y, sideIndex) {
        const canvasCenter = centerOf(x, y);
        const vertex1 = hexVertex(x, y, sideIndex);
        const vertex2 = hexVertex(x, y, (sideIndex + 1) % 6);

        // Calculate the outward offset distance
        const outwardOffset = 3;

        // Calculate the vector from center to midpoint of the side
        const midX = (vertex1.x + vertex2.x) / 2;
        const midY = (vertex1.y + vertex2.y) / 2;
        const centerToMidX = midX - canvasCenter.x;
        const centerToMidY = midY - canvasCenter.y;

        // Normalize this vector
        const length = Math.sqrt(centerToMidX * centerToMidX + centerToMidY * centerToMidY);
        const normalX = centerToMidX / length;
        const normalY = centerToMidY / length;

        // Move both vertices OUTWARD by the offset amount
        const outsetVertex1 = {
            x: vertex1.x + normalX * outwardOffset,
            y: vertex1.y + normalY * outwardOffset
        };
        const outsetVertex2 = {
            x: vertex2.x + normalX * outwardOffset,
            y: vertex2.y + normalY * outwardOffset
        };

        // Store original line settings
        const originalLineWidth = offscreenContext.lineWidth;
        const originalLineCap = offscreenContext.lineCap;

        // Set line properties
        offscreenContext.lineWidth = 6;
        offscreenContext.lineCap = 'round';

        offscreenContext.strokeStyle = map.palette.lines;

        // Draw the main border line
        offscreenContext.beginPath();
        offscreenContext.moveTo(outsetVertex1.x, outsetVertex1.y);
        offscreenContext.lineTo(outsetVertex2.x, outsetVertex2.y);
        offscreenContext.stroke();

        // Restore original line settings
        offscreenContext.lineWidth = originalLineWidth;
        offscreenContext.lineCap = originalLineCap;
      }


      function drawCrumbs(x, y, sideIndex) {
          const canvasCenter = centerOf(x, y);
          const vertex1 = hexVertex(x, y, sideIndex);
          const vertex2 = hexVertex(x, y, (sideIndex + 1) % 6);

          // Calculate the outward offset distance
          const outwardOffset = 3;

          // Calculate the vector from center to midpoint of the side
          const midX = (vertex1.x + vertex2.x) / 2;
          const midY = (vertex1.y + vertex2.y) / 2;
          const centerToMidX = midX - canvasCenter.x;
          const centerToMidY = midY - canvasCenter.y;

          // Normalize this vector
          const length = Math.sqrt(centerToMidX * centerToMidX + centerToMidY * centerToMidY);
          const normalX = centerToMidX / length;
          const normalY = centerToMidY / length;

          // Generate random number of crumbs (2-10)
          const numCrumbs = Math.floor(Math.random() * 9) + 2;

          // Set fill color for crumbs
          offscreenContext.fillStyle = map.palette.walls;

          // Draw crumbs scattered near the wall inside the hex
          for (let i = 0; i < numCrumbs; i++) {
              // Random position along the line (0 to 1)
              const t = Math.random();
              const baseX = vertex1.x + (vertex2.x - vertex1.x) * t;
              const baseY = vertex1.y + (vertex2.y - vertex1.y) * t;

              // Each crumb gets its own random distance from the wall
              const inwardOffset = Math.random() < 0.7 ?
                  Math.random() * 4 + 1 :  // 70% chance: 1-5 pixels inward (close to wall)
                  Math.random() * 12 + 5;  // 30% chance: 5-17 pixels inward (further from wall)

              // Move this crumb inward by its individual offset
              const crumbBaseX = baseX - normalX * inwardOffset;
              const crumbBaseY = baseY - normalY * inwardOffset;

              // Add some random scatter perpendicular to the wall
              const scatterDistance = Math.random() * 6 - 3; // -3 to +3 pixels
              const perpX = -normalY; // Perpendicular to normal vector
              const perpY = normalX;

              const crumbX = crumbBaseX + perpX * scatterDistance;
              const crumbY = crumbBaseY + perpY * scatterDistance;

              // Small crumb size (2-4 px instead of 2-6)
              const crumbSize = Math.floor(Math.random() * 3) + 2;

              // Save context for rotation
              offscreenContext.save();

              // Translate to crumb center and rotate by random angle
              offscreenContext.translate(crumbX, crumbY);
              offscreenContext.rotate(Math.random() * Math.PI * 2);

              // For larger crumbs (4px), draw two overlapping squares to break up the square shape
              if (crumbSize >= 4) {
                  // First square
                  const width1 = crumbSize + Math.random() * 2 - 1;
                  const height1 = crumbSize + Math.random() * 2 - 1;
                  offscreenContext.fillRect(
                      -width1 / 2,
                      -height1 / 2,
                      width1,
                      height1
                  );

                  // Second square, slightly offset and rotated
                  offscreenContext.rotate(Math.random() * Math.PI / 3 - Math.PI / 6); // -30 to +30 degrees
                  const offsetX = (Math.random() - 0.5) * 2; // -1 to +1 pixel offset
                  const offsetY = (Math.random() - 0.5) * 2;
                  const width2 = crumbSize * 0.7 + Math.random() * 1.5 - 0.75;
                  const height2 = crumbSize * 0.7 + Math.random() * 1.5 - 0.75;

                  offscreenContext.fillRect(
                      offsetX - width2 / 2,
                      offsetY - height2 / 2,
                      width2,
                      height2
                  );
              } else {
                  // For smaller crumbs, just draw single irregular rectangle
                  const width = crumbSize + Math.random() * 2 - 1;
                  const height = crumbSize + Math.random() * 2 - 1;

                  offscreenContext.fillRect(
                      -width / 2,
                      -height / 2,
                      width,
                      height
                  );
              }

              // Restore context
              offscreenContext.restore();
          }
      }

      function drawTrapDoor() {

        ctx = offscreenContext;

        const doorSize = hexSide; // Square size relative to hex
        const halfDoor = doorSize / 2;

        // Colors
        const doorColor = '#A0672A'; // Dark brown
        const hingeColor = '#2F1B1A'; // Darker brown for hinges
        const shadowColor = '#1A0F0E'; // Very dark brown for shadows

        ctx.save();

        // Draw door shadow/outline first
        ctx.fillStyle = shadowColor;
        ctx.fillRect(
          centerX - halfDoor - 1,
          centerY - halfDoor - 1,
          doorSize + 2,
          doorSize + 2
        );

        // Draw main door square
        ctx.fillStyle = doorColor;
        ctx.fillRect(
          centerX - halfDoor,
          centerY - halfDoor,
          doorSize,
          doorSize
        );

        // Add wood grain effect with subtle lines
        ctx.strokeStyle = '#2F1B1A';
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.5;

        // Horizontal wood grain lines
        for (let i = 0; i < 4; i++) {
          const y = centerY - halfDoor + (doorSize / 5) * (i + 1);
          ctx.beginPath();
          ctx.moveTo(centerX - halfDoor + 5, y);
          ctx.lineTo(centerX + halfDoor - 5, y);
          ctx.stroke();
        }

        ctx.globalAlpha = 1;

        // Draw hinges on the left side
        const hingeWidth = 8;
        const hingeHeight = doorSize * 0.15;
        const hingeOffset = doorSize * 0.2;

        ctx.fillStyle = hingeColor;

        // Top hinge
        ctx.fillRect(
          centerX - halfDoor - hingeWidth/2,
          centerY - halfDoor + hingeOffset,
          hingeWidth,
          hingeHeight
        );

        // Bottom hinge
        ctx.fillRect(
          centerX - halfDoor - hingeWidth/2,
          centerY + halfDoor - hingeOffset - hingeHeight,
          hingeWidth,
          hingeHeight
        );

        // Add hinge details (screws/bolts)
        ctx.fillStyle = '#1A1A1A';
        const screwSize = 1.5;

        // Top hinge screws
        ctx.beginPath();
        ctx.arc(centerX - halfDoor - 2, centerY - halfDoor + hingeOffset + hingeHeight/3, screwSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(centerX - halfDoor - 2, centerY - halfDoor + hingeOffset + 2*hingeHeight/3, screwSize, 0, Math.PI * 2);
        ctx.fill();

        // Bottom hinge screws
        ctx.beginPath();
        ctx.arc(centerX - halfDoor - 2, centerY + halfDoor - hingeOffset - hingeHeight/3, screwSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(centerX - halfDoor - 2, centerY + halfDoor - hingeOffset - 2*hingeHeight/3, screwSize, 0, Math.PI * 2);
        ctx.fill();

        // Add a handle/ring on the right side
        const handleX = centerX + halfDoor - 10;
        const handleY = centerY;

        ctx.strokeStyle = '#2F1B1A';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(handleX, handleY, 4, 0, Math.PI * 2);
        ctx.stroke();

        // Inner ring
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(handleX, handleY, 2, 0, Math.PI * 2);
        ctx.stroke();

        ctx.restore();

      }


      function drawStoneAltar() {
        // Randomly choose rotation: 0°, 60°, or -60°
        const rotations = [0, Math.PI / 3, -Math.PI / 3]; // 0°, 60°, -60° in radians
        const rotation = rotations[Math.floor(Math.random() * rotations.length)];

        offscreenContext.save();

        // Move to center and rotate
        offscreenContext.translate(centerX, centerY);
        offscreenContext.rotate(rotation);

        // Rectangle dimensions - width based on hexSide, height 80% of width
        const width = hexSide * 1.2;
        const height = width * 0.8;

        // Draw concentric rectangles from outside to inside
        const layers = [
          { size: 1.0, fill: '#707070', stroke: '#505050' },   // Outermost - darkest
          { size: 0.8, fill: '#808080', stroke: '#606060' },   // Middle
          { size: 0.6, fill: '#909090', stroke: '#707070' },   // Inner - lightest
          // { size: 0.4, fill: '#858585', stroke: '#656565' }    // Innermost - medium
        ];

        layers.forEach(layer => {
          const layerWidth = width * layer.size;
          const layerHeight = height * layer.size;

          offscreenContext.beginPath();
          offscreenContext.fillStyle = layer.fill;
          offscreenContext.strokeStyle = layer.stroke;
          offscreenContext.lineWidth = 1.5;

          // Draw rectangle centered at origin
          offscreenContext.rect(
            -layerWidth / 2,
            -layerHeight / 2,
            layerWidth,
            layerHeight
          );

          offscreenContext.fill();
          offscreenContext.stroke();
        });

        offscreenContext.restore();
      }


      function drawPentacle() {
          const ctx = offscreenContext;
          const radius = hexSide * 0.9 / 2; // diameter to radius conversion
          const starRadius = radius * 0.8; // Star fits within the circle
          const innerRadius = starRadius * 0.382; // Golden ratio for pentacle proportions

          ctx.save();

          // Draw outer circle (subtle)
          ctx.strokeStyle = '#444';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.stroke();

          // Calculate pentacle points
          const outerPoints = [];
          const innerPoints = [];

          for (let i = 0; i < 5; i++) {
              const angle = (i * 2 * Math.PI / 5) + (Math.PI / 2); // Start at bottom (flipped)

              // Outer points (star tips)
              outerPoints.push({
                  x: centerX + Math.cos(angle) * starRadius,
                  y: centerY + Math.sin(angle) * starRadius
              });

              // Inner points (star indentations)
              const innerAngle = angle + (Math.PI / 5);
              innerPoints.push({
                  x: centerX + Math.cos(innerAngle) * innerRadius,
                  y: centerY + Math.sin(innerAngle) * innerRadius
              });
          }

          // Draw the pentacle star
          ctx.strokeStyle = '#222';
          ctx.fillStyle = '#333';
          ctx.lineWidth = 2;
          ctx.lineJoin = 'round';

          ctx.beginPath();

          // Start at first outer point
          ctx.moveTo(outerPoints[0].x, outerPoints[0].y);

          // Draw the star by alternating between outer and inner points
          for (let i = 0; i < 5; i++) {
              const nextOuter = (i + 1) % 5;
              ctx.lineTo(innerPoints[i].x, innerPoints[i].y);
              ctx.lineTo(outerPoints[nextOuter].x, outerPoints[nextOuter].y);
          }

          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          // Draw simple mystical marks around the circle
          const markRadius = radius * 0.85;

          ctx.strokeStyle = '#666';
          ctx.lineWidth = 1.5;
          ctx.lineCap = 'round';

          for (let i = 0; i < 6; i++) {
              const angle = (i * Math.PI / 3); // 6 positions around the circle
              const markX = centerX + Math.cos(angle) * markRadius;
              const markY = centerY + Math.sin(angle) * markRadius;

              // Draw small cross marks
              const markSize = radius * 0.08;

              ctx.beginPath();
              ctx.moveTo(markX - markSize, markY);
              ctx.lineTo(markX + markSize, markY);
              ctx.moveTo(markX, markY - markSize);
              ctx.lineTo(markX, markY + markSize);
              ctx.stroke();
          }

          // Draw additional runic-style marks
          ctx.strokeStyle = '#555';
          ctx.lineWidth = 1;

          for (let i = 0; i < 12; i++) {
              const angle = (i * Math.PI / 6); // 12 positions
              const markRadius = radius * 0.95;
              const markLength = radius * 0.05;

              const startX = centerX + Math.cos(angle) * (markRadius - markLength);
              const startY = centerY + Math.sin(angle) * (markRadius - markLength);
              const endX = centerX + Math.cos(angle) * markRadius;
              const endY = centerY + Math.sin(angle) * markRadius;

              ctx.beginPath();
              ctx.moveTo(startX, startY);
              ctx.lineTo(endX, endY);
              ctx.stroke();

              // Add small perpendicular marks for runic effect
              if (i % 3 === 0) {
                  const perpAngle = angle + Math.PI / 2;
                  const perpLength = markLength * 0.3;
                  const perpX1 = endX + Math.cos(perpAngle) * perpLength;
                  const perpY1 = endY + Math.sin(perpAngle) * perpLength;
                  const perpX2 = endX - Math.cos(perpAngle) * perpLength;
                  const perpY2 = endY - Math.sin(perpAngle) * perpLength;

                  ctx.beginPath();
                  ctx.moveTo(perpX1, perpY1);
                  ctx.lineTo(perpX2, perpY2);
                  ctx.stroke();
              }
          }

          // Draw inner circle for mystical effect
          ctx.strokeStyle = '#444';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(centerX, centerY, innerRadius * 1.2, 0, Math.PI * 2);
          ctx.stroke();

          ctx.restore();
      }



      function drawDiagonalLines() {
        offscreenContext.save();

        // Set up clipping path for the hex (with 2-3px inset)
        const inset = 2 + Math.random(); // 2-3 pixels inset
        const clippingRadius = hexSide - inset;

        offscreenContext.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = (i * Math.PI) / 3;
          const x = centerX + clippingRadius * Math.cos(angle);
          const y = centerY + clippingRadius * Math.sin(angle);

          if (i === 0) {
            offscreenContext.moveTo(x, y);
          } else {
            offscreenContext.lineTo(x, y);
          }
        }
        offscreenContext.closePath();
        offscreenContext.clip();

        // Set line style
        offscreenContext.lineWidth = 1;

        // Calculate bounds for diagonal lines
        const maxDistance = hexSide + hexHeight; // Ensure we cover the whole hex area

        // Draw 45° diagonal lines (top-left to bottom-right)
        offscreenContext.beginPath();

        // Start from far left and work right, spacing lines 4px apart
        for (let offset = -maxDistance; offset <= maxDistance; offset += 4) {
          // Calculate start and end points for each diagonal line
          const startX = centerX - maxDistance;
          const startY = centerY - maxDistance + offset;
          const endX = centerX + maxDistance;
          const endY = centerY + maxDistance + offset;

          offscreenContext.moveTo(startX, startY);
          offscreenContext.lineTo(endX, endY);
        }

        offscreenContext.stroke();

        offscreenContext.restore();
      }


      function drawBarricade() {
        offscreenContext.save();
        offscreenContext.translate(centerX, centerY);

        // Define color palette for debris
        const colors = [
          '#8B7355', '#A0826D', '#6B5B47', // Browns (wood, dirt)
          '#808080', '#696969', '#A9A9A9', '#778899', // Greys (stone, metal)
          '#654321', '#8B4513', '#D2B48C' // More browns (dark wood, tan)
        ];

        // First draw some long thin pieces (planks, beams, etc.)
        const numLongPieces = 23 + Math.floor(Math.random() * 4); // 3-6 long pieces

        for (let i = 0; i < numLongPieces; i++) {
          // Random position within hex bounds
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * hexSide * 0.6;
          const x = Math.cos(angle) * distance;
          const y = Math.sin(angle) * distance;

          // Long thin dimensions
          const length = hexSide * (0.8 + Math.random() * 0.4); // 80-120% of hexSide
          const width = length * (0.05 + Math.random() * 0.05); // 5-10% of length

          // Random color from palette
          const color = colors[Math.floor(Math.random() * colors.length)];

          offscreenContext.fillStyle = color;
          offscreenContext.strokeStyle = '#000000';
          offscreenContext.lineWidth = 0.5;

          offscreenContext.save();
          offscreenContext.translate(x, y);
          offscreenContext.rotate(Math.random() * Math.PI * 2); // Random direction

          offscreenContext.beginPath();
          offscreenContext.rect(-length/2, -width/2, length, width);
          offscreenContext.fill();
          offscreenContext.stroke();
          offscreenContext.restore();
        }

        // Fill the hex area with random debris pieces
        const numPieces = 15 + Math.floor(Math.random() * 10); // 15-24 pieces

        for (let i = 0; i < numPieces; i++) {
          // Random position within hex bounds
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * hexSide * 0.8;
          const x = Math.cos(angle) * distance;
          const y = Math.sin(angle) * distance;

          // Random size
          const size = 8 + Math.random() * 12; // 8-20 pixels

          // Random color from palette
          const color = colors[Math.floor(Math.random() * colors.length)];

          // Random shape type
          const shapeType = Math.floor(Math.random() * 4);

          offscreenContext.fillStyle = color;
          offscreenContext.strokeStyle = '#000000';
          offscreenContext.lineWidth = 0.5;

          offscreenContext.save();
          offscreenContext.translate(x, y);
          offscreenContext.rotate(Math.random() * Math.PI * 2);

          offscreenContext.beginPath();

          switch(shapeType) {
            case 0: // Rectangle (planks, boards)
              const rectWidth = size * (0.5 + Math.random() * 1.5);
              const rectHeight = size * (0.3 + Math.random() * 0.4);
              offscreenContext.rect(-rectWidth/2, -rectHeight/2, rectWidth, rectHeight);
              break;

            case 1: // Circle (barrels, stones)
              offscreenContext.arc(0, 0, size/2, 0, Math.PI * 2);
              break;

            case 2: // Triangle (broken wood, debris)
              offscreenContext.moveTo(0, -size/2);
              offscreenContext.lineTo(-size/2, size/2);
              offscreenContext.lineTo(size/2, size/2);
              offscreenContext.closePath();
              break;

            case 3: // Irregular polygon (rubble)
              const sides = 5 + Math.floor(Math.random() * 3); // 5-7 sides
              for (let j = 0; j < sides; j++) {
                const sideAngle = (j / sides) * Math.PI * 2;
                const radius = size/2 * (0.7 + Math.random() * 0.6); // Irregular
                const px = Math.cos(sideAngle) * radius;
                const py = Math.sin(sideAngle) * radius;
                if (j === 0) {
                  offscreenContext.moveTo(px, py);
                } else {
                  offscreenContext.lineTo(px, py);
                }
              }
              offscreenContext.closePath();
              break;
          }

          offscreenContext.fill();
          offscreenContext.stroke();
          offscreenContext.restore();
        }

        offscreenContext.restore();
      }



    function objectToOffscreen() {

      if ( map.width % 2 ) {
        boardWidth = Math.floor( map.width / 2 ) * ( hexWidth + hexSide ) + hexSide;
      } else {
        boardWidth = Math.floor( map.width / 2 ) * ( hexWidth + hexSide );
      }

      boardWidth += hexSide * 2;

      boardHeight = hexHeight * ( map.height + 1 ) + hexHeight/2;

      offscreenCanvas.width = boardWidth;
      offscreenCanvas.height = boardHeight;

      maxZoomLevel = Math.min( offscreenCanvas.width/2, offscreenCanvas.height/2 );

      offscreenContext.fillStyle = map.palette.offboard;
      offscreenContext.fillRect(0, 0, offscreenCanvas.width, offscreenCanvas.height);


      if ( map.graphic ) {

        const graphic = map.graphic.toLowerCase();
        if (graphic === 'melee' || graphic === 'wizard') {
          const logoId = `${graphic}Logo`;
          const logo = document.getElementById(logoId);
          const scale = graphic === 'melee' ? 2 : 3;
          const width = logo.naturalWidth / scale;
          const height = logo.naturalHeight / scale;

          // Draw top-left
          offscreenContext.drawImage(logo, 0, 0, width, height);

          // Draw bottom-right
          offscreenContext.drawImage(
            logo,
            offscreenCanvas.width - width,
            offscreenCanvas.height - height,
            width,
            height
          );
        } else if ( map.graphic.toLowerCase() == 'arcane' ) {

          drawArcaneSymbols();

        }
      }

      if ( megaHexOrigin ) {

        getMegaHexCenters( megaHexOrigin[0], megaHexOrigin[1] );

      } else {
        map.megaHexCenters =[];
      }


      for (  xI=0; xI < map.width; xI++ ) {

          for (  yI=0; yI < map.height; yI++ ) {

              if ( map.grid[xI][yI].includes('offboard') ) {
//                drawOffboard();
                continue;
              }

              for ( let dir = 0; dir < 6; dir++ ) {

                let adjHex = hexAdjacent( xI, yI, dir );

                if ( !inBounds( adjHex.x, adjHex.y ) || map.grid[adjHex.x][adjHex.y].includes('offboard') ) {

                  drawOutsideBorder( xI, yI, dir );

                }

              }

              traceHex(xI,yI);

              if ( map.grid[xI][yI].includes('wall hex') ) {

                offscreenContext.fillStyle = map.palette.clear;
                offscreenContext.fill();
                drawWall(centerI.x, centerI.y);



                continue;

              }

              if ( map.grid[xI][yI].includes('water') ) {

                // offscreenContext.fillStyle = map.palette.water;
                // offscreenContext.fill

                offscreenContext.fillStyle = map.palette.clear;
                offscreenContext.fill();

                drawWater( centerI.x, centerI.y);

              } else if ( map.grid[xI][yI].includes('tar') ) {

                  offscreenContext.fillStyle = map.palette.clear;
                  offscreenContext.fill();

                  drawTar( centerI.x, centerI.y );

                } else if ( map.grid[xI][yI].includes('lava') ) {

                  // offscreenContext.fillStyle = map.palette.lava;
                  // offscreenContext.fill();

                  offscreenContext.fillStyle = map.palette.clear;
                  offscreenContext.fill();

                  drawLava( centerI.x, centerI.y );

                } else {

                  if ( map.grid[xI][yI].includes('darker') ) {

                    offscreenContext.fillStyle = darkenColor(map.palette.clear, 0.1); // darken by 20%

                  } else if ( map.grid[xI][yI].includes('lighter') ) {

                    offscreenContext.fillStyle = lightenColor(map.palette.clear, 0.3); // darken by 20%

                  } else {

                    offscreenContext.fillStyle = map.palette.clear;

                  }

                offscreenContext.fill();

              }

              if ( map.lineStyle == 'normal' ) {

                offscreenContext.stroke();

              } else if ( map.lineStyle == 'handDrawn' ) {

                unevenLine( centerI.x - hexSide, centerI.y, centerI.x - hexSide / 2, centerI.y - hexHeight / 2 );
                unevenLine( centerI.x - hexSide / 2, centerI.y - hexHeight / 2, centerI.x + hexSide / 2, centerI.y - hexHeight / 2 );
                unevenLine( centerI.x + hexSide / 2, centerI.y - hexHeight / 2, centerI.x + hexSide, centerI.y );


              } else if ( map.lineStyle == 'cornersOnly' ) {

                drawHexCorners();

              }


              if ( map.grid[xI][yI].includes('column') ) {
                offscreenContext.fillStyle = map.palette.columns;
                offscreenContext.strokeStyle = map.palette.lines;
                offscreenContext.beginPath();
                offscreenContext.arc( centerI.x, centerI.y, hexSide*0.4, 0, 2 * Math.PI); // draw a circle
                offscreenContext.fill();
                offscreenContext.stroke();

              }

              if (map.grid[xI][yI].length == 0 && map.texture == 'yes' ) {
                  // Only place mushrooms in 10% of empty hexes
                  if (Math.random() < 0.1) {

//                      console.log(xI + ',' + yI);

                      // Random direction (0 to 360 degrees)
                      const angle = Math.random() * 2 * Math.PI;

                      // Random distance up to hexside/2 pixels
                      const distance = Math.random() * (hexSide / 2);

                      // Calculate offset position
                      const offsetX = Math.cos(angle) * distance;
                      const offsetY = Math.sin(angle) * distance;

                      // Draw mushrooms at the offset position
                      drawMushrooms(offscreenContext, centerI.x + offsetX, centerI.y + offsetY);

                  }
              }

              if ( map.grid[xI][yI].length == 0 && map.texture == 'yes' ) {

                for ( let direction = 0; direction < 6; direction++ ) {

                  if ( Math.random() > 0.3 ) continue;

                  let adjHex = hexAdjacent( xI, yI, direction );

                  if ( !inBounds( adjHex.x, adjHex.y ) || map.grid[adjHex.x][adjHex.y].includes('offboard') || map.grid[adjHex.x][adjHex.y].includes('wallhex') ) {

                    drawCrumbs( xI, yI, direction );

                  }

                }

              }

              // draw paths...

              if ( map.grid[xI][yI].includes('path') ) {

                drawPath();

              }



              // art drawing

              if ( map.grid[xI][yI].includes('trapdoor') ) {

                drawTrapDoor()

              }

              if ( map.grid[xI][yI].includes('pit') ) {

                drawDeepPit( centerI.x, centerI.y);

              }

              if ( map.grid[xI][yI].includes('debris') ) {

                drawDebris();

              }

              if ( map.grid[xI][yI].includes('fire') ) {

                offscreenContext.drawImage( document.getElementById('fire'), centerI.x-hexHeight * 0.5, centerI.y-hexHeight * 0.5, hexHeight, hexHeight ) ;

              }

              if ( map.grid[xI][yI].includes('shadow') ) {

                offscreenContext.drawImage( document.getElementById('shadow'), centerI.x-hexHeight * 0.45, centerI.y-hexHeight * 0.45, hexHeight * 0.9, hexHeight * 0.9 ) ;

              }

              if ( map.grid[xI][yI].includes('body') ) {

                let bodyString = 'body' + (Math.random() < 0.5 ? '1' : '2' );

                  // Replace your original line with this:
                  const img = document.getElementById(bodyString);
                  const targetSize = hexHeight * 0.8;
                  const targetX = centerI.x - hexHeight * 0.4;
                  const targetY = centerI.y - hexHeight * 0.4;

                  // Calculate scale factor to fit within target area while maintaining aspect ratio
                  const scaleX = targetSize / img.naturalWidth;
                  const scaleY = targetSize / img.naturalHeight;
                  const scale = Math.min(scaleX, scaleY); // Use smaller scale to fit within bounds

                  // Calculate actual draw dimensions
                  const drawWidth = img.naturalWidth * scale;
                  const drawHeight = img.naturalHeight * scale;

                  // Calculate centered position within the target area
                  const drawX = targetX + (targetSize - drawWidth) / 2;
                  const drawY = targetY + (targetSize - drawHeight) / 2;

                  // Draw the image
                  offscreenContext.drawImage(img, drawX, drawY, drawWidth, drawHeight);


              }

              if ( map.grid[xI][yI].includes('barricade') ) {

//                offscreenContext.drawImage( document.getElementById('table'), centerI.x-hexHeight * 0.35, centerI.y-hexHeight * 0.35, hexHeight * 0.7, hexHeight * 0.7 ) ;

                drawBarricade();

              }

              if ( map.grid[xI][yI].includes('table') ) {

                offscreenContext.drawImage( document.getElementById('table'), centerI.x-hexHeight * 0.35, centerI.y-hexHeight * 0.35, hexHeight * 0.7, hexHeight * 0.7 ) ;

              }

              if ( map.grid[xI][yI].includes('altar') ) {

                drawStoneAltar();

              }

              if ( map.grid[xI][yI].includes('pentacle') ) {

                drawPentacle();

              }

              if ( map.grid[xI][yI].includes('stone') ) {

                  drawStone(xI,yI,"#999999");

              }

              if ( map.grid[xI][yI].includes('tar') ) {

                drawTar();

              }

              if ( map.grid[xI][yI].includes('sticky') ) {

                offscreenContext.strokeStyle = '#FFA500';
                drawDiagonalLines();

              }

              if ( map.grid[xI][yI].includes('slippery') ) {

                offscreenContext.strokeStyle = '#AAAA00';
                drawDiagonalLines();

              }

              offscreenContext.strokeStyle = map.palette.lines;
              offscreenContext.fillStyle = map.palette.lines;


              if ( map.showDots == 'yes' ) {

                offscreenContext.beginPath();
                offscreenContext.arc( centerI.x, centerI.y, 2, 0, 2 * Math.PI);
                offscreenContext.fill();

              }

              if ( map.grid[xI][yI].includes('star') ) {

                offscreenContext.beginPath();
                for ( let i = 0; i < 10; i ++ ) {
                  const r=(i % 2 === 0) ? hexSide/15 : hexSide/30;
                  const angle = (i * Math.PI) / 5 + - Math.PI / 2;
                  const x = centerI.x + Math.cos(angle) * r;
                  const y = centerI.y + Math.sin(angle) * r;
                  if (i === 0) {
                      offscreenContext.moveTo(x, y);
                  } else {
                      offscreenContext.lineTo(x, y);
                  }
                }
                offscreenContext.closePath();
                offscreenContext.fill();
                offscreenContext.stroke();

              }


              if ( map.showHexNumbers == 'yes' ) {

                offscreenContext.fillText( xI + ',' + yI, centerI.x - 5, centerI.y + 40 );

              }

            } // yI loop (  yI=0; yI < map.height; yI++ )
          }  // xI loop

          for ( let i = 0; i < map.megaHexCenters.length; i++ ) {

            drawMegaHex( map.megaHexCenters[i].x, map.megaHexCenters[i].y );

          }

          if (map.stoneBridges && map.stoneBridges.length > 0) {
              map.stoneBridges.forEach(stoneBridge => {
                  const startCenter = centerOf(stoneBridge.startingX, stoneBridge.startingY);
                  const endCenter = centerOf(stoneBridge.endingX, stoneBridge.endingY);

//                  drawBridge(startCenter.x, startCenter.y, endCenter.x, endCenter.y, hexSide);
                  drawStoneBridge(startCenter.x, startCenter.y, endCenter.x, endCenter.y, hexSide*0.866);

//                  fillBridge( stoneBridge );
              });
          }

          if (map.woodBridges && map.woodBridges.length > 0) {
              map.woodBridges.forEach(woodBridge => {
                  const startCenter = centerOf(woodBridge.startingX, woodBridge.startingY);
                  const endCenter = centerOf(woodBridge.endingX, woodBridge.endingY);

//                  drawBridge(startCenter.x, startCenter.y, endCenter.x, endCenter.y, hexSide);
                  drawWoodBridge(startCenter.x, startCenter.y, endCenter.x, endCenter.y, hexSide*0.866);

//                  fillBridge( woodBridge );

              });
          }

          updateMiniMapSize();

    }   // end of  objectToOffscreen()


    function drawPath() {

      offscreenContext.fillStyle = map.palette.paths;
      offscreenContext.beginPath();
      offscreenContext.arc( centerI.x, centerI.y, hexSide*0.3, 0, 2 * Math.PI); // draw a circle
      offscreenContext.fill();

      const originalStrokeStyle = offscreenContext.strokeStyle;
      const originalLineWidth = offscreenContext.lineWidth;

      offscreenContext.strokeStyle = map.palette.paths;
      offscreenContext.lineWidth = hexSide*0.6;

      let pathExits = 0;
      let pathExitDir = -1;
      for ( let i = 0; i < 6; i++ ) {

        let adjHex = hexAdjacent( xI, yI, i );

        if ( adjHex.x < 0 || adjHex.y < 0 || adjHex.x > map.width - 1 || adjHex.y > map.height - 1 ) {
          continue;
        }

        if ( map.grid[adjHex.x][adjHex.y].includes('path') || map.grid[adjHex.x][adjHex.y].includes('bridge') ) {

          offscreenContext.beginPath();
          offscreenContext.moveTo( centerI.x, centerI.y );

          const directionRadians = (i * 60 - 90) * Math.PI / 180;
          const endX = centerI.x + Math.cos(directionRadians) * hexHeight/2;
          const endY = centerI.y + Math.sin(directionRadians) * hexHeight/2;

          offscreenContext.lineTo(endX, endY);
          offscreenContext.stroke();
          pathExits++;
          pathExitDir = i;
        }

      }

      if ( pathExits == 1 && ( xI == 0 || xI == map.width-1 || yI == 0 || yI == map.height-1 ) ) {

        let pathOff = ( pathExitDir + 3 ) % 6;

        offscreenContext.beginPath();
        offscreenContext.moveTo( centerI.x, centerI.y );

        const directionRadians = (pathOff * 60 - 90) * Math.PI / 180;
        const endX = centerI.x + Math.cos(directionRadians) * hexHeight/2;
        const endY = centerI.y + Math.sin(directionRadians) * hexHeight/2;

        offscreenContext.lineTo(endX, endY);
        offscreenContext.stroke();

      }

      offscreenContext.strokeStyle = originalStrokeStyle;
      offscreenContext.lineWidth = originalLineWidth;



    }

    // Function to check if a point is inside the hexagon
    function isPointInHex(x, y, centerX, centerY, hexSide) {
        const dx = Math.abs(x - centerX);
        const dy = Math.abs(y - centerY);
        const hexWidth = hexSide * Math.sqrt(3) / 2;

        if (dx > hexWidth || dy > hexSide) return false;
        if (dx <= hexWidth / 2) return true;

        const slope = hexSide / (hexWidth / 2);
        return dy <= hexSide - slope * (dx - hexWidth / 2);
    }

    // Function to generate a random jagged polygon
    function generateDebrisPolygon(centerX, centerY, hexSide) {
        const maxSize = hexSide / 4;
        const minSize = hexSide / 8;

        // Random size for this debris piece
        const size = minSize + Math.random() * (maxSize - minSize);

        // Random center position within the hex (can be up to hexSide distance from center)
        const hexWidth = hexSide * Math.sqrt(3) / 2;
        let debrisCenterX, debrisCenterY;

        // Use polar coordinates to spread more evenly and reach further out
        const angle = Math.random() * Math.PI * 2;
        const maxDistance = Math.min(hexSide * 0.8, hexWidth * 0.8); // Stay within hex bounds
        const distance = Math.random() * maxDistance;

        debrisCenterX = centerX + Math.cos(angle) * distance;
        debrisCenterY = centerY + Math.sin(angle) * distance;

        // Fallback to random positioning if polar method fails
        if (!isPointInHex(debrisCenterX, debrisCenterY, centerX, centerY, hexSide)) {
            do {
                debrisCenterX = centerX + (Math.random() - 0.5) * hexWidth * 1.6;
                debrisCenterY = centerY + (Math.random() - 0.5) * hexSide * 1.6;
            } while (!isPointInHex(debrisCenterX, debrisCenterY, centerX, centerY, hexSide));
        }

        // Generate 5-8 vertices for jagged appearance
        const numVertices = 5 + Math.floor(Math.random() * 4);
        const vertices = [];

        for (let i = 0; i < numVertices; i++) {
            const angle = (i / numVertices) * Math.PI * 2;
            // Vary the radius to create jagged edges
            const radiusVariation = 0.5 + Math.random() * 0.5;
            const radius = size * radiusVariation;

            const x = debrisCenterX + Math.cos(angle) * radius;
            const y = debrisCenterY + Math.sin(angle) * radius;

            vertices.push({ x, y });
        }

        return vertices;
    }





    // Main debris drawing function
    function drawDebris() {
        offscreenContext.strokeStyle = map.palette.lines;
        offscreenContext.fillStyle = map.palette.walls;
        offscreenContext.lineWidth = 1;

        // Generate 12-20 debris pieces
        const numDebris = 12 + Math.floor(Math.random() * 9);

        for (let i = 0; i < numDebris; i++) {
            const vertices = generateDebrisPolygon(centerX, centerY, hexSide);

            // Draw the polygon
            offscreenContext.beginPath();
            offscreenContext.moveTo(vertices[0].x, vertices[0].y);

            for (let j = 1; j < vertices.length; j++) {
                offscreenContext.lineTo(vertices[j].x, vertices[j].y);
            }

            offscreenContext.closePath();
            offscreenContext.fill();
            offscreenContext.stroke();

            // Add 3D highlights if texture is enabled
            if (map.texture === 'yes') {
                // Create a lighter highlight color
                const baseColor = map.palette.walls;
                let highlightColor;

                // Simple way to create a lighter version of the color
                if (baseColor.startsWith('#')) {
                    // Convert hex to RGB, lighten, and convert back
                    const r = parseInt(baseColor.substr(1, 2), 16);
                    const g = parseInt(baseColor.substr(3, 2), 16);
                    const b = parseInt(baseColor.substr(5, 2), 16);

                    const lighten = 40;
                    const newR = Math.min(255, r + lighten);
                    const newG = Math.min(255, g + lighten);
                    const newB = Math.min(255, b + lighten);

                    highlightColor = `rgb(${newR}, ${newG}, ${newB})`;
                } else {
                    // Fallback for other color formats
                    highlightColor = 'rgba(255, 255, 255, 0.3)';
                }

                // Draw highlight on top-left edges (simulating light from top-left)
                offscreenContext.strokeStyle = highlightColor;
                offscreenContext.lineWidth = 1.5;
                offscreenContext.beginPath();

                // Find the topmost and leftmost vertices for highlighting
                let topVertex = vertices[0];
                let leftVertex = vertices[0];

                for (let k = 1; k < vertices.length; k++) {
                    if (vertices[k].y < topVertex.y) topVertex = vertices[k];
                    if (vertices[k].x < leftVertex.x) leftVertex = vertices[k];
                }

                // Draw highlight lines on a few edges that would catch light
                for (let k = 0; k < vertices.length; k++) {
                    const current = vertices[k];
                    const next = vertices[(k + 1) % vertices.length];

                    // Highlight edges that are on the top or left side
                    const edgeAngle = Math.atan2(next.y - current.y, next.x - current.x);
                    const normalizedAngle = ((edgeAngle + Math.PI * 2) % (Math.PI * 2));

                    // Highlight edges facing roughly northwest to northeast (top edges)
                    if (normalizedAngle > Math.PI * 1.25 && normalizedAngle < Math.PI * 1.75) {
                        offscreenContext.moveTo(current.x, current.y);
                        offscreenContext.lineTo(next.x, next.y);
                    }
                }

                offscreenContext.stroke();

                // Reset stroke style for next debris piece
                offscreenContext.strokeStyle = map.palette.lines;
                offscreenContext.lineWidth = 1;
            }
        }
    }


    function darkenColor(hexColor, amount = 0.2) {
      // Convert shorthand hex to full form (e.g., #abc → #aabbcc)
      if (hexColor.length === 4) {
        hexColor = '#' + [...hexColor.slice(1)].map(c => c + c).join('');
      }

      let r = parseInt(hexColor.slice(1, 3), 16);
      let g = parseInt(hexColor.slice(3, 5), 16);
      let b = parseInt(hexColor.slice(5, 7), 16);

      // Apply darkening
      r = Math.max(0, Math.floor(r * (1 - amount)));
      g = Math.max(0, Math.floor(g * (1 - amount)));
      b = Math.max(0, Math.floor(b * (1 - amount)));

      // Convert back to hex
      return `#${[r, g, b].map(v => v.toString(16).padStart(2, '0')).join('')}`;
    }

    function lightenColor(hexColor, amount = 0.2) {
      // Convert shorthand hex to full form (e.g., #abc → #aabbcc)
      if (hexColor.length === 4) {
        hexColor = '#' + [...hexColor.slice(1)].map(c => c + c).join('');
      }

      let r = parseInt(hexColor.slice(1, 3), 16);
      let g = parseInt(hexColor.slice(3, 5), 16);
      let b = parseInt(hexColor.slice(5, 7), 16);

      // Apply darkening
      r = Math.min(255, Math.floor(r + (255 - r) * amount));
      g = Math.min(255, Math.floor(g + (255 - g) * amount));
      b = Math.min(255, Math.floor(b + (255 - b) * amount));

      // Convert back to hex
      return `#${[r, g, b].map(v => v.toString(16).padStart(2, '0')).join('')}`;
    }



    function drawArcaneSymbols() {
       // Array of obscure mathematical, astrological, and mystical symbols
       const arcaneSymbols = [
           '∴', '∵',  '∅', '∞', '∝', '∆', '∇', '∂', '∫', '∮', '∯', '∰', '∱',
           '☉', '☽', '☾', '☿', '♀', '♁', '♂', '♃', '♄', '♅', '♆', '♇', '☌', '☍', '☊', '☋',
           '⊕', '⊖', '⊗', '⊙', '⊚', '⊛', '⊜', '⊝', '⊞', '⊟', '⊠', '⊡', '⊢', '⊣', '⊤', '⊥',
           '⟂', '⟃', '⟄', '⟅', '⟆', '⟇', '⟈', '⟉', '⟊', '⟋', '⟌', '⟍', '⟎', '⟏', '⟐', '⟑',
           '⌬', '⌭', '⌮', '⌯', '⌰', '⌱', '⌲', '⌳', '⌴', '⌵', '⌶', '⌷', '⌸', '⌹', '⌺', '⌻',
           '⍝', '⍞', '⍟', '⍠', '⍡', '⍢', '⍣', '⍤', '⍥', '⍦', '⍧', '⍩', '⍪', '⍫', '⍬'
       ];

       const saveFont = offscreenContext.font;

       // Set symbol styling
       offscreenContext.fillStyle = map.palette.lines;
       offscreenContext.font = `${Math.floor(hexSide * 0.8)}px Arial`;
       offscreenContext.textAlign = 'center';
       offscreenContext.font = `40px Arial`;
       offscreenContext.textBaseline = 'middle';



       // Function to draw symbols along an edge
       function drawSymbolsAlongEdge(startX, startY, endX, endY, symbols) {
           const edgeLength = Math.sqrt((endX - startX) ** 2 + (endY - startY) ** 2);
           const symbolCount = Math.floor(edgeLength / hexSide);

           if (symbolCount === 0) return;

           const stepX = (endX - startX) / symbolCount;
           const stepY = (endY - startY) / symbolCount;

           for (let i = 0; i < symbolCount; i++) {
               const x = startX + stepX * (i + 0.5);
               const y = startY + stepY * (i + 0.5);
               const symbol = symbols[Math.floor(Math.random() * symbols.length)];
               // Make sure symbol is within the hexSide boundary
               if (x >= hexSide/2 && x <= offscreenCanvas.width - hexSide/2 &&
                   y >= hexSide/2 && y <= offscreenCanvas.height - hexSide/2) {
                   offscreenContext.fillText(symbol, x, y);
               }
           }
       }

       // Draw symbols around all four edges
       // Top edge
       drawSymbolsAlongEdge(hexSide/2, hexSide/2, offscreenCanvas.width - hexSide/2, hexSide/2, arcaneSymbols);
       // Right edge
       drawSymbolsAlongEdge(offscreenCanvas.width - hexSide/2, hexSide/2, offscreenCanvas.width - hexSide/2, offscreenCanvas.height - hexSide/2, arcaneSymbols);
       // Bottom edge
       drawSymbolsAlongEdge(offscreenCanvas.width - hexSide/2, offscreenCanvas.height - hexSide/2, hexSide/2, offscreenCanvas.height - hexSide/2, arcaneSymbols);
       // Left edge
       drawSymbolsAlongEdge(hexSide/2, offscreenCanvas.height - hexSide/2, hexSide/2, hexSide/2, arcaneSymbols);

       offscreenContext.font = saveFont;

    }


    function traceHex( x, y ) {

      centerI = centerOf( x, y );

      offscreenContext.beginPath();

      offscreenContext.moveTo( centerI.x - hexSide, centerI.y );
      offscreenContext.lineTo( centerI.x - hexSide / 2, centerI.y - hexHeight / 2 );
      offscreenContext.lineTo( centerI.x + hexSide / 2, centerI.y - hexHeight / 2 );
      offscreenContext.lineTo( centerI.x + hexSide, centerI.y );
      offscreenContext.lineTo( centerI.x + hexSide / 2, centerI.y + hexHeight / 2 );
      offscreenContext.lineTo( centerI.x - hexSide / 2, centerI.y + hexHeight / 2 );
      offscreenContext.lineTo( centerI.x - hexSide, centerI.y );

      offscreenContext.closePath()


    }

    function drawHexCorners() {

      const cornerLength = 8; // Length of corner segments in pixels

      offscreenContext.beginPath();

      // Define all the corner points
      const points = [
          { x: centerI.x - hexSide, y: centerI.y },
          { x: centerI.x - hexSide / 2, y: centerI.y - hexHeight / 2 },
          { x: centerI.x + hexSide / 2, y: centerI.y - hexHeight / 2 },
          { x: centerI.x + hexSide, y: centerI.y },
          { x: centerI.x + hexSide / 2, y: centerI.y + hexHeight / 2 },
          { x: centerI.x - hexSide / 2, y: centerI.y + hexHeight / 2 }
      ];

      // Draw corner segments for each edge
      for (let i = 0; i < points.length; i++) {
          const current = points[i];
          const next = points[(i + 1) % points.length];

          // Calculate the direction vector
          const dx = next.x - current.x;
          const dy = next.y - current.y;
          const length = Math.sqrt(dx * dx + dy * dy);

          // Normalize the direction vector
          const unitX = dx / length;
          const unitY = dy / length;

          // Draw first corner segment (from current point)
          offscreenContext.moveTo(current.x, current.y);
          offscreenContext.lineTo(
              current.x + unitX * cornerLength,
              current.y + unitY * cornerLength
          );

          // Draw last corner segment (to next point)
          offscreenContext.moveTo(
              next.x - unitX * cornerLength,
              next.y - unitY * cornerLength
          );
          offscreenContext.lineTo(next.x, next.y);
      }

      offscreenContext.stroke();


    }


    function fillBridge( theBridge ) {

      nextX = theBridge.startingX;
      nextY = theBridge.startingY;

      fillDirection = bridgeDirection( {x:theBridge.startingX,y:theBridge.startingY},{x:theBridge.endingX,y:theBridge.endingY})

      if ( fillDirection == Math.round(fillDirection) ) {

        while ( !( nextX == theBridge.endingX && nextY == theBridge.endingY ) ) {

          nextHex = hexAdjacent( nextX, nextY, fillDirection );
          nextX = nextHex.x;
          nextY = nextHex.y;

          if ( !( nextX == theBridge.endingX && nextY == theBridge.endingY ) ) {

            map.grid[nextX][nextY].push('bridge');

          }

        }

      }

    }


    function traceLiquidHex( x, y, liquid ) {

      centerI = centerOf( x, y );

      offscreenContext.beginPath();

      // if ( featureInDirection( x, y, 5, liquid ) || featureInDirection( x, y, 0, liquid ) ) {
      //   offscreenContext.moveTo( centerI.x - hexSide / 2, centerI.y - hexHeight / 2 );
      // } else {
      //   offscreenContext.moveTo( (centerI.x - hexSide / 2)*0.9, (centerI.y - hexHeight / 2)*0.9 );
      // }
      //
      // if ( featureInDirection( x, y, 0, liquid ) ) {
      //   offscreenContext.lineTo( centerI.x, (centerI.y - hexHeight / 2)*0.9 );
      // } else {
      //   offscreenContext.lineTo( centerI.x, (centerI.y - hexHeight / 2) );
      // }
      //
      // if ( featureInDirection( x, y, 0, liquid ) || featureInDirection( x, y, 1, liquid ) ) {
      //   offscreenContextl.lineTo( centerI.x - hexSide / 2, centerI.y - hexHeight / 2 );
      // } else {
      //   offscreenContext.lineTo( (centerI.x + hexSide / 2)*0.9, (centerI.y - hexHeight / 2)*0.9 );
      // }
      //
      // if ( featureInDirection( x, y, 1, liquid )  ) {
      //   offscreenContext.moveTo( centerI.x + hexSide * 3/4, centerI.y - hexHeight / 4 );
      // } else {
      //   offscreenContext.moveTo( (centerI.x + hexSide * 3/4)*0.9, (centerI.y - hexHeight / 4)*0.9 );
      // }
      //

      // Start at top-left vertex
      if ( featureInDirection( x, y, 5, liquid ) || featureInDirection( x, y, 0, liquid ) ) {
        offscreenContext.moveTo( centerI.x - hexSide / 2, centerI.y - hexHeight / 2 );
      } else {
        offscreenContext.moveTo( (centerI.x - hexSide / 2)*0.9, (centerI.y - hexHeight / 2)*0.9 );
      }

      // To top midpoint
      if ( featureInDirection( x, y, 0, liquid ) ) {
        offscreenContext.lineTo( centerI.x, (centerI.y - hexHeight / 2)*0.9 );
      } else {
        offscreenContext.lineTo( centerI.x, (centerI.y - hexHeight / 2) );
      }

      // To top-right vertex
      if ( featureInDirection( x, y, 0, liquid ) || featureInDirection( x, y, 1, liquid ) ) {
        offscreenContext.lineTo( centerI.x + hexSide / 2, centerI.y - hexHeight / 2 );
      } else {
        offscreenContext.lineTo( (centerI.x + hexSide / 2)*0.9, (centerI.y - hexHeight / 2)*0.9 );
      }

      // To right midpoint
      if ( featureInDirection( x, y, 1, liquid ) ) {
        offscreenContext.lineTo( centerI.x + hexSide * 3/4, (centerI.y - hexHeight / 4)*0.9 );
      } else {
        offscreenContext.lineTo( centerI.x + hexSide * 3/4, centerI.y - hexHeight / 4 );
      }

      // To right vertex
      if ( featureInDirection( x, y, 1, liquid ) || featureInDirection( x, y, 2, liquid ) ) {
        offscreenContext.lineTo( centerI.x + hexSide, centerI.y );
      } else {
        offscreenContext.lineTo( (centerI.x + hexSide)*0.9, centerI.y );
      }

      // To bottom-right midpoint
      if ( featureInDirection( x, y, 2, liquid ) ) {
        offscreenContext.lineTo( centerI.x + hexSide * 3/4, (centerI.y + hexHeight / 4)*0.9 );
      } else {
        offscreenContext.lineTo( centerI.x + hexSide * 3/4, centerI.y + hexHeight / 4 );
      }

      // To bottom-right vertex
      if ( featureInDirection( x, y, 2, liquid ) || featureInDirection( x, y, 3, liquid ) ) {
        offscreenContext.lineTo( centerI.x + hexSide / 2, centerI.y + hexHeight / 2 );
      } else {
        offscreenContext.lineTo( (centerI.x + hexSide / 2)*0.9, (centerI.y + hexHeight / 2)*0.9 );
      }

      // To bottom midpoint
      if ( featureInDirection( x, y, 3, liquid ) ) {
        offscreenContext.lineTo( centerI.x, (centerI.y + hexHeight / 2)*0.9 );
      } else {
        offscreenContext.lineTo( centerI.x, centerI.y + hexHeight / 2 );
      }

      // To bottom-left vertex
      if ( featureInDirection( x, y, 3, liquid ) || featureInDirection( x, y, 4, liquid ) ) {
        offscreenContext.lineTo( centerI.x - hexSide / 2, centerI.y + hexHeight / 2 );
      } else {
        offscreenContext.lineTo( (centerI.x - hexSide / 2)*0.9, (centerI.y + hexHeight / 2)*0.9 );
      }

      // To left midpoint
      if ( featureInDirection( x, y, 4, liquid ) ) {
        offscreenContext.lineTo( (centerI.x - hexSide * 3/4)*0.9, (centerI.y + hexHeight / 4)*0.9 );
      } else {
        offscreenContext.lineTo( centerI.x - hexSide * 3/4, centerI.y + hexHeight / 4 );
      }

      // To left vertex
      if ( featureInDirection( x, y, 4, liquid ) || featureInDirection( x, y, 5, liquid ) ) {
        offscreenContext.lineTo( centerI.x - hexSide, centerI.y );
      } else {
        offscreenContext.lineTo( (centerI.x - hexSide)*0.9, centerI.y );
      }

      // To top-left midpoint
      if ( featureInDirection( x, y, 5, liquid ) ) {
        offscreenContext.lineTo( (centerI.x - hexSide * 3/4)*0.9, (centerI.y - hexHeight / 4)*0.9 );
      } else {
        offscreenContext.lineTo( centerI.x - hexSide * 3/4, centerI.y - hexHeight / 4 );
      }


      offscreenContext.closePath()


    }


    function featureInDirection( x, y, direction, feature ) {

      const otherHex = hexAdjacent( x, y, direction );

      if ( map.grid[otherHex.x][otherHex.y].includes(feature ) ) {
        return true;
      }

      return false;

    }



    function drawMegaHex(x, y) {
      offscreenContext.lineWidth = 4;
      offscreenContext.strokeStyle = map.palette.lines;
      offscreenContext.beginPath();

      // Define which edges to draw for each adjacent hex (the outer edges)
      const outerEdges = [
        [5, 0, 1], // Adjacent hex 0: edges 5, 0, 1
        [0, 1, 2], // Adjacent hex 1: edges 0, 1, 2
        [1, 2, 3], // Adjacent hex 2: edges 1, 2, 3
        [2, 3, 4], // Adjacent hex 3: edges 2, 3, 4
        [3, 4, 5], // Adjacent hex 4: edges 3, 4, 5
        [4, 5, 0]  // Adjacent hex 5: edges 4, 5, 0
      ];

      // Draw the outer perimeter
      for (let i = 0; i < 6; i++) {

        const hex = hexAdjacent(x, y, i);

//        console.log(hex.x);
//        console.log(hex.y);

        if ( !inBounds( hex.x, hex.y ) ) continue;
//        console.log(map.grid[hex.x][hex.y]);
        if ( map.grid[hex.x][hex.y].includes('offboard') ) continue;

        const edges = outerEdges[i];

        // Draw each outer edge for this adjacent hex
        for (let j = 0; j < edges.length; j++) {
          const edgeStart = edges[j];
          const edgeEnd = (edges[j] + 1) % 6;

          const vertex1 = hexVertex(hex.x, hex.y, edgeStart);
          const vertex2 = hexVertex(hex.x, hex.y, edgeEnd);

          offscreenContext.moveTo(vertex1.x, vertex1.y);
          offscreenContext.lineTo(vertex2.x, vertex2.y);
        }
      }

      offscreenContext.stroke();
    }

    function unevenLine( srcX, srcY, destX, destY ) {

      // let saveLineWidth = offscreenContext.lineWidth;
      // offscreenContext.lineWidth = 2;


      //switch ( Math.ceil( Math.random() * 3 ) ) {
      switch ( 3 ) {

        case 1:
          offscreenContext.strokeStyle='black';
          offscreenContext.moveTo( srcX, srcY );
          offscreenContext.lineTo( destX, destY );
          offscreenContext.stroke();
          break;

        case 2:
          offscreenContext.strokeStyle='black';
          let breakPoint = 0.1 + Math.random() * 0.8;

          let breakStartX = srcX + breakPoint * ( destX - srcX );
          let breakStartY = srcY + breakPoint * ( destY - srcY );

          let breakEndX = srcX + (breakPoint+0.1) * ( destX - srcX );
          let breakEndY = srcY + (breakPoint+0.1) * ( destY - srcY );

          offscreenContext.moveTo( srcX, srcY );
          offscreenContext.lineTo( breakStartX, breakStartY );
          offscreenContext.moveTo( breakEndX, breakEndY );
          offscreenContext.lineTo( destX, destY );
          offscreenContext.stroke();
          break;

          case 3:

            midwayPoints = [];
            for ( let i = 0; i < 9; i++ ) {
              midwayPoints.push( ( ( i + Math.random() ) / 10 ).toFixed(3) );
            }

            wayPoints = [ { x: srcX, y: srcY } ];
            for ( let i = 0; i < midwayPoints.length; i++ ) {
              wayPoints.push(
                { x: (srcX + ( midwayPoints[i]  * ( destX - srcX ) ) + ( ( Math.random() - 0.5 ) * 2 )).toFixed(3),
                  y: (srcY + ( midwayPoints[i] * ( destY - srcY ) ) + ( ( Math.random() - 0.5 ) * 2 )).toFixed(3)
                } );
            }


            for ( let i = 0; i < wayPoints.length-1; i++ ) {


              if ( i > 0 && i < wayPoints.length - 1 && Math.random() < 0.2 ) {

              } else {

                offscreenContext.beginPath();

                offscreenContext.moveTo( wayPoints[i].x, wayPoints[i].y );

                offscreenContext.lineTo( wayPoints[i+1].x, wayPoints[i+1].y );
                offscreenContext.stroke();
                offscreenContext.closePath();

              }
            }

            offscreenContext.lineTo( destX, destY );

            offscreenContext.stroke();
//              boardContext.strokeStyle='black';

            break;
      }

//      offscreenContext.lineWidth = saveLineWidth;


    }



    function offscreenToMiniMap() {

      miniMapContext.drawImage(
              offscreenCanvas,
              0, 0, offscreenCanvas.width, offscreenCanvas.height,  // source rectangle
              0, 0, miniMapCanvas.width, miniMapCanvas.height   // destination rectangle
          );

    }

    // function offscreenToDisplayOld() {
    //
    //   displayCanvas.width = mapDisplayDiv.clientWidth;
    //   displayCanvas.height = mapDisplayDiv.clientHeight;
    //
    //   displayContext.fillStyle = map.palette.offboard;
    //   displayContext.fillRect(0, 0, displayCanvas.width, displayCanvas.height);
    //
    //   const scaleX = displayCanvas.width / offscreenCanvas.width;
    //   const scaleY = displayCanvas.height / offscreenCanvas.height;
    //   const scale = Math.min(scaleX, scaleY); // Use smaller scale to fit entirely
    //   const newWidth = offscreenCanvas.width * scale;
    //   const newHeight = offscreenCanvas.height * scale;
    //   const x = (displayCanvas.width - newWidth) / 2;
    //   const y = (displayCanvas.height - newHeight) / 2;
    //
    //   displayContext.drawImage(offscreenCanvas, x, y, newWidth, newHeight);
    //
    //   miniMapContext.drawImage(offscreenCanvas, x, y, newWidth, newHeight);
    //
    //
    // }

    function zoom(event) {

        event.preventDefault();

//            console.log( event.deltaY );

        if ( event.deltaY < -100 ) {
            zoomLevel -= 20;
        } else if ( event.deltaY < 0 ) {
            zoomLevel -= 10;
        } else if ( event.deltaY < 100 ) {
            zoomLevel += 10;
        } else {
            zoomLevel += 20;
        }

        if ( zoomLevel < 200 ) {
            zoomLevel = 200;
        } else if ( zoomLevel > maxZoomLevel ) {
            zoomLevel = maxZoomLevel;
        }

//            console.log(zoomLevel);

        offscreenToDisplay();

    }

    function displayMouseDown( event ) {

      isDragging = false;
      startX = event.clientX;
      startY = event.clientY;

//      let maybe = getHexFromCanvasPoint( event.clientX, event.clientY);

//      console.log( maybe.x, maybe.y );

    }

    function displayMouseMove( event ) {

//      if (!event) return;

      if (event.buttons === 1) { // Left mouse button is down
          const deltaX = event.clientX - startX;
          const deltaY = event.clientY - startY;

          // If moved more than threshold, start dragging
          if (!isDragging && (Math.abs(deltaX) > 3 || Math.abs(deltaY) > 3)) {
              isDragging = true;
          }

          if (isDragging) {

            if ( event.shiftKey) {
              // we are editing multiple hexes

              applyTool( event );


            } else {
              //we are dragging the map

              // Update map position in real-time
              focusX -= deltaX;
              focusY -= deltaY;

              focusX = Math.max(zoomX, Math.min(focusX, offscreenCanvas.width - zoomX));
              focusY = Math.max(zoomY, Math.min(focusY, offscreenCanvas.height - zoomY));

              offscreenToDisplay();

              // Update start position for next move
              startX = event.clientX;
              startY = event.clientY;

            }

          }
      }

    }

    function displayMouseUp( event ) {

      if ( isDragging ) {
        return;
      }

      applyTool( event );

      // const widthRatio = offscreenCanvas.width / displayCanvas.width;
      // const heightRatio = offscreenCanvas.height / displayCanvas.height;



    }


    function applyTool( event ) {

      let offscreenX = event.offsetX * ( 2 * zoomX / displayCanvas.width ) + ( focusX - zoomX );
      let offscreenY = event.offsetY * ( 2 * zoomY / displayCanvas.height ) + ( focusY - zoomY );

      theHex = offscreenPointToHex( offscreenX, offscreenY );
      // console.log(theHex);
      // console.log(keys(theHex));
      // if ( keys(theHex) == ['undefined'] ) return;
      if ( theHex.x == undefined ) return;
//      console.log( 'applyTool('+theHex.x+','+ theHex.y +')');

//      console.log('looks like you clicked in ' + theHex.x + ',' + theHex.y );

        if ( map.grid[theHex.x][theHex.y] != undefined ) {

          switch ( global.currentTool ) {
            case 'clear':
              map.grid[theHex.x][theHex.y] = [];
              break;

            case 'wall hex':
              map.grid[theHex.x][theHex.y] = ['wall hex'];
              break;

            case 'water':
              if (map.grid[theHex.x][theHex.y].includes('stone')) {
                map.grid[theHex.x][theHex.y] = ['water','stone'];
              } else {
                map.grid[theHex.x][theHex.y] = ['water'];
              }
              break;

            case 'offboard':
              map.grid[theHex.x][theHex.y] = ['offboard'];
              break;

            case 'pit':
              map.grid[theHex.x][theHex.y] = ['pit'];
              break;

            case 'path':
              if (!map.grid[theHex.x][theHex.y].includes('paths')) {
                  map.grid[theHex.x][theHex.y].push('paths');
              }
              break;

            case 'debris':
              if (!map.grid[theHex.x][theHex.y].includes('debris')) {
                  map.grid[theHex.x][theHex.y].push('debris');
              }
              break;

            case 'stone':
              if (!map.grid[theHex.x][theHex.y].includes('stone')) {
                  map.grid[theHex.x][theHex.y].push('stone');
              }
              break;

            case 'column':
              if (!map.grid[theHex.x][theHex.y].includes('column')) {
                  map.grid[theHex.x][theHex.y].push('column');
              }
              break;

            case 'trapdoor':
              if (!map.grid[theHex.x][theHex.y].includes('trapdoor')) {
                  map.grid[theHex.x][theHex.y].push('trapdoor');
              }
              break;

            case 'table':
              if (!map.grid[theHex.x][theHex.y].includes('table')) {
                  map.grid[theHex.x][theHex.y].push('table');
              }
              break;

            case 'altar':
              if (!map.grid[theHex.x][theHex.y].includes('altar')) {
                  map.grid[theHex.x][theHex.y].push('altar');
              }
              break;

            case 'pentacle':
              if (!map.grid[theHex.x][theHex.y].includes('pentacle')) {
                  map.grid[theHex.x][theHex.y].push('pentacle');
              }
              break;

            case 'paths':
              if (!map.grid[theHex.x][theHex.y].includes('path')) {
                  map.grid[theHex.x][theHex.y].push('path');
              }
              break;

            case 'lava':
              if (map.grid[theHex.x][theHex.y].includes('stone')) {
                map.grid[theHex.x][theHex.y] = ['lava','stone'];
              } else {
                map.grid[theHex.x][theHex.y] = ['lava'];
              }
              break;

            case 'fire':
              if (!map.grid[theHex.x][theHex.y].includes('fire')) {
                  map.grid[theHex.x][theHex.y].push('fire');
              }
              break;

            case 'shadow':
              if (!map.grid[theHex.x][theHex.y].includes('shadow')) {
                  map.grid[theHex.x][theHex.y].push('shadow');
              }
              break;

            case 'body':
              if (!map.grid[theHex.x][theHex.y].includes('body')) {
                  map.grid[theHex.x][theHex.y].push('body');
              }
              break;

            case 'barricade':
              if (!map.grid[theHex.x][theHex.y].includes('barricade')) {
                  map.grid[theHex.x][theHex.y].push('barricade');
              }
              break;

            case 'star':
              if (!map.grid[theHex.x][theHex.y].includes('star')) {
                  map.grid[theHex.x][theHex.y].push('star');
              }
              break;

              case 'tar':
                map.grid[theHex.x][theHex.y] = map.grid[theHex.x][theHex.y].filter(item=>item!=='slippery');
                if (!map.grid[theHex.x][theHex.y].includes('tar')) {
                    map.grid[theHex.x][theHex.y].push('tar');
                }
                break;

            case 'sticky':
              map.grid[theHex.x][theHex.y] = map.grid[theHex.x][theHex.y].filter(item=>item!=='slippery');
              if (!map.grid[theHex.x][theHex.y].includes('sticky')) {
                  map.grid[theHex.x][theHex.y].push('sticky');
              }
              break;

            case 'slippery':
              map.grid[theHex.x][theHex.y] = map.grid[theHex.x][theHex.y].filter(item=>item!=='sticky');
              if (!map.grid[theHex.x][theHex.y].includes('slippery')) {
                  map.grid[theHex.x][theHex.y].push('slippery');
              }
              break;

            case 'lighter':
              map.grid[theHex.x][theHex.y] = map.grid[theHex.x][theHex.y].filter(item=>item!=='darker');
              if (!map.grid[theHex.x][theHex.y].includes('lighter')) {
                  map.grid[theHex.x][theHex.y].push('lighter');
              }
              break;

            case 'darker':
              map.grid[theHex.x][theHex.y] = map.grid[theHex.x][theHex.y].filter(item=>item!=='lighter');
              if (!map.grid[theHex.x][theHex.y].includes('darker')) {
                  map.grid[theHex.x][theHex.y].push('darker');
              }
              break;

            case 'bridge':
              if ( bridgeStart == undefined ) {
                bridgeStart = theHex;
              } else {

                if ( distanceBetween( theHex.x, theHex.y, bridgeStart.x, bridgeStart.y) < 2 ) {
                  return;
                }

                if ( ['wild lands','burrow','woods','swamp'].includes(map.palette.name.toLowerCase()) ) {

                  map.woodBridges.push({
                    startingX: bridgeStart.x,
                    startingY: bridgeStart.y,
                    endingX: theHex.x,
                    endingY: theHex.y
                  });

                } else {
                  map.stoneBridges.push({
                    startingX: bridgeStart.x,
                    startingY: bridgeStart.y,
                    endingX: theHex.x,
                    endingY: theHex.y
                  });

                }
//                  document.getElementById('textDisplayArea').value += 'stone bridge from ' + bridgeStart.x +',' + bridgeStart.y + 'to ' + thehex.x + ',' + theHex.y;
                  //                convertTextToObject();

                  if ( !bridgeGoodDirection( bridgeStart, theHex ) ) {
//                    console.log('crooked bridge');

                    document.getElementById('bridgeWarningDiv').style.display='block';

                  }

                  if (map.stoneBridges && map.stoneBridges.length > 0) {
                      map.stoneBridges.forEach(stoneBridge => {

                          fillBridge( stoneBridge );
                      });
                  }

                  if (map.woodBridges && map.woodBridges.length > 0) {
                      map.woodBridges.forEach(woodBridge => {

                          fillBridge( woodBridge );

                      });
                  }

                bridgeStart = undefined;

              }

        }

        convertObjectToText();
        objectToOffscreen();
        offscreenToDisplay();
        offscreenToMiniMap();

      }

    }

    function distanceBetween( x1, y1, x2, y2 ) {

      return Math.max( Math.abs( x2 - x1 ), Math.abs ( y2 - y1 ) );


    }


    function bridgeDirection(start, end) {
      // Convert hex coordinates to canvas coordinates
      const startCanvas = centerOf(start.x, start.y);
      const endCanvas = centerOf(end.x, end.y);

      // Calculate the direction vector
      const dx = endCanvas.x - startCanvas.x;
      const dy = endCanvas.y - startCanvas.y;

      // Calculate angle in radians (atan2 returns angle from -π to π)
      // Note: atan2(dy, dx) gives angle from positive x-axis
      // We need to adjust for "0° is straight up" convention
      let angleRad = Math.atan2(dx, -dy); // Negative dy because canvas y increases downward

      // Convert to degrees
      let angleDeg = angleRad * (180 / Math.PI);

      // Normalize to 0-360 range
      if (angleDeg < 0) {
          angleDeg += 360;
      }

      return (Math.round(angleDeg)/60);

    }


    function offscreenPointToHex( x, y ) {

      let iX = 0;
      let iY = 0;

//      mapSearchLoop:
      for ( iX = 0; iX < map.width; iX++ ) {
        for ( iY = 0; iY < map.height; iY++ ) {

          hexCenter = centerOf( iX, iY );

          let dx = hexCenter.x - x;
          let dy = hexCenter.y - y;

          if ( dx ** 2 + dy ** 2 <= hexSideSquared ) {

            return { x: iX, y: iY }

//            break mapSearchLoop;

          }
        }
      }

      return { undefined }

    }



    function bridgeGoodDirection(start, end) {
      // Convert hex coordinates to canvas coordinates
      const startCanvas = centerOf(start.x, start.y);
      const endCanvas = centerOf(end.x, end.y);

      // Calculate the direction vector
      const dx = endCanvas.x - startCanvas.x;
      const dy = endCanvas.y - startCanvas.y;

      // Calculate angle in radians (atan2 returns angle from -π to π)
      // Note: atan2(dy, dx) gives angle from positive x-axis
      // We need to adjust for "0° is straight up" convention
      let angleRad = Math.atan2(dx, -dy); // Negative dy because canvas y increases downward

      // Convert to degrees
      let angleDeg = angleRad * (180 / Math.PI);

      // Normalize to 0-360 range
      if (angleDeg < 0) {
          angleDeg += 360;
      }

//      console.log(Math.round(angleDeg)/60);

      // Check if angle is a multiple of 60°
      // Allow small tolerance for floating point precision
      const tolerance = 0.1;
      const remainder = angleDeg % 60;

      return remainder <= tolerance || remainder >= (60 - tolerance);
      }


    function offscreenPointToHex( x, y ) {

      let iX = 0;
      let iY = 0;

//      mapSearchLoop:
      for ( iX = 0; iX < map.width; iX++ ) {
        for ( iY = 0; iY < map.height; iY++ ) {

          hexCenter = centerOf( iX, iY );

          let dx = hexCenter.x - x;
          let dy = hexCenter.y - y;

          if ( dx ** 2 + dy ** 2 <= hexSideSquared ) {

            return { x: iX, y: iY }

//            break mapSearchLoop;

          }
        }
      }

      return { undefined }

    }




    function offscreenToDisplay() {

      displayCanvas.width = mapDisplayDiv.clientWidth;
      displayCanvas.height = mapDisplayDiv.clientHeight;

      displayContext.fillStyle = map.palette.offboard;
      displayContext.fillRect(0, 0, displayCanvas.width, displayCanvas.height);

      focusX = Math.max(zoomX, Math.min(focusX, offscreenCanvas.width - zoomX));
      focusY = Math.max(zoomY, Math.min(focusY, offscreenCanvas.height - zoomY));

      zoomY = zoomLevel;
      zoomX = zoomLevel * ( displayCanvas.width / displayCanvas.height );

      if ( 2 * zoomX > offscreenCanvas.width ) {
        focusX = offscreenCanvas.width / 2;
      }

      if ( 2 * zoomY > offscreenCanvas.height ) {
        focusY = offscreenCanvas.height / 2;
      }


      displayContext.drawImage( offscreenCanvas, focusX - zoomX, focusY - zoomY, zoomX * 2, zoomY * 2, 0, 0, displayCanvas.width, displayCanvas.height );

      miniMapContext.drawImage(offscreenCanvas,0,0,offscreenCanvas.width,offscreenCanvas.height,0,0,miniMapCanvas.width,miniMapCanvas.height);

      miniMapContext.beginPath();
//        smallMapContext.strokeStyle = "orange";
      miniMapContext.strokeStyle = getInverseColor( map.palette.clear );

      // miniBoardWidthRatio = miniMapCanvas.width / miniMapCanvas.width;
      // miniBoardHeightRatio = miniMapCanvas.height / miniMapCanvas.height;
      // miniMapContext.strokeRect( (focusX-zoomX)*miniBoardWidthRatio,(focusY-zoomY)*miniBoardHeightRatio,2*zoomX*miniBoardWidthRatio,2*zoomY*miniBoardHeightRatio );

//      miniMapContext.strokeRect( focusX - zoomX, focusY - zoomY, zoomX * 2, zoomY * 2 );


      const widthRatio = miniMapCanvas.width / offscreenCanvas.width;
      const heightRatio = miniMapCanvas.height / offscreenCanvas.height;

      const leftside = ( focusX - zoomX ) * widthRatio;
      const rightside = ( zoomX * 2 ) * widthRatio;

      const topSide = ( focusY - zoomY ) * heightRatio;
      const bottomSide = zoomY * 2 * heightRatio;

      miniMapContext.strokeRect( leftside, topSide, rightside, bottomSide );


      miniMapContext.stroke();

    }

    function getInverseColor(hex) {

      if ( hex === undefined ) {

        return ( '#aaaa22' );

      }

//      console.log(hex);

        // Remove # if present
        hex = hex.replace('#', '');

        // Parse RGB values
        const r = 255 - parseInt(hex.substr(0, 2), 16);
        const g = 255 - parseInt(hex.substr(2, 2), 16);
        const b = 255 - parseInt(hex.substr(4, 2), 16);

        // Convert back to hex
        return `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
    }


    function testMap( testNum ) {

      if ( testNum == 8 ) {
        document.getElementById('wizardMapDB').style.display = 'flex';
        return;
      }

      document.getElementById('textDisplayArea').value = document.getElementById('testText'+testNum).innerText;

      convertTextToObject();

      objectToOffscreen();

      offscreenToMiniMap();

      offscreenToDisplay();

    }

    function wizardMap( whichVersion ) {
      console.log(whichVersion);

      document.getElementById('textDisplayArea').value = document.getElementById('testText8').innerText;

      switch ( whichVersion ) {
        case 'e':
          break;

        case 'w':
          document.getElementById('textDisplayArea').value += '\nwalls: 3,4 3,5 4,3 4,4 4,5 4,8 4,9 5,4 5,5 5,8 5,9 5,10 6,3 6,4 6,8 6,9 7,3 7,4 7,5 7,8 7,9 8,3 8,4 8,7 8,8 8,9 9,3 9,4 9,8 9,9 10,2 10,3 10,4 10,7 10,8 11,3 11,4 11,7 11,8 11,9 12,7 12,8';
          break;

        case 'f':
          document.getElementById('textDisplayArea').value += '\nflame: 3,4 3,5 4,3 4,4 4,5 4,8 4,9 5,4 5,5 5,8 5,9 5,10 6,3 6,4 6,8 6,9 7,3 7,4 7,5 7,8 7,9 8,3 8,4 8,7 8,8 8,9 9,3 9,4 9,8 9,9 10,2 10,3 10,4 10,7 10,8 11,3 11,4 11,7 11,8 11,9 12,7 12,8';
          break;

        case 's':
          document.getElementById('textDisplayArea').value += '\nshadow: 3,4 3,5 4,3 4,4 4,5 4,8 4,9 5,4 5,5 5,8 5,9 5,10 6,3 6,4 6,8 6,9 7,3 7,4 7,5 7,8 7,9 8,3 8,4 8,7 8,8 8,9 9,3 9,4 9,8 9,9 10,2 10,3 10,4 10,7 10,8 11,3 11,4 11,7 11,8 11,9 12,7 12,8';
          break;

        case 'p':
          document.getElementById('textDisplayArea').value += '\npit: 3,4 3,5 4,3 4,4 4,5 4,8 4,9 5,4 5,5 5,8 5,9 5,10 6,3 6,4 6,8 6,9 7,3 7,4 7,5 7,8 7,9 8,3 8,4 8,7 8,8 8,9 9,3 9,4 9,8 9,9 10,2 10,3 10,4 10,7 10,8 11,3 11,4 11,7 11,8 11,9 12,7 12,8';
          break;
      }

      convertTextToObject();

      objectToOffscreen();

      offscreenToMiniMap();

      offscreenToDisplay();

      document.getElementById('wizardMapDB').style.display = 'none';


    }

    function hexAdjacent( x, y, f ) {

      f = ((f % 6) + 6) % 6;

        if ( x%2 ) {
            switch ( f ) {
              case 0:
                return { x: x, y: y-1 };
                break;
              case 1:
                return { x: x+1, y: y-1 };
                break;
              case 2:
                return { x: x+1, y: y };
                break;
              case 3:
                return { x: x, y: y+1 };
                break;
              case 4:
                return { x: x-1, y: y };
                break;
              case 5:
                return { x: x-1, y: y-1 };
                break;
            }
        } else {
            switch ( f ) {
              case 0:
                return { x: x, y: y-1 };
                break;
              case 1:
                return { x: x+1, y: y };
                break;
              case 2:
                return { x: x+1, y: y+1 };
                break;
              case 3:
                return { x: x, y: y+1 };
                break;
              case 4:
                return { x: x-1, y: y+1 };
                break;
              case 5:
                return { x: x-1, y: y };
                break;
            }
        }
    }

    function updateMiniMapSize(size = global.miniMapSize ) {
        const miniMapDiv = document.getElementById('miniMapDiv');
        const canvas = document.getElementById('miniMapCanvas');
        if (!miniMapDiv || !canvas) {
            console.error('Minimap elements not found');
            return;
        }

        // Get browser window dimensions
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;

        // Debug logging
//        console.log('Window dimensions:', windowWidth, 'x', windowHeight);
//        console.log('Minimap size setting:', size);

        // Check if window has dimensions
        if (windowWidth === 0 || windowHeight === 0) {
            console.warn('Window has no dimensions');
            return;
        }

        // Get map dimensions - try multiple sources
        let mapWidth, mapHeight;
        if (offscreenCanvas && offscreenCanvas.width && offscreenCanvas.height) {
            mapWidth = offscreenCanvas.width;
            mapHeight = offscreenCanvas.height;
//            console.log('Using offscreenCanvas dimensions:', mapWidth, 'x', mapHeight);
        } else if (map && map.width && map.height) {
            mapWidth = map.width;
            mapHeight = map.height;
//            console.log('Using map dimensions:', mapWidth, 'x', mapHeight);
        } else {
            console.error('No valid map dimensions found');
            return;
        }

        // Define size configurations based on window dimensions
        const sizeConfigs = {
            small: {
                base: Math.min(windowWidth, windowHeight) * 0.25,
                min: Math.min(windowWidth, windowHeight) * 0.10,
                max: Math.min(windowWidth, windowHeight) * 0.40
            },
            medium: {
                base: Math.min(windowWidth, windowHeight) * 0.35,
                min: Math.min(windowWidth, windowHeight) * 0.20,
                max: Math.min(windowWidth, windowHeight) * 0.50
            },
            large: {
                base: Math.min(windowWidth, windowHeight) * 0.45,
                min: Math.min(windowWidth, windowHeight) * 0.30,
                max: Math.min(windowWidth, windowHeight) * 0.60
            }
        };

        // Get the configuration for the requested size
        const config = sizeConfigs[size] || sizeConfigs.medium;
        const baseSize = config.base;
        const minSize = config.min;
        const maxSize = config.max;

//        console.log(`Size config for ${size}:`,
//            `base=${Math.round(baseSize)}px, min=${Math.round(minSize)}px, max=${Math.round(maxSize)}px`);

        const mapAspectRatio = mapWidth / mapHeight;
        let miniMapWidth, miniMapHeight;

        if (mapAspectRatio > 1) {
            // Wider than tall
            miniMapWidth = Math.min(Math.max(baseSize, minSize), maxSize);
            miniMapHeight = miniMapWidth / mapAspectRatio;
        } else {
            // Taller than wide
            miniMapHeight = Math.min(Math.max(baseSize, minSize), maxSize);
            miniMapWidth = miniMapHeight * mapAspectRatio;
        }

        // Ensure minimum size for extreme aspect ratios
        if (miniMapWidth < minSize) {
            miniMapWidth = minSize;
            miniMapHeight = minSize / mapAspectRatio;
        }
        if (miniMapHeight < minSize) {
            miniMapHeight = minSize;
            miniMapWidth = minSize * mapAspectRatio;
        }

//        console.log('Calculated minimap size:', Math.round(miniMapWidth), 'x', Math.round(miniMapHeight));

        // Apply styles to DIV (this creates the border container)
        miniMapDiv.style.width = miniMapWidth + 'px';
        miniMapDiv.style.height = miniMapHeight + 'px';

        // Apply dimensions to canvas (this should fill the DIV)
        canvas.width = miniMapWidth;
        canvas.height = miniMapHeight;

    }

    function groupBy( order ) {
      global.groupBy = order;
      saveSettings();
//      localStorage.setItem('HexWrightSettings',JSON.stringify(global));
    }


    //begin icon positioning

    // Icon Position Handler Functions
    function setHorizontalTopLeft() {

        operationOpener.style.top = '2%';
        operationOpener.style.left = '2%';
        operationOpener.style.transform = 'translate(0, 0)';

        toolOpener.style.top = '2%';
        toolOpener.style.left = '2%';
        toolOpener.style.transform = 'translate(5vw, 0)';

        helpOpener.style.top = '2%';
        helpOpener.style.left = '2%';
        helpOpener.style.transform = 'translate(10vw, 0)';

        helpMenu.style.top = '7%';
        helpMenu.style.left = '2%';
        helpMenu.style.bottom = 'auto';
        helpMenu.style.right = 'auto';

        toolMenu.style.top = '7%';
        toolMenu.style.left = '2%';
        toolMenu.style.bottom = 'auto';
        toolMenu.style.right = 'auto';

        operationMenu.style.top = '7%';
        operationMenu.style.left = '2%';
        operationMenu.style.bottom = 'auto';
        operationMenu.style.right = 'auto';

    }

    function setVerticalTopLeft() {

        operationOpener.style.top = '2%';
        operationOpener.style.left = '2%';
        operationOpener.style.transform = 'translate(0, 0)';

        toolOpener.style.top = '2%';
        toolOpener.style.left = '2%';
        toolOpener.style.transform = 'translate(0, 6vh)';

        helpOpener.style.top = '2%';
        helpOpener.style.left = '2%';
        helpOpener.style.transform = 'translate(0, 12vh)';

        helpMenu.style.top = '2%';
        helpMenu.style.left = '5%';
        helpMenu.style.bottom = 'auto';
        helpMenu.style.right = 'auto';

        toolMenu.style.top = '2%';
        toolMenu.style.left = '5%';
        toolMenu.style.bottom = 'auto';
        toolMenu.style.right = 'auto';

        operationMenu.style.top = '2%';
        operationMenu.style.left = '5%';
        operationMenu.style.bottom = 'auto';
        operationMenu.style.right = 'auto';

    }

    function setHorizontalTopRight() {

        operationOpener.style.top = '2%';
        operationOpener.style.left = '2%';
        operationOpener.style.transform = 'translate(calc(96vw - 100%), 0)';

        toolOpener.style.top = '2%';
        toolOpener.style.left = '2%';
        toolOpener.style.transform = 'translate(calc(91vw - 100%), 0)';

        helpOpener.style.top = '2%';
        helpOpener.style.left = '2%';
        helpOpener.style.transform = 'translate(calc(86vw - 100%), 0)';

        helpMenu.style.top = '7%';
        helpMenu.style.right = '2%';
        helpMenu.style.bottom = 'auto';
        helpMenu.style.left = 'auto';

        toolMenu.style.top = '7%';
        toolMenu.style.right = '2%';
        toolMenu.style.bottom = 'auto';
        toolMenu.style.left = 'auto';

        operationMenu.style.top = '7%';
        operationMenu.style.right = '2%';
        operationMenu.style.bottom = 'auto';
        operationMenu.style.left = 'auto';

    }

    function setVerticalTopRight() {

        operationOpener.style.top = '2%';
        operationOpener.style.left = '2%';
        operationOpener.style.transform = 'translate(calc(96vw - 100%), 0)';

        toolOpener.style.top = '2%';
        toolOpener.style.left = '2%';
        toolOpener.style.transform = 'translate(calc(96vw - 100%), 6vh)';

        helpOpener.style.top = '2%';
        helpOpener.style.left = '2%';
        helpOpener.style.transform = 'translate(calc(96vw - 100%), 12vh)';

        helpMenu.style.top = '2%';
        helpMenu.style.right = '5%';
        helpMenu.style.bottom = 'auto';
        helpMenu.style.left = 'auto';

        toolMenu.style.top = '2%';
        toolMenu.style.right = '5%';
        toolMenu.style.bottom = 'auto';
        toolMenu.style.left = 'auto';

        operationMenu.style.top = '2%';
        operationMenu.style.right = '5%';
        operationMenu.style.bottom = 'auto';
        operationMenu.style.left = 'auto';

    }

    function setThreeCorners() {
        console.log('Setting icons to three corners');
        operationOpener.style.top = '2%';
        operationOpener.style.left = '2%';
        operationOpener.style.transform = 'translate(0, 0)';

        toolOpener.style.top = '2%';
        toolOpener.style.left = '2%';
        toolOpener.style.transform = 'translate(calc(96vw - 100%), 0)';

        helpOpener.style.top = '2%';
        helpOpener.style.left = '2%';
        helpOpener.style.transform = 'translate( calc(96vw - 100%), calc(96vh - 100%))';

        helpMenu.style.top = 'auto';
        helpMenu.style.left = 'auto';
        helpMenu.style.bottom = '5%';
        helpMenu.style.right = '3%';

        toolMenu.style.top = '5%';
        toolMenu.style.right = '5%';
        toolMenu.style.bottom = 'auto';
        toolMenu.style.left = 'auto';

        operationMenu.style.top = '2%';
        operationMenu.style.right = 'auto';
        operationMenu.style.bottom = 'auto';
        operationMenu.style.left = '3%';

    }

    function setHorizontalBottomLeft() {
        console.log('Setting icons to horizontal bottom-left');
        operationOpener.style.top = '2%';
        operationOpener.style.left = '2%';
        operationOpener.style.transform = 'translate(0, calc(96vh - 100%))';

        toolOpener.style.top = '2%';
        toolOpener.style.left = '2%';
        toolOpener.style.transform = 'translate(5vw, calc(96vh - 100%))';

        helpOpener.style.top = '2%';
        helpOpener.style.left = '2%';
        helpOpener.style.transform = 'translate(10vw, calc(96vh - 100%))';

        helpMenu.style.top = 'auto';
        helpMenu.style.right = 'auto';
        helpMenu.style.bottom = '5%';
        helpMenu.style.left = '5%';

        toolMenu.style.top = 'auto';
        toolMenu.style.right = 'auto';
        toolMenu.style.bottom = '5%';
        toolMenu.style.left = '5%';

        operationMenu.style.top = 'auto';
        operationMenu.style.right = 'auto';
        operationMenu.style.bottom = '5%';
        operationMenu.style.left = '5%';

    }


        // Main handler function
    function handleIconPositionChange(event) {
        const selectedValue = event.target.value;

        global.icons = selectedValue;
        saveSettings()
//        localStorage.setItem('HexWrightSettings',JSON.stringify(global));

        switch(selectedValue) {
            case 'horizontal-top-left':
                setHorizontalTopLeft();
                break;
            case 'vertical-top-left':
                setVerticalTopLeft();
                break;
            case 'horizontal-top-right':
                setHorizontalTopRight();
                break;
            case 'vertical-top-right':
                setVerticalTopRight();
                break;
            case 'three-corners':
                setThreeCorners();
                break;
            case 'horizontal-bottom-left':
                setHorizontalBottomLeft();
                break;
            default:
                console.warn('Unknown icon position:', selectedValue);
        }
    }

    // Set up event listeners when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
        // Get all radio buttons for icon position
        const iconPositionRadios = document.querySelectorAll('input[name="iconPosition"]');

        // Add event listener to each radio button
        iconPositionRadios.forEach(radio => {
            radio.addEventListener('change', handleIconPositionChange);
        });
    });



    //end icon positioning

// hi res export coded


// Export Dialog JavaScript Functions

function showExportDialog() {
    const overlay = document.querySelector('.exportDialogOverlay');
    if (overlay) {
        overlay.style.display = 'flex';
        updateFileSizeEstimate();
    }
}

function hideExportDialog() {
    const overlay = document.querySelector('.exportDialogOverlay');
    if (overlay) {
        overlay.style.display = 'none';
    }
}

function initializeExportDialog() {
    // Set default values
    document.querySelector('input[name="exportDpi"][value="300"]').checked = true;
    document.querySelector('input[name="exportFormat"][value="png"]').checked = true;
    document.querySelector('#exportQualitySlider').value = 90;
    document.querySelector('#exportCustomDpi').disabled = true;
    document.querySelector('#exportQualitySlider').disabled = true;

    // Add event listeners for DPI selection
    document.querySelectorAll('input[name="exportDpi"]').forEach(radio => {
        radio.addEventListener('change', function() {
            const customDpiInput = document.querySelector('#exportCustomDpi');
            customDpiInput.disabled = this.value !== 'custom';
            if (this.value === 'custom') {
                customDpiInput.focus();
            }
            updateFileSizeEstimate();
        });
    });

    // Add event listeners for format selection
    document.querySelectorAll('input[name="exportFormat"]').forEach(radio => {
        radio.addEventListener('change', function() {
            const qualitySlider = document.querySelector('#exportQualitySlider');
            qualitySlider.disabled = this.value !== 'jpg';
            updateFileSizeEstimate();
        });
    });

    // Add event listener for quality slider
    document.querySelector('#exportQualitySlider').addEventListener('input', function() {
        document.querySelector('#exportQualityValue').textContent = this.value + '%';
        updateFileSizeEstimate();
    });

    // Add event listener for custom DPI input
    document.querySelector('#exportCustomDpi').addEventListener('input', updateFileSizeEstimate);

    // Initialize quality display
    document.querySelector('#exportQualityValue').textContent = '90%';
}

function saveSettings() {

  localStorage.setItem('HexWrightSettings',JSON.stringify(global));
//  console.log(global.currentTool);
}

function beforeGoodbye() {

//  console.log('beforeGoodbye called, privacy:', global.privacy);


    if ( global.privacy == 2 ) {

      localStorage.setItem('HexWrightWorking', document.getElementById("textDisplayArea").value );

    }

//    console.log('->' + global.currentTool);
//    console.log(localStorage.HexWrightSettings);

}


function updateFileSizeEstimate() {
    const dpiRadio = document.querySelector('input[name="exportDpi"]:checked');
    const formatRadio = document.querySelector('input[name="exportFormat"]:checked');
    const customDpiInput = document.querySelector('#exportCustomDpi');
    const qualitySlider = document.querySelector('#exportQualitySlider');
    const fileSizeInfo = document.querySelector('.exportFileSizeInfo');

    if (!dpiRadio || !formatRadio) return;

    // Get DPI value
    let dpi = parseInt(dpiRadio.value);
    if (dpiRadio.value === 'custom') {
        dpi = parseInt(customDpiInput.value) || 300;
    }

    // Assuming canvas dimensions - you'll need to replace with actual canvas size
    const canvasWidth = 1000; // Replace with your actual canvas width
    const canvasHeight = 800;  // Replace with your actual canvas height

    // Calculate pixel dimensions at target DPI
    const pixelWidth = Math.round(canvasWidth * dpi / 72);
    const pixelHeight = Math.round(canvasHeight * dpi / 72);

    // Estimate file size
    let estimatedSize;
    if (formatRadio.value === 'png') {
        // PNG: roughly 3-4 bytes per pixel for full color
        estimatedSize = pixelWidth * pixelHeight * 3.5;
    } else {
        // JPG: varies greatly with quality
        const quality = parseInt(qualitySlider.value);
        const compressionFactor = 0.1 + (quality / 100) * 0.9; // 10% to 100% of PNG size
        estimatedSize = pixelWidth * pixelHeight * 3 * compressionFactor;
    }

    // Format file size
    let sizeText;
    if (estimatedSize < 1024) {
        sizeText = Math.round(estimatedSize) + ' bytes';
    } else if (estimatedSize < 1024 * 1024) {
        sizeText = Math.round(estimatedSize / 1024) + ' KB';
    } else {
        sizeText = (estimatedSize / (1024 * 1024)).toFixed(1) + ' MB';
    }

    fileSizeInfo.innerHTML = `
        <strong>Export Size:</strong> ${pixelWidth} × ${pixelHeight} pixels<br>
        <strong>Estimated File Size:</strong> ${sizeText}
    `;
}

  function exportHighResImage() {
      const dpiRadio = document.querySelector('input[name="exportDpi"]:checked');
      const formatRadio = document.querySelector('input[name="exportFormat"]:checked');
      const customDpiInput = document.querySelector('#exportCustomDpi');
      const qualitySlider = document.querySelector('#exportQualitySlider');

      if (!dpiRadio || !formatRadio) {
          alert('Please select both DPI and format options.');
          return;
      }

      // Get DPI value
      let dpi = parseInt(dpiRadio.value);
      if (dpiRadio.value === 'custom') {
          dpi = parseInt(customDpiInput.value);
          if (!dpi || dpi < 1 || dpi > 3000) {
              alert('Please enter a valid DPI value (1-3000).');
              return;
          }
      }

      // Get your canvas element - replace with your actual canvas
      const canvas = document.querySelector('#offscreenCanvas'); // Replace with your canvas selector
      if (!canvas) {
          alert('Canvas not found.');
          return;
      }

      // Calculate scale factor
      const scaleFactor = dpi / 72;

      // Create a temporary high-resolution canvas
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');

      // Set dimensions for high-res export
      tempCanvas.width = canvas.width * scaleFactor;
      tempCanvas.height = canvas.height * scaleFactor;

      // Scale the context for high DPI
      tempCtx.scale(scaleFactor, scaleFactor);

      // Draw your content to the temporary canvas
      // This is where you'll need to redraw your map content at high resolution
      // For example, if you have a function that draws your map:
      // drawMapContent(tempCtx, canvas.width, canvas.height);

      // For now, we'll just copy the existing canvas content
      tempCtx.drawImage(canvas, 0, 0);

      // Export the image
      const format = formatRadio.value;
      let mimeType, quality;

      if (format === 'png') {
          mimeType = 'image/png';
          quality = undefined;
      } else {
          mimeType = 'image/jpeg';
          quality = parseInt(qualitySlider.value) / 100;
      }

      // Convert to blob and download
      tempCanvas.toBlob(function(blob) {
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `map_export_${dpi}dpi.${format}`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);

          // Hide the dialog
          hideExportDialog();
      }, mimeType, quality);
  }

  // Initialize when DOM is ready
  document.addEventListener('DOMContentLoaded', function() {
      initializeExportDialog();
  });

  // Event listeners for dialog buttons
  document.addEventListener('click', function(e) {
      if (e.target.classList.contains('exportBtnCancel')) {
          hideExportDialog();
      } else if (e.target.classList.contains('exportBtnSave')) {
          exportHighResImage();
      }
  });


// end hi res export code

    function showPrivacyDialog() {
         document.getElementById('privacyOverlay').style.display = 'flex';
     }

     function setPrivacy( newSetting ) {

       global.privacy = newSetting;
       let whichButton = null;

       switch ( newSetting ) {

         case 0:
          localStorage.removeItem('HexWrightSettings');
          localStorage.removeItem('HexWrightWorking');

           whichButton = Array.from(document.querySelectorAll('.mapInfoButton'))
              .find(btn => btn.textContent.trim() === 'Save Nothing');
          whichButton.classList.add('selected');

          whichButton = Array.from(document.querySelectorAll('.mapInfoButton'))
              .find(btn => btn.textContent.trim() === 'Save Settings');
          whichButton.classList.remove('selected');

          whichButton = Array.from(document.querySelectorAll('.mapInfoButton'))
              .find(btn => btn.textContent.trim() === 'Save My Work');
          whichButton.classList.remove('selected');

          break;

        case 1:
         localStorage.removeItem('HexWrightWorking');
         global.seenPrivacy='yes';

         saveSettings();
//         localStorage.setItem('HexWrightSettings',JSON.stringify(global));

          whichButton = Array.from(document.querySelectorAll('.mapInfoButton'))
             .find(btn => btn.textContent.trim() === 'Save Nothing');
         whichButton.classList.remove('selected');

        whichButton = Array.from(document.querySelectorAll('.mapInfoButton'))
             .find(btn => btn.textContent.trim() === 'Save Settings');
         whichButton.classList.add('selected');

        whichButton = Array.from(document.querySelectorAll('.mapInfoButton'))
             .find(btn => btn.textContent.trim() === 'Save My Work');
         whichButton.classList.remove('selected');

         break;

       case 2:
         global.seenPrivacy='yes';

//         localStorage.setItem('HexWrightSettings',JSON.stringify(global));
        saveSettings();

          whichButton = Array.from(document.querySelectorAll('.mapInfoButton'))
             .find(btn => btn.textContent.trim() === 'Save Nothing');
         whichButton.classList.remove('selected');

        whichButton = Array.from(document.querySelectorAll('.mapInfoButton'))
             .find(btn => btn.textContent.trim() === 'Save Settings');
         whichButton.classList.remove('selected');

        whichButton = Array.from(document.querySelectorAll('.mapInfoButton'))
             .find(btn => btn.textContent.trim() === 'Save My Work');
         whichButton.classList.add('selected');


         break;

       }

       document.getElementById('privacyOverlay').style.display = 'none';

     }


     function setMiniMapSmall() {
         updateMiniMapSize('small');
         document.querySelector('input[name="miniMapSize"][value="small"]').checked = true;
         global.miniMapSize='small';
//         localStorage.setItem('HexWrightSettings',JSON.stringify(global));
          saveSettings()
         offscreenToMiniMap();
     }

     function setMiniMapMedium() {
         updateMiniMapSize('medium');
         document.querySelector('input[name="miniMapSize"][value="medium"]').checked = true;
         global.miniMapSize='medium';
         saveSettings()
//         localStorage.setItem('HexWrightSettings',JSON.stringify(global));
         offscreenToMiniMap();
     }

     function setMiniMapLarge() {
         updateMiniMapSize('large');
         document.querySelector('input[name="miniMapSize"][value="large"]').checked = true;
         global.miniMapSize='large';
         saveSettings()
//         localStorage.setItem('HexWrightSettings',JSON.stringify(global));
         offscreenToMiniMap();
     }


    function toggleMiniMap() {
        const miniMapDiv = document.getElementById('miniMapDiv');
        if (miniMapDiv.style.opacity === '0') {
            miniMapDiv.style.opacity = '1';
            document.getElementById('toolOpener').style.top = '22%';
        } else {
            miniMapDiv.style.opacity = '0';
            document.getElementById('toolOpener').style.top = '2%';
        }
    }

    function miniMapMove( event ) {

      if ( event.buttons%2 == 1 ) {

        miniMapClick( event );

      }

    }

    function miniMapClick( event ) {

      focusX = ( event.offsetX / miniMapCanvas.width ) * offscreenCanvas.width;

      focusY = ( event.offsetY / miniMapCanvas.height ) * offscreenCanvas.height;

      offscreenToDisplay();

    }


    function toggleDots() {

      const dotToggle = document.getElementById('mapInfoShowDots');
      dotToggle.checked = !dotToggle.checked;
      // Trigger change event if you have listeners
//      dotToggle.dispatchEvent(new Event('change'));

      map.showDots = ( dotToggle.checked ? 'yes' : 'no' );
//      console.log(map.showDots);

      convertObjectToText();
      objectToOffscreen();
      offscreenToMiniMap();
      offscreenToDisplay();

      global.changed = 'yes';

    }

    function toggleTexture() {

      const textureToggle = document.getElementById('mapInfoTexture');
      textureToggle.checked = !textureToggle.checked;
      // Trigger change event if you have listeners
//      textureToggle.dispatchEvent(new Event('change'));

      map.Texture = ( textureToggle.checked ? 'yes' : 'no' );

      convertObjectToText();
      objectToOffscreen();
      offscreenToMiniMap();
      offscreenToDisplay();

      global.changed = 'yes';

    }

    function toggleHandDrawn() {

      const handDrawnToggle = document.getElementById('mapInfoHandDrawn');
      handDrawnToggle.checked = !handDrawnToggle.checked;
      // Trigger change event if you have listeners
      handDrawnToggle.dispatchEvent(new Event('change'));


      map.handDrawn = ( handDrawnToggle.checked ? 'yes' : 'no' );

      convertObjectToText();
      objectToOffscreen();
      offscreenToMiniMap();
      offscreenToDisplay();

      global.changed = 'yes';

    }


    function toggleHexNumbers() {

      const hexToggle = document.getElementById('mapInfoShowHex');
      hexToggle.checked = !hexToggle.checked;
      // Trigger change event if you have listeners
      hexToggle.dispatchEvent(new Event('change'));

      map.showHexNumbers = ( hexToggle.checked ? 'yes' : 'no' );

      convertObjectToText();
      objectToOffscreen();
      offscreenToMiniMap();
      offscreenToDisplay();

      global.changed = 'yes';

    }


    function keyDown() {

      const tag = event.target.tagName.toLowerCase();

      if (tag === 'input' || tag === 'textarea' || event.target.isContentEditable) {
        // Let the keystroke go through; user is typing
        return;
      }

      if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) {
          return;
      }


//      console.log(event.key);

      switch (event.key) {

        case 'Enter':
          if ( paletteDiv.style.display != 'none' ) {
            saveColors();
          }
          break;

        case 'p':
          cycleMiniMapPosition();
          break;

        case 'c':
          openPalette();
          break;

        case 'i':
          openInfo();
          break;

        case 'm':
          toggleMiniMap();
          break;

        case 'd':
          toggleDots();
          break;

        case 'n':
          toggleHexNumbers();
          break;

        case 'a':
          displayAllMap();
          break;

        case 't':
          displayAllText();
          break;

        case 's':
          displaySplit();
          break;

        case '?':
        case '/':
          showHelp();
          break;

        case ';':
          showSettings();
          break;

        case 'Escape':
          paletteDiv.style.display='none';
          document.getElementById('mapInfoDialogOverlay').style.display = 'none';
          break;

        case '1':
          setTool('offboard');
          break;

        case '2':
          setTool('clear');
          break;

        case '3':
          setTool('wall hex');
          break;

        case '4':
          setTool('pit');
          break;

        case '5':
          setTool('paths');
          break;

        case '6':
          setTool('trapdoor');
          break;

        case '7':
          setTool('debris');
          break;

        case '8':
          setTool('water');
          break;

        case '9':
          setTool('barricade');
          break;

        case '0':
          setTool('shadow');
          break;

        case '-':
          setTool('fire');
          break;

        case '=':
          setTool('body');
          break;

        case '`':
          setTool('lava');
          break;

        case 'r':
          setTool('stone');
          break;

        case 'q':
          setTool('column');
          break;

        case 'f':
          setTool('table');
          break;

        case 'g':
          setTool('altar');
          break;

        case 'j':
          setTool('pentacle');
          break;

        case 'o':
          setTool('tar');
          break;

        case 'u':
          setTool('sticky');
          break;

        case 'h':
          setTool('slippery');
          break;

        case 'l':
          setTool('lighter');
          break;

        case 'k':
          setTool('darker');
          break;

        case 'y':
          setTool('star');
          break;

        case 'b':
          setTool('bridge');
          break;

        case '[':
          setMiniMapSmall();
          break;

        case ']':
          setMiniMapMedium();
          break;

        case '\\':
          setMiniMapLarge();
          break;

      }
    }


  </script>


  <body onload='initApp()' onkeydown="keyDown(event)">

    <input type="file" id="fileInput" style='display: none'>

    <div id='miniMapDiv'>

    <canvas id='miniMapCanvas' onclick='miniMapClick(event)' onwheel="zoom(event)" onmousemove='miniMapMove(event)' ></canvas>

    </div>


    <div id="helpOpener" onmouseover="showDiv( helpMenu )">?</div>

    <div class='menuDiv' id="helpMenu" onmouseleave='hideDiv( helpMenu )'>
      <span class='menuItemSpan' onclick='showHelp("general")'>General</span><br>
      <span class='menuItemSpan' onclick='showHelp("operations")'>Operations</span><br>
      <span class='menuItemSpan' onclick='showHelp("keys")'>Keys</span><br>
      <span class='menuItemSpan' onclick='showHelp("terrain")'>Terrain Tools</span><br>
      <span class='menuItemSpan' onclick='showHelp("settings")'>Settings</span><br>
      <span class='menuItemSpan' onclick='showHelp("about")'>About HexWright</span><br>
    </div>

    <div id='toolOpener' onmouseover="showDiv( toolMenu )">
      <div id='toolOpenerInner'>
        clear
      </div>
    </div>

    <div class='menuDiv' id="toolMenu" onmouseleave='hideDiv( toolMenu )'>
      <span class='menuItemSpan' onclick='setTool("offboard")'>offboard (1)</span><br>
      <span class='menuItemSpan' onclick='setTool("clear")'>clear (2)</span><br>
      <span class='menuItemSpan' onclick='setTool("wall hex")'>wall hex (3)</span><br>
      <span class='menuItemSpan' onclick='setTool("pit")'>pit (4)</span><br>
      <span class='menuItemSpan' onclick='setTool("paths")'>path (5)</span><br>
      <span class='menuItemSpan' onclick='setTool("trapdoor")'>trap door(6)</span><br>
      <span class='menuItemSpan' onclick='setTool("debris")'>debris (7)</span><br>
      <span class='menuItemSpan' onclick='setTool("water")'>water (8)</span><br>
      <span class='menuItemSpan' onclick='setTool("barricade")'>barricade (9)</span><br>
      <span class='menuItemSpan' onclick='setTool("shadow")'>shadow (0)</span><br>
      <span class='menuItemSpan' onclick='setTool("fire")'>fire (-)</span><br>
      <span class='menuItemSpan' onclick='setTool("body")'>body(=)</span><br>
      <span class='menuItemSpan' onclick='setTool("lava")'>lava/acid(~)</span><br>
      <span class='menuItemSpan' onclick='setTool("stone")'>stone(r)</span><br>
      <span class='menuItemSpan' onclick='setTool("column")'>column or tree(q)</span><br>
      <span class='menuItemSpan' onclick='setTool("table")'>wood table(f)</span><br>
      <span class='menuItemSpan' onclick='setTool("altar")'>stone altar(g)</span><br>
      <span class='menuItemSpan' onclick='setTool("pentacle")'>pentacle(j)</span><br>
      <span class='menuItemSpan' onclick='setTool("tar")'>tar pit(o)</span><br>
      <span class='menuItemSpan' onclick='setTool("bridge")'>bridge(b)</span><br>
      <span class='menuItemSpan' onclick='setTool("star")'>star(y)</span><br>
      <span class='menuItemSpan' onclick='setTool("sticky")'>sticky(u)</span><br>
      <span class='menuItemSpan' onclick='setTool("slippery")'>slippery(h)</span><br>
      <span class='menuItemSpan' onclick='setTool("lighter")'>lighter(l)</span><br>
      <span class='menuItemSpan' onclick='setTool("darker")'>darker(k)</span><br>
    </div>

    <div id='operationOpener' onmouseover="showDiv( operationMenu )">
      <img src='art/menuIcon.png'>
    </div>

    <div class='menuDiv' id='operationMenu' onmouseleave='hideDiv( operationMenu )'>

      <span class='menuItemSpan' onclick="openInfo()">Map Info (i)</span><br>
      <span class='menuItemSpan' onclick="displayAllMap()">All Map (a)</span><br>
      <span class='menuItemSpan' onclick="displayAllText()">All Text (t)</span><br>
      <span class='menuItemSpan' onclick="displaySplit()">Split Map/Text (s)</span><br>
      <span class='menuItemSpan' onclick='toggleHelpDiv()'>Help (?)</span><br>
      <span class='menuItemSpan' onclick='saveToDownloads()'>Save To Downloads</span><br>
      <span class='menuItemSpan' onclick='loadMap()'>Load from Disk</span><br>
      <span class='menuItemSpan' onclick='showExportDialog()'>Save Hi Res Image</span><br>
      <span class='menuItemSpan' onclick='showSettings()'>Settings (;)</span><br>
      <span class='menuItemSpan' onclick='openPalette()'>Colors(c)</span><br>
      <span class='menuItemSpan' onclick='showPrivacyDialog()'>Privacy</span><br>

    </div>



    <div id='mapDisplayDiv'>

      <canvas id="displayCanvas" onwheel="zoom(event)" onmousedown='displayMouseDown(event)' onmousemove='displayMouseMove(event)' onmouseup='displayMouseUp(event)'></canvas>

    </div>


    <textarea id='textDisplayArea' oninput='textChange()'>
    Name: Basic Map
    Description: A basic map showing all features.
    Height: 9
    Width: 12
    Walls: 3,4; 7,8; 1,1
    Water: 0,0 8,0 8,4 7,3 8,3 8,5 9,6 7,1 7,2 8,1
    rock 7,2
    8,1 stone
    5,0 pit trapdoor
    5,1  trapdoor

    bridge from 7,5 9,4
    bridge 5,6 5,8

    5,2 pit
    columns: 6,3
    6,4 column
    offboard 9,8 10,7 11,7 10,8 11,8 8,8

    1,3 debris
    4,4 wall
    wall 6,1
    lava 4,2
    path 0,5 1,6 2,6 3,6 4,6 5,6 6,5 7,5 7,6 8,6 9,5
    path 9,4 10,3 10,2 11,2




    </textarea>

    <div id='bigMapImage'>
      big map image
    </div>


    <div class="mapInfoDialogOverlay" id="privacyOverlay">
        <div class="mapInfoDialog privacyDialog">
            <div class="mapInfoDialogContent">
                <h2 class="mapInfoDialogTitle">Privacy & Data Settings</h2>

                <div class="privacyText">
                    <p>In this world of every-changing and ever-so-effective privacy legislation it’s impossible for an independent developer to know what the requirements are everywhere, so even though this app does not collect, store, or transmit any personal data we still need to have this talk.</p>

                    <p>This app does not use cookies. This app does not send any data of any kind back to the server. It does not collect, store, or transmit any personal data, not even the map you are working on. No third parties can see anything.</p>

                    <p>This app can, at your option (below), save your settings or your work inside your browser with something called localStorage. This won’t work on public computer</p>
                </div>

                <div class="privacyContent">
                <button class="mapInfoButton" onclick="setPrivacy(0)">Save Nothing</button>
                <div class="privacyButtonExplanation">
                    The app will remember nothing. You must save your work to disk, or copy the text and paste it somewhere or all is lost. You will see this dialog every time you start.
                </div>

                <button class="mapInfoButton" onclick="setPrivacy(1)">Save Settings</button>
                <div class="privacyButtonExplanation">
                    The app will remember how you like the interface and that you have seen this information. Your work will not be saved unless you save it as above.
                </div>

                <button class="mapInfoButton" onclick="setPrivacy(2)">Save My Work</button>
                <div class="privacyButtonExplanation">
                    The app will remember how you like the interface set up, and your work will be saved locally in the browser every twenty seconds if there has been a change. When you come back to the app to work on your map everything will be like you left it.
                </div>

                </div>
            </div>
        </div>
    </div>




    <div class='dialogOverlay' id='colorDialogOverlay' onclick="if(event.target === this)  document.getElementById('colorDialogOverlay').style.display='none'">

      <div id="paletteDiv">
          <div class="palleteDivLeft">
              <div class="panel-title">Colors</div>
              <div class="color-picker-group">
                  <div class="color-picker-item">
                      <label for="offboardColor">Offboard:</label>
                      <input type="color" id="offboardColor" value="#ff6b6b" onchange='updateColorFromPicker("offboard")'>
                      <input type="text" id="offboardHex" value="#ff6b6b" maxlength="7" onchange='updateColorFromHex("offboard")'>
                  </div>
                  <div class="color-picker-item">
                      <label for="clearColor">Clear:</label>
                      <input type="color" id="clearColor" value="#4ecdc4" onchange='updateColorFromPicker("clear")'>
                      <input type="text" id="clearHex" value="#4ecdc4" maxlength="7" onchange='updateColorFromHex("clear")'>
                  </div>
                  <div class="color-picker-item">
                      <label for="linesColor">Lines:</label>
                      <input type="color" id="linesColor" value="#45b7d1" onchange='updateColorFromPicker("lines")'>
                      <input type="text" id="linesHex" value="#45b7d1" maxlength="7" onchange='updateColorFromHex("lines")'>
                  </div>
                  <div class="color-picker-item">
                      <label for="wallsColor">Walls:</label>
                      <input type="color" id="wallsColor" value="#96ceb4" onchange='updateColorFromPicker("walls")'>
                      <input type="text" id="wallsHex" value="#96ceb4" maxlength="7" onchange='updateColorFromHex("walls")'>
                  </div>
                  <div class="color-picker-item">
                      <label for="waterColor">Water:</label>
                      <input type="color" id="waterColor" value="#ffeaa7" onchange='updateColorFromPicker("water")'>
                      <input type="text" id="waterHex" value="#ffeaa7" maxlength="7" onchange='updateColorFromHex("water")'>
                  </div>
                  <div class="color-picker-item">
                      <label for="pathsColor">Path:</label>
                      <input type="color" id="pathsColor" value="#dda0dd" onchange='updateColorFromPicker("paths")'>
                      <input type="text" id="pathsHex" value="#dda0dd" maxlength="7" onchange='updateColorFromHex("paths")'>
                  </div>
                  <div class="color-picker-item">
                      <label for="columnsColor">Columns:</label>
                      <input type="color" id="columnsColor" value="#fab1a0" onchange='updateColorFromPicker("columns")'>
                      <input type="text" id="columnsHex" value="#fab1a0" maxlength="7" onchange='updateColorFromHex("columns")'>
                  </div>
                  <div class="color-picker-item">
                      <label for="lavaColor">Lava/Acid:</label>
                      <input type="color" id="lavaColor" value="#aa0000" onchange='updateColorFromPicker("lava")'>
                      <input type="text" id="lavaHex" value="#fab1a0" maxlength="7" onchange='updateColorFromHex("lava")'>
                  </div>
                  <br>
                  <button class="niftyButton" onclick='saveColors()'>Save Changes</button>
                  <button class="niftyButton" onclick="document.getElementById('colorDialogOverlay').style.display='none'">Cancel</button>
              </div>        </div>

          <div class="palleteDivright">
              <div class="panel-title">Sample palettes</div>
              <div class="palleteDivButtons">
                  <button class="niftyButton" onclick='loadStandardPalette(0)'>Melee</button>
                  <button class="niftyButton" onclick='loadStandardPalette(1)'>Wizard</button>
                  <button class="niftyButton" onclick='loadStandardPalette(2)'>Cavern</button>
                  <button class="niftyButton" onclick='loadStandardPalette(3)'>Burrow</button>
                  <button class="niftyButton" onclick='loadStandardPalette(4)'>Wild Lands</button>
                  <button class="niftyButton" onclick='loadStandardPalette(5)'>Desert</button>
                  <button class="niftyButton" onclick='loadStandardPalette(6)'>Frozen</button>
                  <button class="niftyButton" onclick='loadStandardPalette(7)'>Volcano</button>
                  <button class="niftyButton" onclick='loadStandardPalette(8)'>Woods</button>
                  <button class="niftyButton" onclick='loadStandardPalette(9)'>Swamp</button>
                  <button class="niftyButton" onclick='loadStandardPalette(10)'>Black & White</button>
                  <button class="niftyButton" onclick='loadStandardPalette(11)'>Ethereal Plane</button>
              </div>

              <canvas id="paletteSampleCanvas" width="300" height="250"></canvas>
          </div>
      </div>
    </div>

<!--
    <div class="mapInfoDialogOverlay" id='mapInfoDialogOverlay' onclick="if(event.target === this) document.getElementById('mapInfoDialogOverlay').style.display = 'none';">
        <div class="mapInfoDialog">
            <div class="mapInfoDialogContent">
                <h2 class="mapInfoDialogTitle">Map Info</h2>

                <div class="mapInfoFormGroup">
                    <label for="mapInfoName" class="mapInfoLabel">Map Name:</label>
                    <input type="text" id="mapInfoName" class="mapInfoInput" placeholder="Enter map name...">
                </div>

                <div class="mapInfoFormRow">
                    <div class="mapInfoFormGroup">
                        <label for="mapInfoWidth" class="mapInfoLabel">Width:</label>
                        <input type="text" id="mapInfoWidth" class="mapInfoInput" value="12">
                    </div>
                    <div class="mapInfoFormGroup">
                        <label for="mapInfoHeight" class="mapInfoLabel">Height:</label>
                        <input type="text" id="mapInfoHeight" class="mapInfoInput" value="9">
                    </div>
                </div>

                <div class="mapInfoFormGroup">
                    <label for="mapInfoDescription" class="mapInfoLabel">Description:</label>
                    <textarea id="mapInfoDescription" class="mapInfoTextarea mapInfoTextareaDescription" placeholder="Enter map description..."></textarea>
                </div>

                <div class="mapInfoFormRow">
                    <div class="mapInfoFormGroup">
                        <label class="mapInfoToggleLabel">
                            <input type="checkbox" id="mapInfoShowDots" class="mapInfoToggleInput">
                            <span class="mapInfoToggleSlider"></span>
                            <span class="mapInfoToggleText">Show Dots</span>
                        </label>
                    </div>

                    <div class="mapInfoFormGroup">
                        <label class="mapInfoToggleLabel">
                            <input type="checkbox" id="mapInfoShowHex" class="mapInfoToggleInput">
                            <span class="mapInfoToggleSlider"></span>
                            <span class="mapInfoToggleText">Show Hex Numbers</span>
                        </label>
                    </div>

                    <div class="mapInfoFormGroup">
                        <label class="mapInfoToggleLabel">
                            <input type="checkbox" id="mapInfoDecorations" class="mapInfoToggleInput">
                            <span class="mapInfoToggleSlider"></span>
                            <span class="mapInfoToggleText">Decorations</span>
                        </label>
                    </div>

                    <div class="mapInfoFormGroup">
                        <label class="mapInfoToggleLabel">
                            <input type="checkbox" id="mapInfoTexture" class="mapInfoToggleInput">
                            <span class="mapInfoToggleSlider"></span>
                            <span class="mapInfoToggleText">Texture!</span>
                        </label>
                    </div>

                    <div class="mapInfoFormGroup">
                        <label class="mapInfoToggleLabel">
                            <input type="checkbox" id="mapInfoHandDrawn" class="mapInfoToggleInput">
                            <span class="mapInfoToggleSlider"></span>
                            <span class="mapInfoToggleText">Hand-Drawn Lines</span>
                        </label>
                    </div>

                </div>

                <div class="mapInfoButtonGroup">
                    <button type="button" class="mapInfoButton mapInfoBtnCancel" onclick="document.getElementById('mapInfoDialogOverlay').style.display = 'none';">Cancel</button>
                    <button type="button" class="mapInfoButton mapInfoBtnSave" onclick="saveMapInfo()">Save</button>
                </div>
            </div>
        </div>
    </div>
    -->

    <div class="mapInfoDialogOverlay" id='mapInfoDialogOverlay' onclick="if(event.target === this) document.getElementById('mapInfoDialogOverlay').style.display = 'none';">
        <div class="mapInfoDialog">
            <div class="mapInfoDialogContent">
                <h2 class="mapInfoDialogTitle">Map Info</h2>
                <div class="mapInfoFormGroup">
                    <label for="mapInfoName" class="mapInfoLabel">Map Name:</label>
                    <input type="text" id="mapInfoName" class="mapInfoInput" placeholder="Enter map name...">
                </div>
                <div class="mapInfoFormRow">
                    <div class="mapInfoFormGroup">
                        <label for="mapInfoWidth" class="mapInfoLabel">Width:</label>
                        <input type="text" id="mapInfoWidth" class="mapInfoInput" value="12">
                    </div>
                    <div class="mapInfoFormGroup">
                        <label for="mapInfoHeight" class="mapInfoLabel">Height:</label>
                        <input type="text" id="mapInfoHeight" class="mapInfoInput" value="9">
                    </div>
                </div>
                <div class="mapInfoFormGroup">
                    <label for="mapInfoDescription" class="mapInfoLabel">Description:</label>
                    <textarea id="mapInfoDescription" class="mapInfoTextarea mapInfoTextareaDescription" placeholder="Enter map description..."></textarea>
                </div>
                <div class="mapInfoFormRow">
                    <div class="mapInfoFormGroup">
                        <div class="mapInfoFormGroup">
                            <label class="mapInfoToggleLabel">
                                <input type="checkbox" id="mapInfoShowDots" class="mapInfoToggleInput">
                                <span class="mapInfoToggleSlider"></span>
                                <span class="mapInfoToggleText">Show Dots</span>
                            </label>
                        </div>
                        <div class="mapInfoFormGroup">
                            <label class="mapInfoToggleLabel">
                                <input type="checkbox" id="mapInfoShowHex" class="mapInfoToggleInput">
                                <span class="mapInfoToggleSlider"></span>
                                <span class="mapInfoToggleText">Show Hex Numbers</span>
                            </label>
                        </div>
                        <div class="mapInfoFormGroup">
                            <label class="mapInfoToggleLabel">
                                <input type="checkbox" id="mapInfoTexture" class="mapInfoToggleInput">
                                <span class="mapInfoToggleSlider"></span>
                                <span class="mapInfoToggleText">Texture!</span>
                            </label>
                        </div>
                    </div>
                    <div class="mapInfoFormGroup">
                        <label class="mapInfoLabel">Line Style:</label>
                        <div class="mapInfoRadioGroup">
                            <label class="mapInfoRadioOption">
                                <input type="radio" name="lineStyle" value="normal" id="mapInfoNormalLines" checked>
                                <span class="mapInfoRadioText">Normal Lines</span>
                            </label>
                            <br>
                            <label class="mapInfoRadioOption">
                                <input type="radio" name="lineStyle" value="handDrawn" id="mapInfoHandDrawn">
                                <span class="mapInfoRadioText">Hand-Drawn Lines</span>
                            </label>
                            <br>
                            <label class="mapInfoRadioOption">
                                <input type="radio" name="lineStyle" value="cornersOnly" id="mapInfoCornersOnly">
                                <span class="mapInfoRadioText">Corners Only</span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="mapInfoButtonGroup">
                    <button type="button" class="mapInfoButton mapInfoBtnCancel" onclick="document.getElementById('mapInfoDialogOverlay').style.display = 'none';">Cancel</button>
                    <button type="button" class="mapInfoButton mapInfoBtnSave" onclick="saveMapInfo()">Save</button>
                </div>
            </div>
        </div>
    </div>


    <div class="mapInfoDialogOverlay" id='wizardMapDB' onclick="if(event.target === this) document.getElementById('wizardMapDB').style.display = 'none';">
        <div class="mapInfoDialog">
            <div class="mapInfoDialogContent">
            Wizard Map Options
                <div class="mapInfoButtonGroup" style='flex-direction: column'>

                    <button type="button" class="mapInfoButton mapInfoBtnSave" onclick="wizardMap('e')">Empty Wizard Map</button>
                    <button type="button" class="mapInfoButton mapInfoBtnSave" onclick="wizardMap('w')">Wizard Map with walls</button>
                    <button type="button" class="mapInfoButton mapInfoBtnSave" onclick="wizardMap('f')">Wizard Map with Flames</button>
                    <button type="button" class="mapInfoButton mapInfoBtnSave" onclick="wizardMap('s')">Wizard Map with Shadows</button>
                    <button type="button" class="mapInfoButton mapInfoBtnSave" onclick="wizardMap('p')">Wizard Map with Pits</button>
                </div>
            </div>
        </div>
    </div>


    <!-- Backdrop -->
    <div id="helpBackdrop"></div>

    <!-- Help System -->
    <div id="helpSystem">
        <div class="help-header">
            <div class="help-tabs">
                <button class="help-tab active" data-section="general">General</button>
                <button class="help-tab" data-section="operations">Operations</button>
                <button class="help-tab" data-section="keys">Keys</button>
                <button class="help-tab" data-section="terrain">Terrain Tools</button>
                <button class="help-tab" data-section="settings">Settings</button>
                <button class="help-tab" data-section="about">About HexWright</button>
            </div>
            <button class="help-close" onclick="hideHelp()">×</button>
        </div>

        <div class="help-content">
            <!-- General Section -->
            <div class="help-section active" id="section-general">
                <h2>Welcome!</h2>
                <p>HexWright is an overwrought editor for hex maps for roleplaying games. While the map is presented visually in the upper part of the window, there is also a text description below, which is handier for saving, sharing and importing into other software. You can edit either the text or the display, any changes are instantly reflected in the other version.</p>

                <h3>Getting Started</h3>
                <p>Hover over one of the three interface icons to bring up the respective menus:</p>
                <ul>
                    <li>The Scroll icon has general operations.</li>
                    <li>The hexagon shows the currently selected terrain "tool".</li>
                    <li>No one knows what the Question Mark icon does</li>
                </ul>

                <h3>Basic Operations</h3>
                <p>Clicking on a hex will change it to the currently selected terrain type. Hold down the shift key, then click to "paint" with the current tool. Click and drag to move around the map. Zoom with the scroll wheel. Click anywhere on the mini map to jump there.</p>
                <p>Map Info (shortcut <span class="key-combo">i</span>) lets you change the size, name, and aesthetics of the map. Colors (<span class="key-combo">c</span>) lets you change the color palette. Settings (<span class="key-combo">;</span>) gives you some interface choices.</p>
            </div>

            <!-- Operations Section -->
            <div class="help-section" id="section-operations">
                <h2>Operations</h2>

                <ul>
                    <li><strong>Map Info</strong>
                    <span class="key-combo">i</span>
                    Start new projects or elements
                    </li>
                    <li><strong>All Map</strong>
                    <span class="key-combo">a</span>
                    Start new projects or elements
                    </li>
                    <li><strong>All Text</strong>
                    <span class="key-combo">t</span>
                    Start new projects or elements
                    </li>
                    <li><strong>Split Map/Text</strong>
                    <span class="key-combo">s</span>
                    Start new projects or elements
                    </li>
                    <li><strong>Save To Downloads</strong>
                    Start new projects or elements
                    </li>
                    <li><strong>Load from Disk</strong>
                    Start new projects or elements
                    </li>
                    <li><strong>Save Hi Res Image</strong>
                    Start new projects or elements
                    </li>
                    <li><strong>Settings</strong>
                    <span class="key-combo">;</span>
                    A few interface choices
                    </li>
                    <li><strong>Color</strong>
                    <span class="key-combo">c</span>
                    Choose or edit the color palette for your map
                    </li>
                    <li><strong>Privacy</strong>
                    Revisit the privacy explanations and options dialog
                    </li>
                </ul>

            </div>

            <!-- Keys Section -->
            <div class="help-section" id="section-keys">
                <h2>Keyboard Shortcuts</h2>
                <p>Use these keyboard shortcuts to work more efficiently:</p>

                <h3>Editing Shortcuts</h3>
                <ul style="list-style-type: none; padding-left: 0;">
                    <li><span class="key-combo">Shift</span> - hold mouse button down to "paint" with current terrain</li>
                    <li><span class="key-combo">d</span> toggles hex center dots</li>
                    <li><span class="key-combo">n</span> toggles display of hex numbers</li>
                    <li><span class="key-combo">1</span> Offboard - these hexes will not be part of the map</li>
                    <li><span class="key-combo">2</span> Clear - removes any other content, open hex</li>
                    <li><span class="key-combo">3</span> Wall - solid, blocked hex</li>
                    <p>Hover over the hexagonl tool icon to see the other terrain choices and their shortcuts, or check the next help section</p>
                </ul>

                <h3>Mini Map Shortcuts</h3>
                <ul style="list-style-type: none; padding-left: 0;">
                    <li><span class="key-combo">m</span> - toggle mini map visibility</li>
                    <li><span class="key-combo">p</span> - move the mini map to another corner</li>
                    <li><span class="key-combo">[</span> - small mini map</li>
                    <li><span class="key-combo">]</span> - medium mini map</li>
                    <li><span class="key-combo">\</span> - large mini map</li>
                </ul>
            </div>

            <!-- Terrain Tools Section -->
            <div class="help-section" id="section-terrain">
            <div class="tertools-grid-layout">
                <div class="tertools-tool-name">Lava</div>
                <div class="tertools-key-combo">&#96;</div>
                <div class="tertools-description">Lava very bad, use sparingly; may also be acid depending on where it is encountered and what color it is. See bridges below.</div>

                <div class="tertools-tool-name">Offboard</div>
                <div class="tertools-key-combo">1</div>
                <div class="tertools-description">What used to be a hex will no longer be part of the map</div>

                <div class="tertools-tool-name">Clear</div>
                <div class="tertools-key-combo">2</div>
                <div class="tertools-description">Clears any contents, creates an open hex</div>

                <div class="tertools-tool-name">Wall Hex</div>
                <div class="tertools-key-combo">3</div>
                <div class="tertools-description">A solid wall, completely blocked hex</div>

                <div class="tertools-tool-name">Pit</div>
                <div class="tertools-key-combo">4</div>
                <div class="tertools-description">Very deep, try to keep out.</div>

                <div class="tertools-tool-name">Path</div>
                <div class="tertools-key-combo">5</div>
                <div class="tertools-description">No game effect</div>

                <div class="tertools-tool-name">Trap Door</div>
                <div class="tertools-key-combo">6</div>
                <div class="tertools-description">No game effect, looks out of place except in a dungeon</div>

                <div class="tertools-tool-name">Debris</div>
                <div class="tertools-key-combo">7</div>
                <div class="tertools-description">Enough to interfere with movement and combat</div>

                <div class="tertools-tool-name">Water</div>
                <div class="tertools-key-combo">8</div>
                <div class="tertools-description">Chest deep, very awkward. See bridges below.</div>

                <div class="tertools-tool-name">Barricade</div>
                <div class="tertools-key-combo">9</div>
                <div class="tertools-description">High enough to block movement but no missiles or jabs</div>

                <div class="tertools-tool-name">Shadow</div>
                <div class="tertools-key-combo">0</div>
                <div class="tertools-description">Magical Shadow</div>

                <div class="tertools-tool-name">Flame</div>
                <div class="tertools-key-combo">-</div>
                <div class="tertools-description">Burning material or magical flame</div>

                <div class="tertools-tool-name">Sticky</div>
                <div class="tertools-key-combo">u</div>
                <div class="tertools-description">Displayed in the editor but not in TFT Trainer. Works like the spell.</div>

                <div class="tertools-tool-name">Slippery</div>
                <div class="tertools-key-combo">h</div>
                <div class="tertools-description">Displayed in the editor but not in TFT Trainer. Works like the spell.</div>

                <div class="tertools-tool-name">Body</div>
                <div class="tertools-key-combo">=</div>
                <div class="tertools-description">Body on the ground</div>

                <div class="tertools-tool-name">Tar Pit</div>
                <div class="tertools-key-combo">=</div>
                <div class="tertools-description">Very sticky. Like the spell, but you can see it.</div>

                <div class="tertools-tool-name">Column</div>
                <div class="tertools-key-combo">a</div>
                <div class="tertools-description">A column or tree. A character cannot move here, but you can jab through this hex. Missiles are blocked only if the LOS actually passes through the column.</div>

                <div class="tertools-tool-name">Stone</div>
                <div class="tertools-key-combo">r</div>
                <div class="tertools-description">On land this is a waist high rock that blocks movement but not jabbing or missiles. In water or lava it is a flat topped stone you can jump to move across like a clear hex.</div>

                <div class="tertools-tool-name">Wood Table</div>
                <div class="tertools-key-combo">f</div>
                <div class="tertools-description">Does not block missiles or jabs. 3 MA to climb onto to get the height bonuses.</div>

                <div class="tertools-tool-name">Stone Altar</div>
                <div class="tertools-key-combo">g</div>
                <div class="tertools-description">Does not block missiles or jabs. 3 MA to climb onto to get the height bonuses.</div>

                <div class="tertools-tool-name">Pentacle</div>
                <div class="tertools-key-combo">j</div>
                <div class="tertools-description">Purely cosmetic. Let us say this is for Shamat compatibility.</div>

                <div class="tertools-tool-name">Bridge</div>
                <div class="tertools-key-combo">b</div>
                <div class="tertools-description">When this tool is selected you first click on the starting hex, then the final hex. If you want to use your map with TFT Trainer you need to make sure bridges run along the hex grid, not across. You will get a warning box. If not you will have a map usable for human moderated games but TFT Trainer will ignore the bridge. The only way to delete a bridge is to delete the text version of it. The app will guess the appropriate type of bridge based on the palette; if you want to change it you must do it by editing the text.</div>

                </div>

                <p>
                There are a few cosmetic features with no menu or short cut key access. You can add a line "darker" and list hexes you want to be slightly darker than other hexes. You can do the same with "lighter" You can say "star" and list hexes that will have a star at the center.
                </p>
                <p>
                If you put "Graphic: Melee" or "Graphic - wizard" you can include those logos, but you need to make that work with the other colors and map edges. "Graphic arcane" will give your map a border of arcane(ish) symbols.
                </p>


<!--
                // <ul style="list-style-type: none; padding-left: 0;">
                //     <li><strong>Lava</strong>
                //     <span class="key-combo">&#96;</span>
                //      Lava very bad, use sparingly</li>
                //     <li><strong>Offboard</strong>
                //     <span class="key-combo">1</span>
                //      What used to be a hex will no longer be part of the map</li>
                //     <li><strong>Clear</strong>
                //     <span class="key-combo">2</span>
                //      Clears any contents, creates an open hex</li>
                //     <li><strong>Wall Hex</strong>
                //     <span class="key-combo">3</span>
                //      A solid wall, completely blocked hex</li>
                // </ul>
-->

            </div>

            <!-- Settings Section -->
            <div class="help-section" id="section-settings">
                <h2>Settings</h2>
                <p>Customize the application behavior and appearance through the settings panel, accesible through the Operations menu or by pressing <span class="key-combo">;</span>.</p>

                <h3>Group By</h3>
                <p>
                  When the map is converted into text this setting determines whether it will be one long list of hexes with the terrain types for each or a list of the terrain types with all the hexes they apply to.
                </p>

                <h3> Mini Map</h3>
                <p>
                  Self-explanatory, but remember that <span class="key-combo">p</span> will cycle the mini map to each corner.
                </p>

                <h3>Menu Icon Position</h3>
                <p>
                  My indecisiveness becomes your option!
                </p>
            </div>

            <!-- About Section -->
            <div class="help-section" id="section-about">
                <h2>About HexWright</h2>
                <p>The Fantasy Trip </p>

                <p>Of course, there was already an excellent hex map generator for The Fantasy Trip by the name of ShaMat, available along with a *lot* of other material for The Fantasy Trip at <a href='https://shadekeep.com/'>Shadekeep</a>.</p>

                <p>If you just need a blank hex grid I always use <a href='https://incompetech.com/graphpaper/hexagonal/'>Incompetech</a> but it does not do numbers. If you need that try <a href='https://hexgridgenerator.github.io/'>hexgridgenerator.github.io/</a>.</p>

                <p>Click here if you are unfamiliar with <a href='https://thefantasytrip.game/about/'>The Fantasy Trip</a>.</p>

                <p>This app and its associated code, art, etc is Copyright 2025 C. Andrew Walters</p>

                <p>The Fantasy Trip is Copyright Steve Jackson Games</p>
            </div>

        </div>
    </div>

    <div id="settingsBackdrop"></div>

    <!-- Settings Window -->
    <div id="settingsWindow">
        <div class="settings-header">
            <h2 class="settings-title">Settings</h2>
            <button class="settings-close" onclick="hideSettings()">×</button>
        </div>

        <div class="settings-content">

            <div class="setting-item radio-setting">
                <div class="setting-label">Preparing Text Version</div>
                <div class="radio-group">
                    <label class="radio-item" onchange='groupBy("terrain")'>
                        <input type="radio" name="groupBy" value="terrain" class="radio-input" checked>
                        <span class="radio-custom"></span>
                        <span class="radio-label">Group by Terrain Type</span>
                    </label>
                    <label class="radio-item" onchange='groupBy("hex number")'>
                        <input type="radio" name="groupBy" value="hex number" class="radio-input">
                        <span class="radio-custom"></span>
                        <span class="radio-label">Group by hex number</span>
                    </label>
                </div>
            </div>

            <div class="setting-item radio-setting">
                <div class="setting-label">MiniMap Size</div>
                <div class="radio-group">
                    <label class="radio-item" onchange='setMiniMapSmall()'>
                        <input type="radio" name="miniMapSize" value="small" class="radio-input" checked>
                        <span class="radio-custom"></span>
                        <span class="radio-label">Small Mini Map ([)</span>
                    </label>
                    <label class="radio-item" onchange='setMiniMapMedium()'>
                        <input type="radio" name="miniMapSize" value="medium" class="radio-input">
                        <span class="radio-custom"></span>
                        <span class="radio-label">Medium Mini Map (])</span>
                    </label>
                    <label class="radio-item" onchange='setMiniMapLarge()'>
                        <input type="radio" name="miniMapSize" value="large" class="radio-input">
                        <span class="radio-custom"></span>
                        <span class="radio-label">Large Mini Map (\)</span>
                    </label>
                </div>
            </div>

            <div class="setting-item">
                <div class="setting-label">Show MiniMap</div>
                <div class="toggle-switch" id="showMiniMapToggle" onclick="toggleSetting('showMiniMap')">
                    <div class="toggle-slider"></div>
                </div>
            </div>


            <!-- begin positioning  stuff -->


<!-- Add this to your settings dialog -->
<div class="setting-item radio-setting">
    <div class="setting-label">Menu Icon Position</div>
    <div class="visual-radio-group">

        <!-- Horizontal Top-Left -->
        <label class="visual-radio-item">
            <input type="radio" name="iconPosition" value="horizontal-top-left" class="visual-radio-input" checked>
            <div class="icon-preview layout-h-tl">
                <div class="mini-icon"></div>
                <div class="mini-icon"></div>
                <div class="mini-icon"></div>
            </div>
            <div class="visual-radio-label">Horizontal<br>Top-Left</div>
        </label>

        <!-- Vertical Top-Left -->
        <label class="visual-radio-item">
            <input type="radio" name="iconPosition" value="vertical-top-left" class="visual-radio-input">
            <div class="icon-preview layout-v-tl">
                <div class="mini-icon"></div>
                <div class="mini-icon"></div>
                <div class="mini-icon"></div>
            </div>
            <div class="visual-radio-label">Vertical<br>Top-Left</div>
        </label>

        <!-- Three Corners -->
        <label class="visual-radio-item">
            <input type="radio" name="iconPosition" value="three-corners" class="visual-radio-input">
            <div class="icon-preview layout-corners">
                <div class="mini-icon"></div>
                <div class="mini-icon"></div>
                <div class="mini-icon"></div>
            </div>
            <div class="visual-radio-label">Three<br>Corners</div>
        </label>

        <!-- Horizontal Top-Right -->
        <label class="visual-radio-item">
            <input type="radio" name="iconPosition" value="horizontal-top-right" class="visual-radio-input">
            <div class="icon-preview layout-h-tr">
                <div class="mini-icon"></div>
                <div class="mini-icon"></div>
                <div class="mini-icon"></div>
            </div>
            <div class="visual-radio-label">Horizontal<br>Top-Right</div>
        </label>

        <!-- Vertical Top-Right -->
        <label class="visual-radio-item">
            <input type="radio" name="iconPosition" value="vertical-top-right" class="visual-radio-input">
            <div class="icon-preview layout-v-tr">
                <div class="mini-icon"></div>
                <div class="mini-icon"></div>
                <div class="mini-icon"></div>
            </div>
            <div class="visual-radio-label">Vertical<br>Top-Right</div>
        </label>

        <!-- Horizontal Bottom-Left -->
        <label class="visual-radio-item">
            <input type="radio" name="iconPosition" value="horizontal-bottom-left" class="visual-radio-input">
            <div class="icon-preview layout-h-bl">
                <div class="mini-icon"></div>
                <div class="mini-icon"></div>
                <div class="mini-icon"></div>
            </div>
            <div class="visual-radio-label">Horizontal<br>Bottom-Left</div>
        </label>

    </div>
</div>

<!-- end positioning  stuff -->



        </div>
    </div>

    <div class="mapInfoDialogOverlay exportDialogOverlay">
        <div class="mapInfoDialog exportDialog">
            <div class="mapInfoDialogContent">
                <h2 class="mapInfoDialogTitle">Export High Resolution Image</h2>

                <div class="exportExplanation">
                    <p>Export your map as a high-resolution image suitable for printing or professional use. Higher DPI values create larger, more detailed images but result in bigger file sizes.</p>
                    <p>Choose your preferred settings below:</p>
                </div>

                <div class="exportRadioGroup">
                    <h4>Resolution (DPI)</h4>
                    <div class="exportRadioOption">
                        <input type="radio" id="exportDpi72" name="exportDpi" value="72">
                        <label for="exportDpi72">72 DPI (Screen quality)</label>
                    </div>
                    <div class="exportRadioOption">
                        <input type="radio" id="exportDpi300" name="exportDpi" value="300">
                        <label for="exportDpi300">300 DPI (Print quality)</label>
                    </div>
                    <div class="exportRadioOption exportCustomDpiRow">
                        <input type="radio" id="exportDpiCustom" name="exportDpi" value="custom">
                        <label for="exportDpiCustom">Custom:</label>
                        <input type="number" id="exportCustomDpi" class="exportCustomDpiInput" min="1" max="3000" placeholder="300">
                        <span style="color: #654321; font-size: 12px;">DPI</span>
                    </div>
                </div>

                <div class="exportRadioGroup">
                    <h4>File Format</h4>
                    <div class="exportRadioOption">
                        <input type="radio" id="exportFormatPng" name="exportFormat" value="png">
                        <label for="exportFormatPng">PNG (Lossless, larger file)</label>
                    </div>
                    <div class="exportRadioOption">
                        <input type="radio" id="exportFormatJpg" name="exportFormat" value="jpg">
                        <label for="exportFormatJpg">JPG (Compressed, smaller file)</label>
                    </div>
                </div>

                <div class="exportQualityGroup">
                    <h4>JPG Quality</h4>
                    <input type="range" id="exportQualitySlider" class="exportQualitySlider" min="10" max="100" value="90" step="5">
                    <div id="exportQualityValue" class="exportQualityValue">90%</div>
                </div>

                <div class="exportFileSizeInfo">
                    File size information will appear here...
                </div>

                <div class="mapInfoButtonGroup">
                    <button class="mapInfoButton mapInfoBtnCancel exportBtnCancel">Cancel</button>
                    <button class="mapInfoButton mapInfoBtnSave exportBtnSave">Export Image</button>
                </div>
            </div>
        </div>
    </div>

    <canvas id='offscreenCanvas' style='display:none'>
    </canvas>

    <img id='trapdoor' src='art/trapdoor.png' style='display: none;'>
    <img id='fire' src='art/fire.png' style='display: none;'>
    <img id='shadow' src='art/shadow.png' style='display: none;'>

    <img id='body1' src='art/body1.png' style='display: none;'>
    <img id='body2' src='art/body2.png' style='display: none;'>

    <img id='table' src='art/table.png' style='display: none;'>

    <div class='testMap' id='testMap1' onclick='testMap(1)'>
      Test 1
    </div>

    <div class='testMap' id='testMap2' onclick='testMap(2)'>
      Test 2
    </div>

    <div class='testMap' id='testMap3' onclick='testMap(3)'>
      Test 3
    </div>

    <div class='testMap' id='testMap4' onclick='testMap(4)'>
      Test 4
    </div>

    <div class='testMap' id='testMap5' onclick='testMap(5)'>
      Test 5
    </div>

    <div class='testMap' id='testMap6' onclick='testMap(6)'>
      Test 6
    </div>

    <div class='testMap' id='testMap7' onclick='testMap(7)'>
      Melee
    </div>

    <div class='testMap' id='testMap8' onclick='testMap(8)'>
      Wizard
    </div>

    <div id='bridgeWarningDiv' onclick="this.style.display='none'" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); z-index: 19; cursor: pointer;">

      <div id='bridgeWarningBox'>

        <div class="settings-header">
            <h2 class="settings-title">Bridge Warning</h2>
            <button class="settings-close" onclick="hideSettings()">×</button>
        </div>

        <div class="settings-content">

        This bridge does not go straight along the hex grain. This is fine if you are creating a map to print or use yourself, but it will not work with TFT Trainer.
        </div>
      </div>

    </div>

    <img id='meleeLogo' src="art/MeleeLogo.png" style="display: none;">
    <img id='wizardLogo' src="art/WizardLogo.png" style="display: none;">


    <div id='shamatWarningDiv' style='position: relative; display: none; width: 50vw; margin: 0 auto; z-index: 14; top: 10vh;'>
        <img src='art/scroll3.jpg' style='width: 100%; height: auto;'>
        <img src='art/swordy.jpg' style='position: absolute; top: 10%; left: 50%; transform: translateX(-50%); height: 8vh; width: auto;'>
        <div style='position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; padding: 20px; border-radius: 10px; font-size: 1.2rem; width: 80%; max-width: calc(50vw - 40px);'>
        <p>
            It looks like you are trying to import a map from Shamat! There are a couple things you should know.
        </p>
        <p>
            Shamat implements a lot of subtlety about what can be in a hex, whereas HexWright only recognizes full hexes of wall, water, etc. So Shamat hexes containing any black will be walls here. Blue hexes will be water. Red hexes will be lava. Pits and trapdoors carry over, and pentagrams become pentacles. Nothing else is converted.
        </p>
        </div>
        <button onclick="hideShamatWarning();" style='position: absolute; bottom: 15%; left: 50%; transform: translateX(-50%); background: #8B4513; color: #F4E4BC; border: 2px solid #654321; padding: 12px 24px; font-size: 1.1rem; border-radius: 8px; cursor: pointer; font-family: serif; box-shadow: 2px 2px 4px rgba(0,0,0,0.3);'>
            Proceed with Import
        </button>
    </div>


    <div id='testText1' style='display: none'>

Name: The Bottom of the Dungeon
Description: featuring lava!
Height: 9
Width: 12
Palette: Cavern
Offboard: 0,7 0,8 1,8 2,8 3,1 9,0 10,0 11,0 11,1
Walls: 0,5 1,5 2,3 2,4 3,4
Water: 3,6 4,6 4,7 4,8 5,5 5,6 5,7 5,8 6,3 6,4 6,5 6,6 7,3 7,4 7,5 8,2 8,3 9,2 9,3 10,1 10,2 11,2
Path: 0,0 1,1 2,1 3,2 4,2 5,3 8,4 9,5 9,6 9,7 10,7 11,8
Column: 8,5 9,4
Fire: 5,4
Body: 4,3
Shadow: 1,4
Debris: 4,1 6,7
Trapdoor: 0,2
Lava: 8,7 8,8 9,8 11,6 11,7
Stone: 3,6
Pits: 2,5 5,1 8,0
Darker: 10,8 11,4 11,8
lighter 5,0 6,0 7,0
Stars: 0,0 0,1 1,0
stone bridge from 5,3 to 8,4


    </div>

    <div id='testText2' style='display: none'>

Name: Ocean
Description: hope you have the swimming Talent
Height: 10
Width: 16
Palette: Desert
Offboard: 0,0 0,8 0,9 1,0 1,1 1,9 2,0 2,9
Walls: 1,4 1,5
Water: 2,1 2,2 2,6 2,8 3,0 3,1 3,2 3,3 3,6 3,7 3,8 3,9 4,0 4,1 4,2 4,5 4,6 4,7 4,8 4,9 5,0 5,1 5,2 5,3 5,6 5,7 5,8 5,9 6,0 6,1 6,2 6,5 6,6 6,7 6,8 6,9 7,0 7,1 7,2 7,3 7,6 7,7 7,8 7,9 8,0 8,1 8,2 8,5 8,6 8,7 8,8 8,9 9,0 9,1 9,2 9,3 9,5 9,6 9,7 9,8 9,9 10,1 10,2 10,3 10,4 10,5 10,6 10,7 10,8 10,9 11,3 11,4 11,5 11,6 11,7 11,8 11,9 12,2 12,3 12,4 12,5 12,6 12,7 12,8 12,9 13,3 13,4 13,5 13,6 13,7 13,8 13,9 14,3 14,4 14,5 14,6 14,7 14,8 14,9 15,4 15,5 15,6 15,7 15,8 15,9
Column: 9,4
Fire: 3,4
Shadow: 1,6
Debris: 10,0 11,1 13,2
Lava: 13,0 14,0 15,0 15,1
Stone: 2,1 3,1 4,0 5,1 6,0 7,1 8,0 9,1 12,7
Pits: 0,4
Darker: 1,8
Lighter: 1,7
stone bridge from 8,3 to 11,2
wood bridge from 7,5 to 12,7

    </div>

    <div id='testText3' style='display: none'>

    Name: Ambush by the Old Bridge
    Description: Between the rocks, over the bridge, into the woods
    Height: 6
    Width: 24
    Show Dots: no
    Show hex Numbers: no
    Add Texture: yes
    Line Style: handDrawn
    Palette: Wild Lands
    Walls: 0,0 0,1 0,3 0,4 0,5
    Water: 10,0 10,1 10,2 10,3 10,4 11,0 11,1 11,2 11,3 11,4 11,5 12,1 12,2 12,3 12,4 12,5
    Path: 0,2 1,3 2,3 3,3 4,2 5,2 6,1 7,2 8,2 8,3 9,4 13,2 14,1 15,1 16,1 17,2 18,2 19,3 20,3 21,4 22,3 23,3
    Column: 9,3 13,0 14,5 15,2 15,4 17,1 18,4 19,2 21,3 21,5 22,0
    Fire: 6,4
    Shadow: 7,1
    Lava: 3,4
    Stone: 6,2 11,5 12,5
    Darker: 3,0 4,0 5,0
    Stars: 0,2 23,3
    wood bridge from 13,2 to 9,4

    </div>

    <div id='testText4' style='display: none'>

    Name: Nasty Swamp
    Description: You couldn't build a castle here.
    Height: 9
    Width: 12
    Palette: Swamp
    Offboard: 0,8 6,8 7,8 8,7 8,8 9,0 9,1 9,7 9,8 10,0 10,1 10,6 10,7 10,8 11,0 11,1 11,2 11,6 11,7 11,8
    Walls: 0,0 0,1 1,0 1,1 1,2 2,1 2,2 3,2 3,3 3,4 4,2 4,3 4,4
    Water: 3,8 4,5 4,6 4,7 5,5 6,2 6,3 6,4 7,0 7,1 7,2 7,3
    Path: 0,3 1,4 1,5 1,6 1,7 2,7 3,7 5,0 5,1 5,6 6,1 6,5 7,5 8,2 8,3 8,4
    Column: 0,7 7,4 11,3
    Fire: 9,3
    Body: 1,3
    Shadow: 2,8 4,8 7,7 8,6
    Debris: 4,1 6,0 9,4 10,4
    Lava: 0,5 2,4
    Stone: 2,6
    Darker: 10,4
    Lighter: 10,5
    stone bridge from 5,6 to 3,7
    wood bridge from 6,1 to 8,2
    Tar: 6,6 7,6 8,5 9,6



    </div>


    <div id='testText5' style='display: none'>

Name: Frozen Crevice
Description: ...A place shrouded in mystery and silence, untouched by map or legend.
Height: 9
Width: 12
Palette: Frozen
Offboard: 0,7 0,8 1,8 2,8 4,8 9,0 10,0 11,0 11,1
Walls: 0,6 1,7 2,7 3,8 7,0 8,0 9,1 10,1 10,2 11,2 11,3
Water: 2,3 5,0 5,1 5,2 5,3 5,4 5,5 5,6 5,7 5,8 6,0 6,1 6,2 6,3 6,4 6,5 6,6 6,7 6,8 11,5
Path: 0,1 1,2 2,2 3,3 4,3 7,5 8,5 9,6 10,6 11,7
Column: 9,4
Shadow: 0,3 3,1 3,6 10,4 10,7
Debris: 1,5 2,1 7,6 8,2
Darker: 4,4
Lighter: 4,2
stone bridge from 4,3 to 7,5




    </div>


    <div id='testText6' style='display: none'>

    Name: Walls & Deco
    Description: a mixed up place
    Height: 9
    Width: 12
    Palette: Wild Lands
    Walls: 1,1 3,4 4,4 6,1 6,2 6,3 7,8
    Water: 0,0 8,0
    Debris: 3,1
    bodies 2,2.  7,1
    pond 1,4
    barricade 3,6 3,7 3,8
    pits 8,3 8,4 8,5 9,5
    path 7,3 8,2 10,1 11,2
    Trapdoor: 0,5
    Shadows 10,7
    fire 1,2
    body 8,7
    5,0 body



    </div>


    <div id='testText7' style='display: none'>

Name: Melee
Description: the classic map
Graphic: Melee
Height: 9
Width: 15
Show hex Numbers: no
Palette: Melee
Megahex centers on: 2,2
Offboard: 0,0 0,1 0,2 0,3 0,8 1,0 1,1 2,0 2,8 3,0 3,1 4,0 4,8 5,0 5,8 6,0 6,8 7,0 7,8 8,7 8,8 9,0 9,8 10,7 10,8 11,7 11,8 12,7 12,8 13,7 13,8 14,4 14,5 14,6 14,7 14,8
star 0,6 1,7 0,7 1,8
star 13,0 13,1 14,0 14,1

    </div>
    <div id='testText8' style='display: none'>

Name: Wizard
Description: The Classic Map
Graphic: Wizard
Height: 13
Width: 16
Show hex Numbers: no
Palette: Wizard
Megahex centers on: 2,2
Offboard: 0,0 0,1 0,2 0,3 0,6 0,7 0,8 0,9 0,10 0,11 0,12 1,0 1,1 1,7 1,8 2,0 3,0 3,1 4,0 5,0 6,0 6,12 7,0 8,12 9,0 9,12 10,12 11,12 12,11 12,12 13,12 14,4 14,5 14,11 14,12 15,0 15,1 15,2 15,3 15,4 15,5 15,6 15,9 15,10 15,11 15,12

Darker: 3,4 3,5 4,3 4,4 4,5 4,8 4,9 5,4 5,5 5,8 5,9 5,10 6,3 6,4 6,8 6,9 7,3 7,4 7,5 7,8 7,9 8,3 8,4 8,7 8,8 8,9 9,3 9,4 9,8 9,9 10,2 10,3 10,4 10,7 10,8 11,3 11,4 11,7 11,8 11,9 12,7 12,8

stars 1,11 1,12 2,11 2,12
stars 13,0 13,1 14,0 14,1

    </div>


  </body>



</html>
